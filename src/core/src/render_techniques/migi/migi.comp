#ifndef USE_INLINE_RT
#define USE_INLINE_RT 1
#endif

#ifndef WARP_SIZE
// NVIDIA's default warp size
#define WARP_SIZE 32
#endif

#define MIN_COLOR 0.000001f

// Shared structs among CPU and GPU
#include "../../gpu_shared.h"

// Parameters & Globals & Helper functions
#include "migi_inc.hlsl"

// Library for MIGI
#include "migi_lib.hlsl"

// Hash grid cache library
#include "hash_grid_cache.hlsl"
// World space ReSTIR library
#include "world_space_restir.hlsl"

#define MAX_HIT_DISTANCE 1e9f

struct ScreenCacheUpdatePayload
{
    float3 sky_sample;
    float hit_dist;
};

struct PopulateCellsPayload
{
    uint      query_index;
    float3    world;
    float3    normal;
    float3    lighting;
    Reservoir reservoir;
};

struct TraceReflectionsPayload
{
    int2   full_pos;
    float3 radiance;
    float2 s;
    float  hit_distance;
};


// A naive kernel for generating dispatch commands
[numthreads(1, 1, 1)]
void GenerateDispatch()
{
    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = (g_CountBuffer[0] + g_GroupSize - 1) / g_GroupSize;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

[numthreads(1, 1, 1)]
void GenerateDispatchRays()
{
    DispatchRaysCommand dispatch_rays_command;
    dispatch_rays_command.ray_generation_shader_record = g_RTConstants.ray_generation_shader_record;
    dispatch_rays_command.miss_shader_table = g_RTConstants.miss_shader_table;
    dispatch_rays_command.hit_group_table = g_RTConstants.hit_group_table;
    dispatch_rays_command.callable_shader_table = g_RTConstants.callable_shader_table;
    dispatch_rays_command.width = g_CountBuffer[0];
    dispatch_rays_command.height = 1;
    dispatch_rays_command.depth = 1;
    dispatch_rays_command.padding[0] = 0;
    dispatch_rays_command.padding[1] = 0;
    dispatch_rays_command.padding[2] = 0;
    g_RWDispatchRaysCommandBuffer[0] = dispatch_rays_command;
}

[numthreads(64, 1, 1)]
void PurgeTiles(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_PreviousPackedTileCountBuffer[0])
    {
        return; // out of bounds
    }

    // We opt for calculating the decay of each tile from the
    // current frame index, as it saves many writes per frame
    // and is quite a bit faster than having to decrement all
    // cell's decay values.
    uint tile_index = g_HashGridCache_PreviousPackedTileIndexBuffer[did];
    uint tile_decay = g_HashGridCache_DecayTileBuffer[tile_index];

    if (g_FrameIndex < tile_decay)   // account for integer wraparound case
    {
        tile_decay = ((0xFFFFFFFFu - tile_decay) + g_FrameIndex + 1);
    }
    else
    {
        tile_decay = (g_FrameIndex - tile_decay);
    }

    if (tile_decay >= kHashGridCache_TileDecay)
    {
        g_HashGridCache_HashBuffer[tile_index] = 0;

#ifdef DEBUG_HASH_CELLS
        // Clear all mipmaps
        for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile; ++cell_offset)
        {
            uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
            g_HashGridCache_DecayCellBuffer[cell_index] = 0xFFFFFFFFu;
        }
#endif // DEBUG_HASH_CELLS

        return; // kill the tile
    }

    uint packed_tile_index;
    InterlockedAdd(g_HashGridCache_PackedTileCountBuffer[0], 1, packed_tile_index);
    g_HashGridCache_PackedTileIndexBuffer[packed_tile_index] = tile_index;
}

[numthreads(1, 1, 1)]
void ClearCounters()
{
    g_Reservoir_HashListCountBuffer[0] = 0; // reset counters

    g_HashGridCache_PackedTileCountBuffer[0]    = 0;
    g_HashGridCache_UpdateTileCountBuffer[0]    = 0;
    g_HashGridCache_VisibilityCountBuffer[0]    = 0;
    g_HashGridCache_VisibilityRayCountBuffer[0] = 0;
    
}

void ScreenCacheUpdateHandleHit(uint DispatchID, inout ScreenCacheUpdatePayload payload, RayDesc ray, HitInfo hit_info)
{
    HashGridCache_Data data;
    data.eye_position = g_CameraPosition;
    data.hit_position = ray.Origin + payload.hit_dist * ray.Direction;
    data.direction    = ray.Direction;
    data.hit_distance = payload.hit_dist;

    uint tile_index;
    bool is_new_tile;
    uint cell_index = HashGridCache_InsertCell(data, tile_index, is_new_tile);

    if (cell_index != kGI10_InvalidId)
    {
        // Bump the cell's decay to the max. now that it's been 'touched'
        uint previous_tile_decay;
        InterlockedExchange(g_HashGridCache_DecayTileBuffer[tile_index], g_FrameIndex, previous_tile_decay);

        HashGridCache_Visibility visibility;
        visibility.is_front_face   = hit_info.frontFace;
        visibility.instance_index  = hit_info.instanceIndex;
        visibility.geometry_index  = hit_info.geometryIndex;
        visibility.primitive_index = hit_info.primitiveIndex;
        visibility.barycentrics    = hit_info.barycentrics;

        // We update the cell index for later passes
        uint visibility_index;
        InterlockedAdd(g_HashGridCache_VisibilityCountBuffer[0], 1, visibility_index);
        g_HashGridCache_VisibilityBuffer[visibility_index]      = HashGridCache_PackVisibility(visibility);
        g_HashGridCache_VisibilityCellBuffer[visibility_index]  = cell_index;
        g_HashGridCache_VisibilityQueryBuffer[visibility_index] = DispatchID;

        // Write out bounds of visibility
        requestLightSampleLocation(data.hit_position);

        // If this cell is inside a new tile, we need to add the tile to the packed storage and clear its cells.
        if (is_new_tile)
        {
            uint packed_tile_index;
            InterlockedAdd(g_HashGridCache_PackedTileCountBuffer[0], 1, packed_tile_index);
            g_HashGridCache_PackedTileIndexBuffer[packed_tile_index] = tile_index;

            // Clear mip0 cells (others will be reset anyways by UpdateTiles)
            for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile_mip0; ++cell_offset)
            {
                uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
                g_HashGridCache_ValueBuffer[cell_index] = uint2(0, 0);
            }
        }

        // If we're the 1st invocation touching this cell (this frame), we want to clear the
        // scratch storage that'll be used for atomically updating the radiance.
        // The accumulation will be resolved in the 'UpdateTiles()' kernel to
        // avoid integer overflow.
        if (is_new_tile || previous_tile_decay != g_FrameIndex)
        {
            uint update_tile_index;
            InterlockedAdd(g_HashGridCache_UpdateTileCountBuffer[0], 1, update_tile_index);
            g_HashGridCache_UpdateTileBuffer[update_tile_index] = tile_index;
        }

#ifdef DEBUG_HASH_CELLS
        // For debugging purposes, we need to be able to retrieve the position
        // & orientation of cells as we iterate the content of the cache.
        // So, write the packed cell descriptor out to memory in this case.
        if (is_new_tile)
        {
            // Clear debug cells (all mips)
            for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile; ++cell_offset)
            {
                uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
                g_HashGridCache_DebugCellBuffer[cell_index] = HashGridCache_ClearDebugCell();
            }
        }

        float4 packed_debug_cell;
        uint debug_cell_index = HashGridCache_PackDebugCell(data, tile_index, packed_debug_cell);

        // BE CAREFUL: writing to g_HashGridCache_DebugCellBuffer isn't atomic and several writings could occur
        uint previous_cell_decay;
        InterlockedExchange(g_HashGridCache_DecayCellBuffer[debug_cell_index], g_FrameIndex, previous_cell_decay);
        if (previous_cell_decay != g_FrameIndex)
        {
            g_HashGridCache_DebugCellBuffer[debug_cell_index] = packed_debug_cell;
        }
#endif // DEBUG_HASH_CELLS
    }
}

void ScreenCacheUpdateHandleMiss(inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    payload.sky_sample = g_EnvironmentBuffer.SampleLevel(g_TextureSampler, ray.Direction, 0.0f).xyz;
}

void ScreenCacheUpdateTraceRayInline(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    ClosestRayQuery ray_query = TraceRay<ClosestRayQuery>(ray);

    // If we hit some geometry, we append a new world-space hash-grid cache query
    if (ray_query.CommittedStatus() == COMMITTED_NOTHING)
    {
        payload.hit_dist = ray_query.CommittedRayT();
        ScreenCacheUpdateHandleMiss(payload, ray);
    }
    else
    {
        payload.hit_dist = ray_query.CommittedRayT();
        ScreenCacheUpdateHandleHit(did, payload, ray, GetHitInfoRtInlineCommitted(ray_query));
    }
}

void ScreenCacheUpdateTraceRayRt(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    TraceRay(g_Scene, RAY_FLAG_NONE, 0xFFu, 0, 0, 0, ray, payload);
}

void ScreenCacheUpdateTraceRay(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
#if USE_INLINE_RT
    ScreenCacheUpdateTraceRayInline(did, payload, ray);
#else
    ScreenCacheUpdateTraceRayRt(did, payload, ray);
#endif
}


// Trace visibility rays to generate intersections for secondary vertices
void TraceUpdateRays (uint2 DispatchID) {
    if(DispatchID.x >= g_OutputDimensions.x || DispatchID.y >= g_OutputDimensions.y) return ;
    
    float2 UV = (DispatchID + 0.5f) / float2(g_OutputDimensions);

    float4 Visibility   = g_VisibilityTexture.Load(int3(DispatchID, 0));
    float2 Barycentrics = Visibility.xy;
    uint   InstanceID   = asuint(Visibility.z);
    uint   PrimitiveID  = asuint(Visibility.w);

    Instance InstanceData  = g_InstanceBuffer[InstanceID];
    Mesh     MeshData      = g_MeshBuffer[InstanceData.mesh_index];
    float3x4 Transform     = g_TransformBuffer[InstanceData.transform_index];

    Triangle vertices = fetchVertices(MeshData, PrimitiveID);
    float3 v0 = transformPoint(vertices.v0, Transform);
    float3 v1 = transformPoint(vertices.v1, Transform);
    float3 v2 = transformPoint(vertices.v2, Transform);

    float3 WorldPixelPosition  = interpolate(v0, v1, v2, Barycentrics);
    
    float3 GeometryNormal = normalize(2.0f * g_GeometryNormalTexture.Load(int3(DispatchID, 0)).xyz - 1.0f);
    float3 ShadingNormal  = normalize(2.0f * g_ShadingNormalTexture.Load(int3(DispatchID, 0)).xyz - 1.0f);

    float3 RayOrigin = offsetPosition(WorldPixelPosition, GeometryNormal);

    float2 u_b;
    if(g_UseBlueNoiseSampleDirection) {
        u_b = BlueNoise_Sample2D(DispatchID, g_FrameIndex);
    } else {
        Random randomNG = MakeRandom(DispatchID.x + DispatchID.y * g_OutputDimensions.x, g_FrameIndex);
        u_b = randomNG.rand2();
    }
    float3 RayDirection;
    [branch]
    if(g_NoImportanceSampling == 1) 
    {
        RayDirection = UniformSampleSphere(u_b);//UniformSampleHemisphere(u_b);//CosineWeightedSampleHemisphere(u_b);
        
        float3 PixelTangent, PixelBitangent;
        TangentVectors(ShadingNormal, PixelTangent, PixelBitangent);
        RayDirection = normalize(RayDirection.x * PixelTangent + RayDirection.y * PixelBitangent + RayDirection.z * ShadingNormal);
    } else {
        float PDF;
        SGData SG;
        WData WD;
        FetchBasisData(DispatchID, SG, WD);
        RayDirection = SampleSG(u_b, SG.Lambda, PDF);
        float3 SGTangent, SGBitangent;
        TangentVectors(SG.Direction, SGTangent, SGBitangent);
        RayDirection = normalize(RayDirection.x * SGTangent + RayDirection.y * SGBitangent + RayDirection.z * SG.Direction);
    }
    // Record trace ray direction for later hit position recovery
    g_RWRayDirectionTexture[DispatchID.xy] = float4(RayDirection * 0.5f + 0.5f, 0);

    if(dot(RayDirection, GeometryNormal) < 0.0f) {
        // Learn negative samples.
        g_RWRayRadianceTexture[DispatchID.xy] = float4(0.0f, 0.0f, 0.0f, 0.0f);
        return ;
    }

    // g_RWRayRadianceTexture[DispatchID.xy] = float4(dot(RayDirection, float3(1, -1, 0)).xxx, 0.0f);
    // return ;

    // Trace a visibility ray only.
    RayDesc VisibilityRayDesc;
    VisibilityRayDesc.Origin = RayOrigin;
    VisibilityRayDesc.Direction = RayDirection;
    VisibilityRayDesc.TMin = 0.f;
    VisibilityRayDesc.TMax = MAX_HIT_DISTANCE;

    ScreenCacheUpdatePayload payload;
    payload.sky_sample = float3(0.0f, 0.0f, 0.0f);
    ScreenCacheUpdateTraceRay(
        DispatchID.y * g_OutputDimensions.x + DispatchID.x,
        payload, VisibilityRayDesc
    );
    g_RWRayRadianceTexture[DispatchID.xy] = float4(payload.sky_sample, 0.f);
}

[numthreads(4, 4, 1)]
void TraceUpdateRaysMain (uint2 DispatchID : SV_DispatchThreadID) {
    TraceUpdateRays(DispatchID);
}

[numthreads(32, 1, 1)]
void ClearReservoirs(in uint did : SV_DispatchThreadID)
{
    g_Reservoir_HashBuffer[did]      = 0;
    g_Reservoir_HashCountBuffer[did] = 0;
}


[numthreads(32, 1, 1)]
void GenerateReservoirs(in uint DispatchID : SV_DispatchThreadID)
{
    if (DispatchID >= g_HashGridCache_VisibilityCountBuffer[0])
    {
        return; // out of bounds
    }

    // Load our visibility sample
    float4                   packed_visibility = g_HashGridCache_VisibilityBuffer[DispatchID];
    HashGridCache_Visibility visibility        = HashGridCache_UnpackVisibility(packed_visibility);

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[visibility.instance_index];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index + visibility.geometry_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    TriangleNormUV vertices = fetchVerticesNormUV(mesh, visibility.primitive_index);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);

    vertices.n0 = transformNormal(vertices.n0, transform);
    vertices.n1 = transformNormal(vertices.n1, transform);
    vertices.n2 = transformNormal(vertices.n2, transform);

    float3   world    =                                                       interpolate(vertices.v0, vertices.v1, vertices.v2, visibility.barycentrics);
    float3   normal   = (visibility.is_front_face ? 1.0f : -1.0f) * normalize(interpolate(vertices.n0, vertices.n1, vertices.n2, visibility.barycentrics));
    Material material = g_MaterialBuffer[instance.material_index];

    // Recover the ray origin
    uint query_index = g_HashGridCache_VisibilityQueryBuffer[DispatchID];
    // Queries are indexed with pixel coordinates (currently).
    int2 pixel_coords = int2(query_index % g_OutputDimensions.x, query_index / g_OutputDimensions.x);
    float depth = g_DepthTexture.Load(int3(pixel_coords, 0)).x;
    float2 uv = (pixel_coords + 0.5f) / g_OutputDimensions;
    float3 origin = InverseProject(g_CameraProjViewInv, uv, depth);
    float2 mesh_uv = interpolate(vertices.uv0, vertices.uv1, vertices.uv2, visibility.barycentrics);

    // Patch the screen space cache with some emissivity information:
    // We bypass the hash-grid cache entirely here, as adding emissive information to the cells
    // effectively enlarges the area light (due to the spatial nature of the grid) and leads to
    // light leaks and generally poorer visuals.
    if (visibility.is_front_face && dot(material.emissivity.xyz, material.emissivity.xyz) > 0.0f)
    {
        MaterialEmissive emissive = MakeMaterialEmissive(material, mesh_uv);
        g_RWRayRadianceTexture[pixel_coords] = float4(emissive.emissive, 1.f);

        return; // do not continue past an emissive surface
    }

    // We can perform some temporal radiance feedback from last frame if direct lighting was
    // evaluated.
    // If successful, we inject the reprojected radiance into the cache so it can be re-used
    // by neighbor vertices but bypass the filtered readback as the sample is already denoised.
    {
        float3 homogeneous = transformPointProjection(world, g_CameraProjView);

        uv    = 0.5f * float2(homogeneous.x, -homogeneous.y) + 0.5f;
        depth = homogeneous.z;

        if (all(uv > 0.0f) && all(uv < 1.0f) && depth > 0.0f && depth < 1.0f)
        {
            float2 previous_uv = uv - g_VelocityTexture.SampleLevel(g_NearestSampler, uv, 0.0f).xy;

            if (all(previous_uv > 0.0f) && all(previous_uv < 1.0f))
            {
                float3 homogeneous2 = transformPointProjection(float3(2.0f * float2(uv.x, 1.0f - uv.y) - 1.0f, depth), g_Reprojection);
                homogeneous2.z      = GetLinearDepth(homogeneous2.z);

                float  previous_depth  = GetLinearDepth(g_PreviousDepthTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).x);
                float3 previous_normal = normalize(2.0f * g_PreviousGeometryNormalTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz - 1.0f);

                if (dot(previous_normal, normal) > 5e-1f && abs(previous_depth - homogeneous2.z) / homogeneous2.z < 5e-2f)
                {
                    float3 previous_lighting = g_PrevCombinedIlluminationTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz;

                    uint  cell_index         = g_HashGridCache_VisibilityCellBuffer[DispatchID];
                    uint4 quantized_radiance = HashGridCache_QuantizeRadiance(previous_lighting);
#ifdef ENABLE_INDIRECT
                    g_RWRayRadianceTexture[pixel_coords] = g_RWRayRadianceTexture[pixel_coords] + float4(previous_lighting, 0.f);
#endif // ENABLE_INDIRECT
                    if (dot(previous_lighting, previous_lighting) > 0.0f)
                    {
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0], quantized_radiance.x);
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1], quantized_radiance.y);
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2], quantized_radiance.z);
                    }
                    InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3], quantized_radiance.w);

                    return; // we can skip the shadow ray for this sample :)
                }
            }
        }
    }

    float3 view_direction = normalize(origin - world);

    // Sample new lights
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 1.5f);
    MaterialEvaluated material2 = MakeMaterialEvaluated(material, mesh_uv);
    MaterialBRDF materialBRDF = MakeMaterialBRDF(material2);
    // Make the seed different from the one used in TraceUpdateRays
    Random random = MakeRandom(DispatchID ^ 0x8a197727, g_FrameIndex);
    LightSampler lightSampler = MakeLightSampler(random);
    Reservoir reservoir = lightSampler.sampleLightListCone<kReservoir_SampleCount>(world, normal, view_direction, solid_angle, materialBRDF);

    if (!reservoir.isValid())
    {
        return;
    }

    // Append our resampled shadow ray, generate a ray index for later tracing and updates
    uint ray_index;
    InterlockedAdd(g_HashGridCache_VisibilityRayCountBuffer[0], 1, ray_index);

    g_HashGridCache_VisibilityRayBuffer[ray_index] = DispatchID;   // compact the surviving shadow rays

    // Here, we check that the ray has traversed at least a full hash cell
    // before hitting something.
    // If it hasn't, we bypass the filtering from the cache (although we
    // still accumulate the contribution into the cell).
    //
    // This avoids possible light leaks in the following configuration:
    //
    //    bright area   +--------------+
    //                  |    dark area |
    //                  | |            |
    //                  | x            |
    //                  |/|            |
    //                 /|\             |
    //                / | eye          |
    // bright radiance  +--------------+
    //
    // Here the point 'x' is reached after bouncing from the first vertex.
    // (i.e., it is a 2nd vertex, the ones filtered through the hash grid)
    // Because it is close to the wall and has a similar direction to the
    // 'bright radiance' event, both vertices will share the same hash cell
    // leading to a light leak on the bounced lighting from the inner wall.
    //
    // Such a scenario mostly occurs if the length of the ray connecting
    // the 2nd vertex is less than the size of the hash cell being used.
    // So, we detect this case and flag a bypass of the filtered readback.
    float cell_size  = HashGridCache_GetCellSize(world);
    float ray_length = distance(origin, world);

    if (ray_length < cell_size)
    {
        g_HashGridCache_VisibilityRayBuffer[ray_index] |= 0x80000000u;
    }

    // Insert the reservoir into the hash table
#ifdef USE_RESAMPLING
    float3 b1, b2;
    GetOrthoVectors(normal, b1, b2);
    float2 jitter = 2.0f * random.rand2() - 1.0f;
    jitter *= Reservoir_GetCellSize(world) * kReservoir_SpatialJitter;
    Reservoir_InsertEntry(ray_index, world + jitter.x * b1 + jitter.y * b2);

    g_Reservoir_IndirectSampleBuffer[ray_index]       = Reservoir_PackIndirectSample(origin, world);
    g_Reservoir_IndirectSampleNormalBuffer[ray_index] = packNormal(normal);
#endif // USE_RESAMPLING

    // Write the results out to memory
    g_Reservoir_IndirectSampleMaterialBuffer[ray_index]  = packMaterial(material2);  // cannot afford to re-fetch the full material each time, so we need to approximate it...
    g_Reservoir_IndirectSampleReservoirBuffer[ray_index] = packReservoir(reservoir);
}

// 32 threads for NVIDIA hardwares (warp size)
[numthreads(32, 1, 1)]
void CompactReservoirs(in uint did : SV_DispatchThreadID)
{
    if (did >= g_Reservoir_HashListCountBuffer[0])
    {
        return; // out of bounds
    }

    uint4 list_element = g_Reservoir_HashListBuffer[did];
    uint  value_index  = g_Reservoir_HashIndexBuffer[list_element.y] + list_element.z;

    g_Reservoir_HashValueBuffer[value_index] = list_element.x;
}

// Temporal resampling only
[numthreads(64, 1, 1)]
void ResampleReservoirs(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    // Load our shading information
    float3 origin, world;
    Reservoir_UnpackIndirectSample(g_Reservoir_IndirectSampleBuffer[did], origin, world);

    float3       normal    = unpackNormal(g_Reservoir_IndirectSampleNormalBuffer[did]);
    MaterialBRDF material  = unpackMaterial(g_Reservoir_IndirectSampleMaterialBuffer[did]);
    Reservoir    reservoir = unpackReservoir(g_Reservoir_IndirectSampleReservoirBuffer[did]);

    // Normalize the sample count M (a.k.a. confidence weight) with the initial sample count for simplicity.
    reservoir.M = 1.0f;

    Random random = MakeRandom(did, g_FrameIndex);

    // Locate our hash table cell
    float3 b1, b2;
    GetOrthoVectors(normal, b1, b2);
    float2 jitter = 2.0f * random.rand2() - 1.0f;
    jitter *= Reservoir_GetCellSize(world) * kReservoir_SpatialJitter;
    uint entry_index = Reservoir_FindPreviousEntry(world + jitter.x * b1 + jitter.y * b2);

    if (entry_index == kGI10_InvalidId)
    {
        return; // no previous reservoir cell - temporal resampling failed :'(
    }

    uint index = g_Reservoir_PreviousHashIndexBuffer[entry_index];
    uint count = g_Reservoir_PreviousHashCountBuffer[entry_index];

    // Stochastically iterate the cell content
    uint max_count = 4;
    uint increment = (count + max_count - 1) / max_count;
    uint offset    = random.randInt(increment);

    // And combine the reservoirs
    float3 view_direction = normalize(origin - world);
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 12000.0f);
    ReservoirUpdater updater = MakeReservoirUpdater();
    mergeReservoirsCone(updater, reservoir, random, material, world, normal, view_direction, solid_angle);
    for (uint i = 0; i < count; i += increment)
    {
        // Load up the iterated reservoir
        uint      reservoir_index = g_Reservoir_PreviousHashValueBuffer[index + ((i + offset) % count)];
        Reservoir reservoir2      = unpackReservoir(g_Reservoir_PreviousIndirectSampleReservoirBuffer[reservoir_index]);
        float3    filter_normal   = unpackNormal(g_Reservoir_PreviousIndirectSampleNormalBuffer[reservoir_index]);

        if (!reservoir2.isValid())
        {
            continue;   // skip invalid reservoir(s)
        }

        // Bilaterally filter the neighbor reservoir
        float bilateral_weight = max(dot(normal, filter_normal), 0.0f);
        bilateral_weight = squared(squared(bilateral_weight)); // make it steep
        if (bilateral_weight < kReservoir_BilateralThreshold) continue;

        // And combine it with our current reservoir
        Reservoir_ClampPrevious(reservoir2);
        mergeReservoirsCone(updater, reservoir2, random, material, world, normal, view_direction, solid_angle);
    }

    if (!updater.reservoir.M)
    {
        return; // reprojection failed
    }

    // Finalize our reservoir
    reservoir = updater.reservoir;

    // And write it out to memory
    g_Reservoir_IndirectSampleReservoirBuffer[did] = packReservoir(reservoir);
}

void PopulateCellsHandleHit(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    payload.lighting    = float3(0.0f, 0.0f, 0.0f);

    Reservoir reservoir = payload.reservoir;
    // Update our reservoir cache for next frame's temporal resampling
#ifdef USE_RESAMPLING
    reservoir.W = 0.0f; // invalidate the reservoir

    g_Reservoir_IndirectSampleReservoirBuffer[did] = packReservoir(reservoir);
#endif // USE_RESAMPLING
}

void PopulateCellsHandleMiss(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    float3       light_radiance = payload.lighting;
    float        light_weight   = payload.reservoir.W;
    int2         pixel_coords   = int2(payload.query_index % g_OutputDimensions.x, payload.query_index / g_OutputDimensions.x);
    MaterialBRDF material       = unpackMaterial(g_Reservoir_IndirectSampleMaterialBuffer[did]);

    // Recover the ray origin
    float  depth  = g_DepthTexture.Load(int3(pixel_coords, 0)).x;
    float2 uv     = (pixel_coords + 0.5f) / g_OutputDimensions;
    float3 origin = InverseProject(g_CameraProjViewInv, uv, depth);

    // And evaluate our lighting
    payload.lighting =
        evaluateBRDF(material, payload.normal, normalize(origin - payload.world), ray.Direction)
        * light_radiance * light_weight;
}

void PopulateCellsTraceRayInline(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    ShadowRayQuery ray_query = TraceRay<ShadowRayQuery>(ray);

    if (ray_query.CommittedStatus() == COMMITTED_NOTHING)
    {
        PopulateCellsHandleMiss(did, payload, ray);
    }
    else
    {
        PopulateCellsHandleHit(did, payload, ray);
    }
}

void PopulateCellsTraceRayRt(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    TraceRay(g_Scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH, 0xFFu, 0, 0, 0, ray, payload);
}

void PopulateCellsTraceRay(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
#if USE_INLINE_RT
    return PopulateCellsTraceRayInline(did, payload, ray);
#else
    return PopulateCellsTraceRayRt(did, payload, ray);
#endif
}

// Light sampling completed, actually trace a shadow ray for each hash grid cache query.
void PopulateCells(uint did)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    uint                     visibility_index = (g_HashGridCache_VisibilityRayBuffer[did] & ~0x80000000u);
    HashGridCache_Visibility visibility       = HashGridCache_UnpackVisibility(g_HashGridCache_VisibilityBuffer[visibility_index]);

    uint query_index = g_HashGridCache_VisibilityQueryBuffer[visibility_index];
    int2 pixel_coords = int2(query_index % g_OutputDimensions.x, query_index / g_OutputDimensions.x);    

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[visibility.instance_index];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index + visibility.geometry_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    Triangle vertices = fetchVertices(mesh, visibility.primitive_index);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);
    float3 world = interpolate(vertices.v0, vertices.v1, vertices.v2, visibility.barycentrics);
    float3 edge10 = vertices.v1 - vertices.v0;
    float3 edge20 = vertices.v2 - vertices.v0;
    float3 normal = normalize(transformNormal(cross(edge10, edge20) * (visibility.is_front_face ? 1.0f : -1.0f), transform));

    // Retrieve the light sample that we should use for our shadow ray
    Reservoir reservoir    = unpackReservoir(g_Reservoir_IndirectSampleReservoirBuffer[did]);

    // Decode the light sample from our reservoir
    float3 direction, light_position;
    // Approximate visible light surface based on number of samples being used
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 12000.0f);
    Light selected_light = getLight(reservoir.lightSample.index);
    float3 light_radiance = evaluateLightConeSampled(selected_light, world, reservoir.lightSample.sampleParams, solid_angle, direction, light_position);

    // Traverse the BVH
    RayDesc ray_desc;
    ray_desc.Direction = direction;
    ray_desc.Origin    = offsetPosition(world, normal);
    ray_desc.TMin      = 0.0f;
    ray_desc.TMax      = hasLightPosition(selected_light) ? length(light_position - ray_desc.Origin) : FLT_MAX;

    PopulateCellsPayload payload;
    payload.query_index = query_index;
    payload.world       = world;
    payload.normal      = normal;
    payload.lighting    = light_radiance;
    payload.reservoir   = reservoir;
    PopulateCellsTraceRay(did, payload, ray_desc);

    // And update the hash-grid cell payload
    uint  cell_index         = g_HashGridCache_VisibilityCellBuffer[visibility_index];
    uint4 quantized_radiance = HashGridCache_QuantizeRadiance(payload.lighting);

    if (dot(payload.lighting, payload.lighting) > 0.0f)
    {
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0], quantized_radiance.x);
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1], quantized_radiance.y);
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2], quantized_radiance.z);
    }
    InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3], quantized_radiance.w);

    // In some cases, we want to bypass the cache to avoid light leaks;
    // so we simply patch the screen probes directly and invalidate the
    // cache connection.
    bool is_bypass_cache = ((g_HashGridCache_VisibilityRayBuffer[did] >> 31) != 0);

    if (is_bypass_cache)
    {
        g_RWRayRadianceTexture[pixel_coords] = g_RWRayRadianceTexture[pixel_coords] + float4(GIDenoiser_RemoveNaNs(payload.lighting), 0.f);
    }
}

[numthreads(32, 1, 1)]
void PopulateCellsMain(in uint did : SV_DispatchThreadID)
{
    PopulateCells(did);
}

// BE CAREFUL: we assume
//             UPDATE_TILES_NOT_SLICED_GROUP_* >= g_HashGridCacheConstants.size_tile_mip0
//             UPDATE_TILES_NOT_SLICED_GROUP_*  % g_HashGridCacheConstants.size_tile_mip0 == 0
//
#define UPDATE_TILES_GROUP_X 8
#define UPDATE_TILES_GROUP_Y 8
#define UPDATE_TILES_GROUP_SIZE (UPDATE_TILES_GROUP_X * UPDATE_TILES_GROUP_Y)

groupshared uint2 lds_UpdateTiles_ValueBuffer[UPDATE_TILES_GROUP_X][UPDATE_TILES_GROUP_Y];

[numthreads(1, 1, 1)]
void GenerateUpdateTilesDispatch()
{
    uint num_tiles_by_group = UPDATE_TILES_GROUP_SIZE / g_HashGridCacheConstants.num_cells_per_tile_mip0;

    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = (g_HashGridCache_UpdateTileCountBuffer[0] + num_tiles_by_group - 1) / num_tiles_by_group;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

[numthreads(UPDATE_TILES_GROUP_X, UPDATE_TILES_GROUP_Y, 1)]
void UpdateTiles(in uint group_id : SV_GroupID, in uint2 group_thread_id : SV_GroupThreadID)
{
    // A group cover from 1 tile/subgroup (8x8) to 64 tiles/subgroups (1x1)
    uint2 subgroup_id        = group_thread_id / g_HashGridCacheConstants.size_tile_mip0;
    uint2 subgroup_thread_id = group_thread_id % g_HashGridCacheConstants.size_tile_mip0;
    uint2 subgroup_size      = uint2(UPDATE_TILES_GROUP_X, UPDATE_TILES_GROUP_Y) / g_HashGridCacheConstants.size_tile_mip0;
    uint  update_tile_index  = group_id * subgroup_size.x * subgroup_size.y +
                               subgroup_id.y * subgroup_size.x +
                               subgroup_id.x;

    if (update_tile_index >= g_HashGridCache_UpdateTileCountBuffer[0])
    {
        return;
    }

    uint tile_index = g_HashGridCache_UpdateTileBuffer[update_tile_index];

    // MIP 0
    {
        uint cell_index  = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 0);

        // Temporal accumulation
        float4 radiance     = HashGridCache_UnpackRadiance(g_HashGridCache_ValueBuffer[cell_index]);
        float4 new_radiance = HashGridCache_RecoverRadiance(uint4(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3]));

        float sample_count = min(radiance.w + new_radiance.w, g_HashGridCacheConstants.max_sample_count);

        radiance     /= max(radiance.w, 1.0f);
        new_radiance /= max(new_radiance.w, 1.0f);

        if (radiance.w <= 0.0f)
        {
            radiance = new_radiance;
        }
        else
        {
            radiance = lerp(radiance, new_radiance, 1.0f / sample_count);
        }

        radiance *= sample_count;   // sample count is used as a hint for picking prefiltering amount

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;

        // Clear scratch
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3] = 0;
    }

    // MIP 1
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip1 > 0 && all((group_thread_id % 2) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 1);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance10 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 1][group_thread_id.y + 0];
        uint2 packed_radiance01 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 1];
        uint2 packed_radiance11 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 1][group_thread_id.y + 1];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance10);
        radiance += HashGridCache_UnpackRadiance(packed_radiance01);
        radiance += HashGridCache_UnpackRadiance(packed_radiance11);

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;
    }

    // MIP 2
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip2 > 0 && all((group_thread_id % 4) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 2);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance20 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 2][group_thread_id.y + 0];
        uint2 packed_radiance02 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 2];
        uint2 packed_radiance22 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 2][group_thread_id.y + 2];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance20);
        radiance += HashGridCache_UnpackRadiance(packed_radiance02);
        radiance += HashGridCache_UnpackRadiance(packed_radiance22);

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;
    }

    // MIP 3
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip3 > 0 && all((group_thread_id % 8) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 3);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance40 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 4][group_thread_id.y + 0];
        uint2 packed_radiance04 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 4];
        uint2 packed_radiance44 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 4][group_thread_id.y + 4];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance40);
        radiance += HashGridCache_UnpackRadiance(packed_radiance04);
        radiance += HashGridCache_UnpackRadiance(packed_radiance44);

        // Pack
        g_HashGridCache_ValueBuffer[cell_index] = HashGridCache_PackRadiance(radiance);
    }
}

[numthreads(64, 1, 1)]
void ResolveCells(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    uint visibility_index = g_HashGridCache_VisibilityRayBuffer[did];

    if ((visibility_index >> 31) != 0)
    {
        return; // do not use filtered radiance
    }

    uint cell_index  = g_HashGridCache_VisibilityCellBuffer[visibility_index];
    uint query_index = g_HashGridCache_VisibilityQueryBuffer[visibility_index];

    float4 radiance = HashGridCache_FilteredRadiance(cell_index, false);

    int2 pixel_coords = int2(query_index % g_OutputDimensions.x, query_index / g_OutputDimensions.x);
#ifdef ENABLE_INDIRECT
    g_RWRayRadianceTexture[pixel_coords] = g_RWRayRadianceTexture[pixel_coords] + float4(GIDenoiser_RemoveNaNs(radiance.xyz / max(radiance.w, 1.0f)), 0.f);
#endif
}

// Reproject basis from previous frame, filter and inject
[numthreads(WARP_SIZE, 1, 1)]
void ReprojectPreviousBasis (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= g_RWTileBasisCountBuffer[0]) {
        return;
    }
    if(!IsBasisActive(DispatchID)) {
        return;
    }
    SGData SG;
    WData W;
    float2 PreviousUV;
    FetchBasisData(DispatchID, SG, W);
    FetchBasisLocation(DispatchID, PreviousUV);
    float PreviousPixelDepth = g_PreviousDepthTexture.SampleLevel(g_LinearSampler, UV, 0.0f).x;
    float3 PreviousPixelNormal = normalize(2.f * g_PreviousGeometryNormalTexture.SampleLevel(g_LinearSampler, PreviousUV, 0.0f).xyz - 1.f);
    float3 CurrentHomogeneous = transformPointProjection(float3(2.0f * float2(PreviousUV.x, 1.0f - PreviousUV.y) - 1.0f, PreviousPixelDepth), g_ForwardReprojection);


    float2 CurrentUV = 0.5f * float2(CurrentHomogeneous.x, -CurrentHomogeneous.y) + 0.5f;
    float  CurrentDepth = CurrentHomogeneous.z;

    bool ActiveFlag = false;

    if (all(CurrentUV > -g_ScreenSpaceCacheBorderPaddingUV) 
    && all(CurrentUV < 1.0f + g_ScreenSpaceCacheBorderPaddingUV) 
    && CurrentDepth > 0.0f && CurrentDepth < 1.0f) {
        float CurrentLinearDepth = DepthToLinearDepth(CurrentDepth, g_CameraNear, g_CameraFar);
        float PreviousLinearDepth = DepthToLinearDepth(PreviousPixelDepth, g_CameraNear, g_CameraFar);
        float DeltaLinearDepth = CurrentLinearDepth - PreviousLinearDepth;
        float3 CameraRayDirection = GetCameraRayDirectionUnnormalized(UV2NDC2(CurrentUV));
        float3 Delta = DeltaLinearDepth * CameraRayDirection;
        // Recompute W parameters based on position shift.
        WData WShifted = ShiftW(W, Delta);
        // TODO decay according to geometry difference

        if(!IsEmptyW(WShifted)) {
            // Write back
            WriteBasisWData(DispatchID, WShifted);
            WriteBasisLocation(DispatchID, CurrentUV);
            // Update the depth for basis, used in later injection pass
            g_RWBasisCenterDepthBuffer[DispatchID] = CurrentDepth;
            ActiveFlag = true;
        }
    }

    // Free the slot if reprojection failed
    if(!ActiveFlag) {
        uint Slot = InterlockedAdd(g_RWFreeBasisIndicesCountBuffer[0], 1);
        g_RWFreeBasisIndicesBuffer[Slot] = DispatchID;
        g_RWBasisFlagsBuffer[DispatchID] = 0;
    }
}

// Clear tile injection index
[numthreads(WARP_SIZE, 1, 1)]
void ClearTileInjectionIndex (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    g_RWTileBasisCountBuffer[DispatchID] = 0;
}


// Inject reprojected basis to tile injection index
// Performed within the fragment shader with conservative rasterization
// InjectReprojectedBasis : TOPOLOGY_TRIANGLEFAN

// Clip overflowing tile index
[numthreads(WARP_SIZE, 1, 1)]
void ClipOverflowTileIndex (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID > g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    if(g_RWTileBasisCountBuffer[DispatchID] > SRC_TILE_BASIS_INJECTION_RESERVATION) {
        g_RWTileBasisCountBuffer[DispatchID] = SRC_TILE_BASIS_INJECTION_RESERVATION;
    }
}

// A scan sum is performed to accumulate g_RWTileBasisBaseOffsetBuffer

// Allocate one extra slot for each tile and accumulate it to the accumulated base basis index offset,
// which is used to store the newly allocated basis index this frame
[numthreads(WARP_SIZE, 1, 1)]
void AllocateExtraSlotForBasisGeneration (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    g_RWTileBaseSlotOffsetBuffer[DispatchID] = g_RWTileBaseSlotOffsetBuffer[DispatchID] + DispatchID;
}

// Compress the tile basis index
[numthreads(WARP_SIZE, 1, 1)]
void CompressTileBasisIndex (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    if(any(GroupID >= g_TileDimensions)) {
        return;
    }
    int TileID = GroupID.x + GroupID.y * g_TileDimensions.x;
    int UncompressedTileSlotOffset = TileID * SRC_TILE_BASIS_INJECTION_RESERVATION;
    int CompressedTileSlotOffset   = g_RWTileBaseSlotOffsetBuffer[TileID];
    // Cooperatively fill the compressed index
    int Count = g_RWTileBasisCountBuffer[TileID];
    
    for(int TileSlotOffset = 0; TileSlotOffset < Count; TileSlotOffset += WARP_SIZE) {
        int TileSlot = TileSlotOffset + LocalID;
        if(TileSlot < Count) {
            g_RWTileBasisIndexBuffer[CompressedTileSlotOffset + TileSlot] = 
                g_RWTileBasisIndexInjectionBuffer[UncompressedTileSlotOffset + TileSlot];
        }
    }
}

// Precompute the cache update
groupshared float3 LocalRayDirection[SRC_TILE_SIZE][SRC_TILE_SIZE];
groupshared float3 LocalRayRadiance[SRC_TILE_SIZE][SRC_TILE_SIZE];
groupshared float3 LocalRayOrigin[SRC_TILE_SIZE][SRC_TILE_SIZE];

[numthreads(WARP_SIZE, 1, 1)]
void PrecomputeCacheUpdate (int3 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID             = GroupID.x + GroupID.y * g_TileDimensions.x;
    int TileBasisCount     = g_RWTileBasisCountBuffer[TileID];
    int TileSlotBaseOffset = g_RWTileBaseSlotOffsetBuffer[TileID];
    int2 TileTextureBaseOffset = int2(GroupID.x * SRC_TILE_SIZE, GroupID.y * SRC_TILE_SIZE);
    // Cooperatively load the tile data into shmem
    for(int PixelIndexBase = 0; PixelIndexBase < SRC_TILE_SIZE * SRC_TILE_SIZE; PixelIndexBase += WARP_SIZE) {
        int PixelIndex = PixelIndexBase + LocalID;
        int PixelX = PixelIndex % SRC_TILE_SIZE;
        int PixelY = PixelIndex / SRC_TILE_SIZE;
        // We assume WARP_SIZE is a multiple of SRC_TILE_SIZE, and SRC_TILE_SIZE^2 is a multiple of WARP_SIZE
        {   
            int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
            float3 RayDirection = normalize(g_RWRayDirectionTexture[TexCoords].xyz * 2.f - 1.f);
            float3 RayRadiance  = g_RWRayRadianceTexture[TexCoords].xyz;
            float  Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
            float2 UV = (TexCoords + 0.5f) / g_OutputDimensions;
            float3 RayOrigin = InverseProject(g_CameraProjViewInv, UV, Depth);
            LocalRayDirection[PixelY][PixelX] = RayDirection;
            LocalRayRadiance[PixelY][PixelX] = RayRadiance;
            LocalRayOrigin[PixelY][PixelX] = RayOrigin;
        }
    }
    
    GroupMemoryBarrierWithGroupSync();

    // Thread local accumulators
    float3 ThreadSumRadiance[SRC_TILE_SIZE * SRC_TILE_SIZE / WARP_SIZE];
    float  ThreadSumWeight  [SRC_TILE_SIZE * SRC_TILE_SIZE / WARP_SIZE];
    for(int i = 0; i< SRC_TILE_SIZE * SRC_TILE_SIZE / WARP_SIZE; i++) {
        ThreadSumRadiance[i] = 0.f.xxx;
        ThreadSumWeight[i] = 0.f;
    }
    
    // Iterate over each basis overlapping with this tile
    for(int Slot = 0; Slot < TileBasisCount; Slot ++) {
        int BasisIndex = g_RWTileBasisIndexBuffer[TileSlotBaseOffset + Slot];
        SGData SG;
        WData  W;
        FetchBasisData(BasisIndex, SG, W);
        float3 BasisWorldPosition = ReconstructBasisWorldPosition(BasisIndex);

        // Cooperatively iterate over all pixels of the grid
        for(int PixelIndexBase = 0; PixelIndexBase < SRC_TILE_SIZE * SRC_TILE_SIZE; PixelIndexBase += WARP_SIZE) {
            int PixelIndex = PixelIndexBase + LocalID;
            int PixelX = PixelIndex % SRC_TILE_SIZE;
            int PixelY = PixelIndex / SRC_TILE_SIZE;
            // We assume WARP_SIZE is a multiple of SRC_TILE_SIZE, and SRC_TILE_SIZE^2 is a multiple of WARP_SIZE
            {
                // There is no bank conflict as the stride is 3 * 4 bytes for float3
                // Loading from shmem is done in 1 cycle per word
                float3 RayDirection = LocalRayDirection[PixelY][PixelX];
                float3 RayRadiance  = LocalRayRadiance [PixelY][PixelX];

                float3 EvaluatedRadiance = EvaluateSG(SG, RayDirection);
                float3 DeltaPosition = LocalRayOrigin[PixelY][PixelX] - BasisWorldPosition;
                float  EvaluatedW        = EvaluateW(W, DeltaPosition);

                // Use thread local registers to accumulate results
                ThreadSumRadiance[PixelIndexBase / WARP_SIZE] += EvaluatedRadiance * EvaluatedW;
                ThreadSumWeight  [PixelIndexBase / WARP_SIZE] += EvaluatedW;
            }
        }
    }
    // Cooperatively write back the data
    for(int PixelIndexBase = 0; PixelIndexBase < SRC_TILE_SIZE * SRC_TILE_SIZE; PixelIndexBase += WARP_SIZE) {
        int PixelIndex = PixelIndexBase + LocalID;
        int PixelX = PixelIndex % SRC_TILE_SIZE;
        int PixelY = PixelIndex / SRC_TILE_SIZE;
        // We assume WARP_SIZE is a multiple of SRC_TILE_SIZE, and SRC_TILE_SIZE^2 is a multiple of WARP_SIZE
        {   
            int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
            float3 RayRadiance = LocalRayRadiance [PixelY][PixelX];
            float SumWeight    = ThreadSumWeight  [PixelIndexBase / WARP_SIZE];
            float3 SumRadiance = ThreadSumRadiance[PixelIndexBase / WARP_SIZE];
            SumWeight = max(SumWeight, 1e-6f);
            if(SumWeight > 0.f) {
                g_RWRayRadianceDifferenceWSumTexture[TexCoords] = float4(RayRadiance - SumRadiance / SumWeight, SumWeight);
            }
        }
    }
}


// Split the 4x4 strided data into 3x4 and 1x4 to avoid bank conflicts
groupshared float3 LocalRayRadianceDifference[SRC_TILE_SIZE][SRC_TILE_SIZE];
groupshared float  LocalInvSumWeight[SRC_TILE_SIZE][SRC_TILE_SIZE];

[numthreads(WARP_SIZE, 1, 1)]
void UpdateCacheParameters (int3 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID             = GroupID.x + GroupID.y * g_TileDimensions.x;
    int TileBasisCount     = g_RWTileBasisCountBuffer[TileID];
    int TileSlotBaseOffset = g_RWTileBaseSlotOffsetBuffer[TileID];
    int2 TileTextureBaseOffset = int2(GroupID.x * SRC_TILE_SIZE, GroupID.y * SRC_TILE_SIZE);
    // Cooperatively load the tile data into shmem
    for(int PixelIndexBase = 0; PixelIndexBase < SRC_TILE_SIZE * SRC_TILE_SIZE; PixelIndexBase += WARP_SIZE) {
        int PixelIndex = PixelIndexBase + LocalID;
        int PixelX = PixelIndex % SRC_TILE_SIZE;
        int PixelY = PixelIndex / SRC_TILE_SIZE;
        // We assume WARP_SIZE is a multiple of SRC_TILE_SIZE, and SRC_TILE_SIZE^2 is a multiple of WARP_SIZE
        {   
            int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
            float3 RayDirection = normalize(g_RWRayDirectionTexture[TexCoords].xyz * 2.f - 1.f);
            float4 RayRadianceDifferenceSum  = g_RWRayRadianceDifferenceWSumTexture[TexCoords];
            float  Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
            float2 UV = (TexCoords + 0.5f) / g_OutputDimensions;
            float3 RayOrigin = InverseProject(g_CameraProjViewInv, UV, Depth);
            LocalRayDirection[PixelY][PixelX]          = RayDirection;
            LocalRayRadianceDifference[PixelY][PixelX] = RayRadianceDifferenceSum.xyz;
            LocalInvSumWeight[PixelY][PixelX]          = 1.f / max(RayRadianceDifferenceSum.w, 1e-6f);
            LocalRayOrigin[PixelY][PixelX]             = RayOrigin;
        }
    }
    
    GroupMemoryBarrierWithGroupSync();

    // Thread local accumulators
    SGGradients SumStepSize   = (SGGradients)0;
    WGradients  SumStepSize_W = (WGradients)0;
    
    // Iterate over each basis overlapping with this tile
    for(int Slot = 0; Slot < TileBasisCount; Slot ++) {
        int BasisIndex = g_RWTileBasisIndexBuffer[TileSlotBaseOffset + Slot];
        SGData SG;
        WData  W;
        FetchBasisData(BasisIndex, SG, W);
        float3 BasisWorldPosition = ReconstructBasisWorldPosition(BasisIndex);
        // Cooperatively iterate over all pixels of the grid
        for(int PixelIndexBase = 0; PixelIndexBase < SRC_TILE_SIZE * SRC_TILE_SIZE; PixelIndexBase += WARP_SIZE) {
            int PixelIndex = PixelIndexBase + LocalID;
            int PixelX = PixelIndex % SRC_TILE_SIZE;
            int PixelY = PixelIndex / SRC_TILE_SIZE;
            // We assume WARP_SIZE is a multiple of SRC_TILE_SIZE, and SRC_TILE_SIZE^2 is a multiple of WARP_SIZE
            {
                // There is no bank conflict as the stride is (1 or 3) * 4 bytes for float3
                // Loading from shmem is done in 1 cycle per word
                float3 RayDirection          = LocalRayDirection[PixelY][PixelX];
                float3 RayRadianceDifference = LocalRayRadianceDifference[PixelY][PixelX];
                float  InvSumWeight          = LocalInvSumWeight[PixelY][PixelX];

                float3 EvaluatedRadiance     = EvaluateSG(SG, RayDirection);
                float  EvaluatedRadianceSum  = dot(EvaluatedRadiance, 1.f.xxx);
                float3 DeltaPosition         = LocalRayOrigin[PixelY][PixelX] - BasisWorldPosition;
                float  EvaluatedW            = EvaluateW(W, DeltaPosition);

                // Compute gradients
                SGGradients Gradients;
                WGradients  Gradients_W;
                EvaluateSG_Gradients(SG, RayDirection, Gradients);
                float3 DeltaRadiance    = EvaluatedRadiance - RayRadianceDifference;
                float  DeltaRadianceSum = dot(DeltaRadiance, 1.f.xxx);
                float  Weight           = EvaluatedW * InvSumWeight;
                EvaluateW_Gradients(W, DeltaPosition, Gradients_W);
                // Accumulate and combine gradients for optimal descending
                // TODO adaptive learning rate based on the magnitude of the gradients
                SumStepSize.dColor     += DeltaRadiance    * Gradients.dColor     * Weight;
                SumStepSize.dDirection += DeltaRadianceSum * Gradients.dDirection * Weight;
                SumStepSize.dLambda    += DeltaRadianceSum * Gradients.dLambda    * Weight;
                // F = W / (S+W) * f, so the step size of W is calculated by the followings
                SumStepSize_W.dLambda  += 
                   (Gradients_W.dLambda * InvSumWeight - InvSumWeight * InvSumWeight * Gradients_W.dLambda)
                    * EvaluatedRadianceSum * DeltaRadianceSum;
                SumStepSize_W.dAlpha   += 
                   (Gradients_W.dAlpha  * InvSumWeight - InvSumWeight * InvSumWeight * Gradients_W.dAlpha) 
                    * EvaluatedRadianceSum * DeltaRadianceSum;
            }
        }
        // Wave reduce the gradients
        SumStepSize.dColor     = WaveActiveSum(SumStepSize.dColor);
        SumStepSize.dDirection = WaveActiveSum(SumStepSize.dDirection);
        SumStepSize.dLambda    = WaveActiveSum(SumStepSize.dLambda);
        SumStepSize_W.dLambda  = WaveActiveSum(SumStepSize_W.dLambda);
        if(WaveIsFirstLane()) {
            // Accumulate the gradients with atomic operations.
            // Note: Performance for atomic operations drops drastically when the quantlilized step buffer 
            // for accumulation overflows the L2 GPU cache (8MB for 3090). 
            // (about 1ms for 250000 basis, and 32 random basis for each tile)
            // However, if we kept some locallity in the accumulation (by processing adjacent tiles at one time), 
            // the performance is still acceptable.
            // (No L2 overflow: 200us)
            ScreenCache_AccumulateStepSize(BasisIndex, SumStepSize, SumStepSize_W);
        }
    }
}

[numthreads(WARP_SIZE, 1, 1)]
void SpawnNewBasis (int3 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * g_TileDimensions.x;
    int TileBasisCount = g_RWTileBasisCountBuffer[TileID];
    if(TileBasisCount >= SRC_TILE_BASIS_INJECTION_RESERVATION) {
        // Overflowed
        return;
    }
    // Find a pixel with minimum weight coverage
    uint MinCoverage    = 0xffffffff;
    // We assume SRC_TILE_SIZE * SRC_TILE_SIZE is a multiple of WARP_SIZE
    for(int Offset = 0; Offset < SRC_TILE_SIZE * SRC_TILE_SIZE; Offset += WARP_SIZE) {
        int PixelIndex = Offset + LocalID;
        int PixelX = PixelIndex % SRC_TILE_SIZE;
        int PixelY = PixelIndex / SRC_TILE_SIZE;
        int2 TexCoords = int2(GroupID.x * SRC_TILE_SIZE + PixelX, GroupID.y * SRC_TILE_SIZE + PixelY);
        float Coverage = g_RWRayRadianceDifferenceWSumTexture.Load(int3(TexCoords, 0)).w;
        MinCoverage = min(MinCoverage, (uint(Coverage * 0xfffff) << 12) | PixelIndex);
    }
    WaveActiveMin(MinCoverage);
    if(WaveIsFirstLane()) {
        uint MinPixelIndex = MinCoverage & 0xfff;
        if(MinPixelIndex != 0xfff) {
            // New basis is here!
            int2 TexCoords = int2(GroupID.x * SRC_TILE_SIZE + MinPixelIndex % SRC_TILE_SIZE, GroupID.y * SRC_TILE_SIZE + MinPixelIndex / SRC_TILE_SIZE);
            uint BasisAllocIndex = InterlockedAdd(g_RWFreeBasisIndicesCountBuffer[0], -1);
            if(BasisAllocIndex < 0x7fffffffu) {
                // Allocation succeeded
                int BasisIndex = g_RWFreeBasisIndicesBuffer[BasisAllocIndex];

                // The last slot for each tile is reserved for the newly allocated basis
                // Inject it to the tile basis index
                g_RWTileBasisIndexBuffer[g_RWTileBaseSlotOffsetBuffer[TileID] + TileBasisCount] = BasisIndex;
                g_RWTileBasisCountBuffer[TileID] = TileBasisCount + 1;

                // Initialize the basis
                SGData SG = (SGData)0;
                WData W = (WData)0;
                float2 UV = (TexCoords + 0.5f) / g_OutputDimensions;
                float PixelDepth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
                float3 PixelNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
                float3 WorldPosition = InverseProject(g_CameraProjViewInv, UV, PixelDepth);
                
                // TODO better initialization
                SG.Direction = PixelNormal;
                SG.Lambda = 0.85f;
                SG.Color  = 0.5f.xxx;
                W.Alpha   = GetLinearDepth(PixelDepth) * (g_BasisWInitialRadius / g_OutputDimensions.y);
                W.Lambda  = 0.5f;

                // Write the basis data
                g_RWBasisCenterDepthBuffer[BasisIndex] = PixelDepth;
                WriteBasisData_W(BasisIndex, SG, W);
                WriteBasisLocation(BasisIndex, UV);
                // Mark the basis as active
                g_RWBasisFlagsBuffer[BasisIndex] = 1;
            } 
        }
    }
}

[numthreads(32, COOPERATIVE_SHADING_GRID_SIZE, COOPERATIVE_SHADING_GRID_SIZE)]
void IntegrateASG(int2 GroupID : SV_GroupID, int3 LocalID : SV_GroupThreadID)
{
    int WarpID = LocalID.y * COOPERATIVE_SHADING_GRID_SIZE + LocalID.z; 
    int LaneID = LocalID.x;
    // Cooperatively load the data into shared memory
    // Warp : Y, Lane : X    
    if(WarpID < 8 + COOPERATIVE_SHADING_GRID_SIZE && LaneID < 8 + COOPERATIVE_SHADING_GRID_SIZE) {
        int X_Real = int(GroupID.x) * COOPERATIVE_SHADING_GRID_SIZE + LaneID - 4;
        int Y_Real = int(GroupID.y) * COOPERATIVE_SHADING_GRID_SIZE + WarpID - 4;
        if(X_Real < 0 || Y_Real < 0 || X_Real >= g_ScreenCacheDimensions.x || Y_Real >= g_ScreenCacheDimensions.y) {
            SGData SG = (SGData)0;
            SG.Lambda = 1.f;
            LocalSGData[WarpID][LaneID] = SG;
            WData W = (WData)0;
            W.Lambda = 100.f;
            LocalWData[WarpID][LaneID] = W;
            LocalPixelPosition[WarpID][LaneID] = float3(0, 0, 0);
            LocalPixelNormal[WarpID][LaneID] = float3(0, 0, 0);
        } else {
            FetchBasisData(int2(X_Real, Y_Real), LocalSGData[WarpID][LaneID], LocalWData[WarpID][LaneID]);
            float2 UV = (float2(X_Real, Y_Real) + 0.5f) / g_OutputDimensions;
            float PixelDepth = g_DepthTexture.Load(int3(X_Real, Y_Real, 0)).x;
            LocalPixelPosition[WarpID][LaneID] = InverseProject(g_CameraProjViewInv, UV, PixelDepth);
            LocalPixelNormal[WarpID][LaneID] = normalize(2.f * g_GeometryNormalTexture.Load(int3(X_Real, Y_Real, 0)).xyz - 1.f);
        }
    }
    GroupMemoryBarrierWithGroupSync();

    int2   PixelCoords = int2(GroupID.x * COOPERATIVE_SHADING_GRID_SIZE + LocalID.y, GroupID.y * COOPERATIVE_SHADING_GRID_SIZE + LocalID.z);
    float2 UV = (PixelCoords + 0.5f) / float2(g_OutputDimensions);
    float Depth = g_DepthTexture.Load(int3(PixelCoords, 0)).x;
    if(Depth >= 1.0f) {
        g_RWGlobalIlluminationOutput[PixelCoords] = float4(0.f, 0.f, 0.f, 1.0f);
        return ;
    }

    float4 Visbility = g_VisibilityTexture.Load(int3(PixelCoords, 0));
    uint InstanceID = asuint(Visbility.z);
    uint PrimitiveID = asuint(Visbility.w);

    Instance InstanceData = g_InstanceBuffer[InstanceID];
    Mesh MeshData = g_MeshBuffer[InstanceData.mesh_index];

    // Get UV values from buffers
    UVs PrimitiveUVs = fetchUVs(MeshData, PrimitiveID);

    float2 MeshUV = interpolate(PrimitiveUVs.uv0, PrimitiveUVs.uv1, PrimitiveUVs.uv2, Visbility.xy);


    float3 Normal         = normalize(2.0f * g_ShadingNormalTexture.Load(int3(PixelCoords, 0)).xyz - 1.0f);
    float3 GeometryNormal = LocalPixelNormal[LocalID.z + 4][LocalID.y + 4];

    float3 WorldPixelPosition = InverseProject(g_CameraProjViewInv, UV, Depth);
    float  PixelCameraDistance = distance(WorldPixelPosition, g_CameraPosition);
    float  PixelScale = PixelCameraDistance * g_CameraPixelScale;

    float3 ViewDirection = normalize(g_CameraPosition - WorldPixelPosition);
    float DotNV = saturate(dot(Normal, ViewDirection));

    Material MaterialData = g_MaterialBuffer[InstanceData.material_index];
    MaterialEvaluated MaterialEvaluatedData = MakeMaterialEvaluated(MaterialData, MeshUV);
    MaterialEmissive EmissiveMaterialData = MakeMaterialEmissive(MaterialData, MeshUV);

    MaterialBRDF MaterialBRDFData = MakeMaterialBRDF(MaterialEvaluatedData);

    // This should be alpha actually
    float Roughness = clamp(MaterialEvaluatedData.roughness, 0.001f, 1.f);

    float3 OutLighting = 0;
    float SumBilateralWeight = 0;

    // Iterate over adjacent pixels and integrate using ASG approximations
    // 9x9 = 81 basis, we use 32x3 = 96 operations to cover all of them
    for(int batch = 0; batch < 3; batch++) {
        int index = LaneID + batch * 32;
        if(index < 81) {
            int dX = index % 9 - 4;
            int dY = index / 9 - 4;
            int X = int(LocalID.y) + dX + 4;
            int Y = int(LocalID.z) + dY + 4;

            int2 RealCoord = int2(GroupID.x * COOPERATIVE_SHADING_GRID_SIZE + X, GroupID.y * COOPERATIVE_SHADING_GRID_SIZE + Y);
            if(RealCoord.x >= 0 && RealCoord.y >= 0 && RealCoord.x < g_OutputDimensions.x && RealCoord.y < g_OutputDimensions.x) {
                SGData SG = LocalSGData[Y][X];
                WData WD  = LocalWData[Y][X];
                float3 LightPixelPosition = LocalPixelPosition[Y][X];
                float3 LightPixelNormal   = LocalPixelNormal[Y][X];
                float3 LightDirection = SG.Direction;
                float3 ReflectionDirection = calculateGGXSpecularDirection(Normal, ViewDirection, Roughness);
                float3 HalfVector = normalize(LightDirection + ViewDirection);
                float dotNR = saturate(dot(Normal, ReflectionDirection));
                float dotNV = saturate(dot(Normal, ViewDirection));
                float dotHV = saturate(dot(HalfVector, ViewDirection));
                float3 FresnelTerm = fresnel(0.04f.xxx, dotHV);
                // Approximate \int D * Li with ASG
                // we use RoughnessAlpha here
                float3 GGX_D_Li_Approx = SpecularTermASGWarp(SG, Normal, MaterialBRDFData.roughnessAlphaSqr, ViewDirection);
                float VisibilityTerm = evaluateVisibilityGGX(MaterialBRDFData.roughnessAlphaSqr, dotNR, dotNV);
                float3 GGXIntegrationApprox = FresnelTerm * GGX_D_Li_Approx / VisibilityTerm;
                float3 DiffuseCompensation = diffuseCompensationTerm(FresnelTerm, dotHV);
                float3 LambertIntegration = SGDiffuseInnerProduct(SG, Normal, MaterialEvaluatedData.albedo) * DiffuseCompensation;
                float2 Jitter = float2(0, 0);//BlueNoise_Sample2D(RealCoord, g_FrameIndex, 2) * 2.f - 1.f;
                float EvaluatedW = EvaluateW(WD, float2(-dX, -dY) + Jitter);
                float BilateralWeight = EvaluateBilateralFilterWeight(PixelScale, 4, WorldPixelPosition - LightPixelPosition, GeometryNormal, LightPixelNormal) * EvaluatedW;
                OutLighting += (GGXIntegrationApprox + LambertIntegration) * BilateralWeight;
                SumBilateralWeight += BilateralWeight;
            }
        }
    }
    // Aggregate the evaluated radiance from cache
    SumBilateralWeight = WaveActiveSum(SumBilateralWeight);
    OutLighting = WaveActiveSum(OutLighting) / (SumBilateralWeight + 1e-6f);

    g_RWGlobalIlluminationOutput[PixelCoords] = float4(OutLighting + EmissiveMaterialData.emissive, 1.f);

}

// ***********************************************
// *                 Misc                        *
// ***********************************************

[numthreads(8, 8, 1)]
void ResetScreenSpaceCache (uint2 DispatchID : SV_DispatchThreadID) {
    if(DispatchID.x >= g_OutputDimensions.x || DispatchID.y >= g_OutputDimensions.y) return ;
    
    float2 u = BlueNoise_Sample2D(DispatchID, g_FrameIndex);
    float3 Direction = UniformSampleHemisphere(u);
    float3 ShadingNormal = normalize(2.0f * g_ShadingNormalTexture.Load(int3(DispatchID, 0)).xyz - 1.0f);
    float3 PixelTangent, PixelBitangent;
    TangentVectors(ShadingNormal, PixelTangent, PixelBitangent);
    Direction = normalize(Direction.x * PixelTangent + Direction.y * PixelBitangent + Direction.z * ShadingNormal);

    // Direction = ShadingNormal;

    g_RWBasisParameterTexture[DispatchID.xy] = float4(Direction, 1.f);
    g_RWBasisColorTexture[DispatchID.xy] = float4(0.2f, 0.2f, 0.2f, 0);
}

// New line required for termination.
