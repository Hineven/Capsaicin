#ifndef USE_INLINE_RT
#define USE_INLINE_RT 1
#endif

#ifndef WAVE_SIZE
// NVIDIA's default warp size
#define WAVE_SIZE 32
#endif

#define MIN_COLOR 0.000001f

// Shared structs among CPU and GPU
#include "../../gpu_shared.h"

// Parameters & Globals & Helper functions
#include "migi_inc.hlsl"

// Library for MIGI
#include "migi_lib.hlsl"
#include "migi_probes.hlsl"

// Hash grid cache library
#include "hash_grid_cache.hlsl"
// World space ReSTIR library
#include "world_space_restir.hlsl"

#define MAX_HIT_DISTANCE 1e9f

struct ScreenCacheUpdatePayload
{
    float3 sky_sample;
    float hit_dist;
};

struct PopulateCellsPayload
{
    uint      query_index;
    float3    world;
    float3    normal;
    float3    lighting;
    Reservoir reservoir;
};

struct TraceReflectionsPayload
{
    int2   full_pos;
    float3 radiance;
    float2 s;
    float  hit_distance;
};


// A naive kernel for generating dispatch commands
[numthreads(1, 1, 1)]
void GenerateDispatch()
{
    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = (g_CountBuffer[0] + g_GroupSize - 1) / g_GroupSize;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

[numthreads(1, 1, 1)]
void GenerateDispatchRays()
{
    DispatchRaysCommand dispatch_rays_command;
    dispatch_rays_command.ray_generation_shader_record = g_RTConstants.ray_generation_shader_record;
    dispatch_rays_command.miss_shader_table = g_RTConstants.miss_shader_table;
    dispatch_rays_command.hit_group_table = g_RTConstants.hit_group_table;
    dispatch_rays_command.callable_shader_table = g_RTConstants.callable_shader_table;
    dispatch_rays_command.width = g_CountBuffer[0];
    dispatch_rays_command.height = 1;
    dispatch_rays_command.depth = 1;
    dispatch_rays_command.padding[0] = 0;
    dispatch_rays_command.padding[1] = 0;
    dispatch_rays_command.padding[2] = 0;
    g_RWDispatchRaysCommandBuffer[0] = dispatch_rays_command;
}

[numthreads(64, 1, 1)]
void PurgeTiles(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_PreviousPackedTileCountBuffer[0])
    {
        return; // out of bounds
    }

    // We opt for calculating the decay of each tile from the
    // current frame index, as it saves many writes per frame
    // and is quite a bit faster than having to decrement all
    // cell's decay values.
    uint tile_index = g_HashGridCache_PreviousPackedTileIndexBuffer[did];
    uint tile_decay = g_HashGridCache_DecayTileBuffer[tile_index];

    if (g_FrameIndex < tile_decay)   // account for integer wraparound case
    {
        tile_decay = ((0xFFFFFFFFu - tile_decay) + g_FrameIndex + 1);
    }
    else
    {
        tile_decay = (g_FrameIndex - tile_decay);
    }

    if (tile_decay >= kHashGridCache_TileDecay)
    {
        g_HashGridCache_HashBuffer[tile_index] = 0;

#ifdef DEBUG_HASH_CELLS
        // Clear all mipmaps
        for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile; ++cell_offset)
        {
            uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
            g_HashGridCache_DecayCellBuffer[cell_index] = 0xFFFFFFFFu;
        }
#endif // DEBUG_HASH_CELLS

        return; // kill the tile
    }

    uint packed_tile_index;
    InterlockedAdd(g_HashGridCache_PackedTileCountBuffer[0], 1, packed_tile_index);
    g_HashGridCache_PackedTileIndexBuffer[packed_tile_index] = tile_index;
}

[numthreads(1, 1, 1)]
void ClearCounters()
{
    g_Reservoir_HashListCountBuffer[0] = 0; // reset counters

    g_HashGridCache_PackedTileCountBuffer[0]    = 0;
    g_HashGridCache_UpdateTileCountBuffer[0]    = 0;
    g_HashGridCache_VisibilityCountBuffer[0]    = 0;
    g_HashGridCache_VisibilityRayCountBuffer[0] = 0;
    
}

// Clear the counters at the begginging of the frame
[numthreads(1, 1, 1)]
void SSRC_ClearCounters() {
    g_RWAdaptiveProbeCountBuffer[0]      = 0;
    g_RWAllocatedProbeSGCountBuffer[0] = 0;
}

// Allocate fixed uniform probes for current frame
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateUniformProbes (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID > MI.UniformScreenProbeCount) {
        return;
    }
    ProbeHeader Header;
    Header.ScreenPosition = GetUniformScreenProbeScreenPosition(DispatchID);
    float Depth             = g_DepthTexture.Load(int3(Header.ScreenPosition, 0)).x;
    bool  bValid            = Depth < 1.f;
    if(bValid) Header.Class  = ComputeProbeRankFromSplattedError(Header.ScreenPosition);
    int BasisCount      = bValid ? GetProbeBasisCountFromClass(Header.Class) : 0;
    int BasisOffset     = WavePrefixSum(BasisCount);
    int BasisCountSum   = WaveActiveSum(BasisCount);
    int BasisGroupOffset;
    if(WaveIsFirstLane()) {
        InterlockedAdd(g_RWAllocatedProbeSGCountBuffer[0], BasisCountSum, BasisGroupOffset);
    }
    BasisGroupOffset = WaveReadLaneFirst(BasisGroupOffset);
    Header.BasisOffset   = BasisGroupOffset + BasisOffset;
    // Clip over the maximum basis count
    if(Header.BasisOffset + BasisCount > MI.MaxBasisCount) {
        Header.Class = 0;
    }

    // Negative depths stands for invalid probes
    Header.LinearDepth   = (bValid ? 1 : -1) * GetLinearDepth(Depth);
    int2 TileCoords      = int2(DispatchID % MI.TileDimensions.x, DispatchID / MI.TileDimensions.x);
    Header.Position      = RecoverWorldPositionHiRes(Header.ScreenPosition);
    Header.Normal        = normalize(g_GeometryNormalTexture.Load(int3(Header.ScreenPosition, 0)).xyz * 2.f - 1.f);
    WriteScreenProbeHeader(DispatchID, Header);
}

float3 GetUniformScreenProbePositionFromGBuffer (int2 TileCoords, float LinearDepth, bool bPrevious) {
    float2 UV = GetUniformScreenProbeScreenUV(TileCoords, bPrevious);
    // Multiply by linear depth to get rid of the perspective divide
    float4 Position = float4(UV2NDC2(UV) * LinearDepth, LinearDepth, 1);
    // Transform to world space without the perspective divide (as we already has the linear depth)
    return mul(Position, MI.CameraProjViewInv).xyz;
}

void CalculateSSRCSampleWeightsForUniformScreenProbes (
    float2 ScreenCoords,
    float3 Position,
    float  LinearDepth,
    float3 Normal,
    out int2 ScreenTileBaseCoords,
    out float4 Weights,
    bool bPrevious = false
) {
    int2 ScreenCoordsProbeGrid = clamp(ScreenCoords - GetTileJitter(bPrevious), 0, MI.ScreenDimensions - 1.xx);
    int2 TileCoordsX00         = min(ScreenCoordsProbeGrid / SSRC_TILE_SIZE, MI.TileDimensions - 2);
    // Pad the bilinear filtering weights
    int BilinearExpand = 1;
    float2 Bilinear    = 
        (ScreenCoordsProbeGrid - TileCoordsX00 * SSRC_TILE_SIZE + BilinearExpand) 
        / (float)(SSRC_TILE_SIZE + 2 * BilinearExpand);
    float4 CornerLinearDepths;
    CornerLinearDepths.x = GetScreenProbeLinearDepth(TileCoordsX00 + int2(0, 0), bPrevious);
    CornerLinearDepths.y = GetScreenProbeLinearDepth(TileCoordsX00 + int2(1, 0), bPrevious);
    CornerLinearDepths.z = GetScreenProbeLinearDepth(TileCoordsX00 + int2(0, 1), bPrevious);
    CornerLinearDepths.w = GetScreenProbeLinearDepth(TileCoordsX00 + int2(1, 1), bPrevious);
    Weights = float4(
        (1.f - Bilinear.x) * (1.f - Bilinear.y),
        Bilinear.x * (1.f - Bilinear.y),
        (1.f - Bilinear.x) * Bilinear.y,
        Bilinear.x * Bilinear.y
    );
    float4 DepthWeights;
    float4 PixelPlane  = float4(Normal, dot(Position, Normal));
    float3 PositionX00 = GetUniformScreenProbePositionFromGBuffer(TileCoordsX00 + int2(0, 0), CornerLinearDepths.x, bPrevious);
    float3 PositionX10 = GetUniformScreenProbePositionFromGBuffer(TileCoordsX00 + int2(1, 0), CornerLinearDepths.y, bPrevious);
    float3 PositionX01 = GetUniformScreenProbePositionFromGBuffer(TileCoordsX00 + int2(0, 1), CornerLinearDepths.z, bPrevious);
    float3 PositionX11 = GetUniformScreenProbePositionFromGBuffer(TileCoordsX00 + int2(1, 1), CornerLinearDepths.w, bPrevious);
    float4 PlaneDistances;
    PlaneDistances.x = abs(dot(PixelPlane, float4(PositionX00, -1.f)));
    PlaneDistances.y = abs(dot(PixelPlane, float4(PositionX10, -1.f)));
    PlaneDistances.z = abs(dot(PixelPlane, float4(PositionX01, -1.f)));
    PlaneDistances.w = abs(dot(PixelPlane, float4(PositionX11, -1.f)));
    float4 RelativeDepthDifference = PlaneDistances / LinearDepth;
    // Negative depths stands for invalid probes
    DepthWeights = select(
        CornerLinearDepths > 0, 
        exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference)),
        0.0
    );
    Weights *= DepthWeights;
}

void CalculateSSRCSampleWeights (
    float2 ScreenCoords,
    float3 Position,
    float  LinearDepth,
    float3 Normal,
    out SSRC_SampleData Sample,
    bool bPrevious = false
) {
    uint2 TileCoordsX00;
    CalculateSSRCSampleWeightsForUniformScreenProbes(
        ScreenCoords,
        Position,
        LinearDepth,
        Normal,
        TileCoordsX00,
        Sample.Weights,
        bPrevious
    );
    Sample.Index[0] = TileCoordsX00 + int2(0, 0);
    Sample.Index[1] = TileCoordsX00 + int2(1, 0);
    Sample.Index[2] = TileCoordsX00 + int2(0, 1);
    Sample.Index[3] = TileCoordsX00 + int2(1, 1);
    
    // Weight the adaptive probes and search within the nearest tiles
    {
        float Epsilon = .01f;
		float4 PixelPlane = float4(Normal, dot(Position, Normal));
        for (uint CornerIndex = 0; CornerIndex < 4; CornerIndex++)
		{
			if (Sample.Weights[CornerIndex] <= Epsilon)
			{
				int2 TileCoords = TileCoordsX00 + uint2(CornerIndex % 2, CornerIndex / 2);
				int NumAdaptiveProbes = 
                    bPrevious ? g_RWPreviousTileAdaptiveProbeCountTexture[TileCoords] 
                    : g_RWTileAdaptiveProbeCountTexture[TileCoords];
                [unroll(1 << (SSRC_MAX_ADAPTIVE_PROBE_LAYERS * 2))]
				for (uint AdaptiveProbeListIndex = 0; AdaptiveProbeListIndex < NumAdaptiveProbes; AdaptiveProbeListIndex++)
				{
                    // TODO reconstruct probe data from G-Buffer to reduce VRAM bandwidth when shading

					int  AdaptiveProbeIndex1 = GetAdaptiveProbeIndex(TileCoords, AdaptiveProbeListIndex, bPrevious);
					int  ScreenProbeIndex1   = AdaptiveProbeIndex1 + MI.UniformScreenProbeCount;
                    int2 ScreenProbeIndex    = int2(ScreenProbeIndex1 % MI.TileDimensions.x, ScreenProbeIndex1 / MI.TileDimensions.x);

                    ProbeHeader Header        = GetScreenProbeHeader(ScreenProbeIndex1, bPrevious);
					int2  ProbeScreenPosition = Header.ScreenPosition;
					float ProbeLinearDepth    = Header.LinearDepth;
					
					float NewDepthWeight = 0;

                    float3 ProbePosition = Header.Position;
                    float  PlaneDistance = abs(dot(float4(ProbePosition, -1), PixelPlane));
                    float RelativeDepthDifference = PlaneDistance / LinearDepth;
                    NewDepthWeight = exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference));

					float2 DistanceToScreenProbe = abs(ProbeScreenPosition - ScreenCoords);
					float NewCornerWeight = 1.0f - saturate(min(DistanceToScreenProbe.x, DistanceToScreenProbe.y) / (float)(SSRC_TILE_SIZE));
					float NewInterpolationWeight = NewDepthWeight * NewCornerWeight;

					if (NewInterpolationWeight > Sample.Weights[CornerIndex])
					{
						Sample.Weights[CornerIndex] = NewInterpolationWeight;
						Sample.Index[CornerIndex] = ScreenProbeIndex;
					}
				}
			}
		}
    }
}


groupshared int LocalNumProbesToAllocate;
groupshared int LocalAdaptiveProbeOffset;
groupshared int2 LocalProbeScreenPositionsToAllocate[WAVE_SIZE];
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateAdaptiveProbes (int DispatchID : SV_DispatchThreadID, int LocalID : SV_GroupThreadID) {
    if(WaveIsFirstLane()) {
        LocalNumProbesToAllocate = 0;
    }
    GroupMemoryBarrierWithGroupSync();
// This macro is passed in by compiler arguments
#ifndef SSRC_ADAPTIVE_PROBE_LAYER
#define SSRC_ADAPTIVE_PROBE_LAYER 0
#endif
    const int AdaptiveProbeDownsampleFactor = SSRC_TILE_SIZE / (2 << SSRC_ADAPTIVE_PROBE_LAYER);

    {
        int2 DownsampledTileDimensions = MI.ScreenDimensions / AdaptiveProbeDownsampleFactor;
        int2 TileCoords = int2(
            DispatchID % DownsampledTileDimensions.x,
            DispatchID / DownsampledTileDimensions.x
        );
        // Omit the adaptive probe that overlaps with the previous layer
        if(any((TileCoords&1) != 0)) {
            // Compute the screen coords for current adaptive probe
            int2 AdaptiveProbeScreenPosition = TileCoords * AdaptiveProbeDownsampleFactor + GetTileJitter();
            float Depth = g_DepthTexture.Load(int3(AdaptiveProbeScreenPosition, 0)).x;
            bool  bValid = Depth < 1.f;
            if(bValid) {
                float3 WorldPosition = RecoverWorldPositionHiRes(AdaptiveProbeScreenPosition);
                float  LinearDepth   = GetLinearDepth(Depth);
                float3 GeometryNormal = normalize(g_GeometryNormalTexture.Load(int3(AdaptiveProbeScreenPosition, 0)).xyz * 2.f - 1.f);
                SSRC_SampleData Sample;

                CalculateSSRCSampleWeights(
                    AdaptiveProbeScreenPosition,
                    WorldPosition,
                    LinearDepth,
                    GeometryNormal,
                    Sample
                );

                float Epsilon = .01f;
                Sample.Weights /= max(dot(Sample.Weights, 1), Epsilon);

                float LightingIsValid = (dot(Sample.Weights, 1) < 1.0f - Epsilon) ? 0.0f : 1.0f;

                if (!LightingIsValid)
                {
                    int ListIndex;
                    InterlockedAdd(LocalNumProbesToAllocate, 1, ListIndex);
                    LocalProbeScreenPositionsToAllocate[ListIndex] = AdaptiveProbeScreenPosition;
                }
            }
        }
    }
    
    GroupMemoryBarrierWithGroupSync();
    
    if(WaveIsFirstLane()) {
        InterlockedAdd(g_RWAdaptiveProbeCountBuffer[0], LocalNumProbesToAllocate, LocalAdaptiveProbeOffset);
    }
    
    GroupMemoryBarrierWithGroupSync();

    int AdaptiveProbeIndex = LocalID + LocalAdaptiveProbeOffset; 

    if(!MI.NoAdaptiveProbes && LocalID < LocalNumProbesToAllocate && AdaptiveProbeIndex < MI.MaxAdaptiveProbeCount) {
        // The probe must be valid upon allocation.
        int ScreenProbeIndex1   = AdaptiveProbeIndex + MI.UniformScreenProbeCount;
        ProbeHeader Header;
        Header.ScreenPosition   = LocalProbeScreenPositionsToAllocate[LocalID];
        float Depth             = g_DepthTexture.Load(int3(Header.ScreenPosition, 0)).x;
        Header.Class  = ComputeProbeRankFromSplattedError(Header.ScreenPosition);
        int BasisCount      = GetProbeBasisCountFromClass(Header.Class);
        int BasisOffset     = WavePrefixSum(BasisCount);
        int BasisCountSum   = WaveActiveSum(BasisCount);
        int BasisGroupOffset;
        if(WaveIsFirstLane()) {
            InterlockedAdd(g_RWAllocatedProbeSGCountBuffer[0], BasisCountSum, BasisGroupOffset);
        }
        BasisGroupOffset = WaveReadLaneFirst(BasisGroupOffset);
        Header.BasisOffset   = BasisGroupOffset + BasisOffset;
        // Clip over the maximum basis count
        if(Header.BasisOffset + BasisCount > MI.MaxBasisCount) {
            Header.Class = 0;
        }
        Header.LinearDepth   = GetLinearDepth(Depth);
        Header.Position      = RecoverWorldPositionHiRes(Header.ScreenPosition);
        Header.Normal        = normalize(g_GeometryNormalTexture.Load(int3(Header.ScreenPosition, 0)).xyz * 2.f - 1.f);
        int2 ScreenProbeIndex = int2(ScreenProbeIndex1 % MI.TileDimensions.x, ScreenProbeIndex1 / MI.TileDimensions.x);
        WriteScreenProbeHeader(ScreenProbeIndex, Header);
    }
}

// Write dispatch parameters for SSRC computations
[numthreads(1, 1, 1)]
void SSRC_WriteProbeDispatchParameters () {
    DispatchCommand Command;
    Command.num_groups_x = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0];
    Command.num_groups_y = 1;
    Command.num_groups_z = 1;
    g_RWDispatchCommandBuffer[0] = Command;
}

float  LocalSGSize4[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
SGData LocalSGData4[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
SGData LocalSGData4New[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
int    LocalSGMaxMatchIndex[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
int    LocalSGNewIndex[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
// Initialize probe cache from the previous frame, one group per probe
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_ReprojectProbeHistory (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {
    if(MI.ResetCache) return ;
    int2 ProbeIndex = int2(GroupID % MI.TileDimensions.x, GroupID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    float4 PrevHomogeneousW = mul(MI.PrevCameraProjView, float4(Header.Position, 1));
    if(PrevHomogeneousW.w <= 0) {
        return ;
    }sdfasfsdafdasfasdf
    float3 PrevHomogeneous = PrevHomogeneousW.xyz / PrevHomogeneousW.w;
    float2 PrevScreenPosition = MI.ScreenDimensions * NDC22UV(PrevHomogeneous.xy);
    SSRC_SampleData Sample;
    CalculateSSRCSampleWeights(
        Header.ScreenPosition,
        Header.Position,
        Header.LinearDepth,
        Header.Normal,
        Sample,
        true
    );
    float Epsilon = .01f;
    Sample.Weights /= max(dot(Sample.Weights, 1), Epsilon);

    int BasisOffsets[4];
    BasisOffsets[0] = GetScreenProbeBasisOffset(Sample.Index[0], true);
    BasisOffsets[1] = GetScreenProbeBasisOffset(Sample.Index[1], true);
    BasisOffsets[2] = GetScreenProbeBasisOffset(Sample.Index[2], true);
    BasisOffsets[3] = GetScreenProbeBasisOffset(Sample.Index[3], true);
    
    int BasisCount[4];
    BasisCount[0] = GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[0], true).Class);
    BasisCount[1] = GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[1], true).Class);
    BasisCount[2] = GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[2], true).Class);
    BasisCount[3] = GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[3], true).Class);
    int NumBasis0 = BasisCount[0] + BasisCount[1];
    int NumBasis1 = BasisCount[2] + BasisCount[3];
    int NumBasis  = NumBasis0 + NumBasis1;

    // Fetch the basis data from the previous frame
    {
#if SSRC_MAX_NUM_BASIS_PER_PROBE <= 8
        int BasisRankBase = 0;
#else
        [unroll((SSRC_MAX_NUM_BASIS_PER_PROBE * 4 + WAVE_SIZE - 1) / WAVE_SIZE)]
        for(int BasisRankBase = 0; BasisRankBase < NumBasis; BasisRankBase += WAVE_SIZE) {
#endif
            int BasisRank = BasisRankBase + LocalID;
            if(BasisRank < NumBasis) {
                int BasisOffset;
                float Weight;
                if(BasisRank < NumBasis0) {
                    BasisOffset = BasisOffsets[BasisRank < BasisCount[0] ? 0 : 1] + BasisRank;
                    Weight      = Sample.Weights[BasisRank < BasisCount[0] ? 0 : 1];
                } else {
                    BasisOffset = BasisOffsets[BasisRank < NumBasis0 + BasisCount[2] ? 2 : 3] + BasisRank - NumBasis0;
                    Weight      = Sample.Weights[BasisRank < NumBasis0 + BasisCount[2] ? 2 : 3];
                }
                SGData SG = FetchBasisData(BasisOffset + BasisRank, true);
                // FIXME directional reprojection is missing
                // Scale the color by the weight
                SG.Color = SG.Color * Weight;
                LocalSGData4[BasisRank] = SG;
                LocalSGSize4[BasisRank] = SGIntegrate(SG.Lambda) * dot(SG.Color, 1.f.xxx);
            }
#if SSRC_MAX_NUM_BASIS_PER_PROBE > 8
        }
#endif
    }
    GroupMemoryBarrierWithGroupSync();
    // Simple N^2 Sort
    {
        SGData ThreadSG[(SSRC_MAX_NUM_BASIS_PER_PROBE*4 + WAVE_SIZE - 1) / WAVE_SIZE];
        int    ThreadSGRank[(SSRC_MAX_NUM_BASIS_PER_PROBE*4 + WAVE_SIZE - 1) / WAVE_SIZE];
#if SSRC_MAX_NUM_BASIS_PER_PROBE <= 8
        int BasisRankBase = 0;
#else
        [unroll((SSRC_MAX_NUM_BASIS_PER_PROBE * 4 + WAVE_SIZE - 1) / WAVE_SIZE)]
        for(int BasisRankBase = 0; BasisRankBase < NumBasis; BasisRankBase += WAVE_SIZE) {
#endif
            int BasisRank = BasisRankBase + LocalID;
            if(BasisRank < NumBasis) {
                float Weight = LocalSGSize4[BasisRank];
                int SortedRank = 0;
                for(int i = 0; i < NumBasis; i++) {
                    if(LocalSGSize4[i] > Weight || (LocalSGSize4[i] == Weight && i < BasisRank)) {
                        SortedRank ++;
                    }
                }
                ThreadSGRank[BasisRankBase / WAVE_SIZE] = SortedRank;
            }
#if SSRC_MAX_NUM_BASIS_PER_PROBE > 8
        }
#endif
        [unroll((SSRC_MAX_NUM_BASIS_PER_PROBE * 4 + WAVE_SIZE - 1) / WAVE_SIZE)]
        for(int i = 0; i * WAVE_SIZE < NumBasis; i++) {
            int BasisRank = i * WAVE_SIZE + LocalID;
            if(BasisRank < NumBasis) {
                ThreadSG[i] = LocalSGData4[BasisRank];
            }
        }
        GroupMemoryBarrierWithGroupSync();
        [unroll((SSRC_MAX_NUM_BASIS_PER_PROBE * 4 + WAVE_SIZE - 1) / WAVE_SIZE)]
        for(int i = 0; i * WAVE_SIZE < NumBasis; i++) {
            int BasisRank = i * WAVE_SIZE + LocalID;
            if(BasisRank < NumBasis) {
                LocalSGData4[ThreadSGRank[i]] = ThreadSG[i];
            }
        }
    }
    GroupMemoryBarrierWithGroupSync();

    int CurrentProbeBasisCount = GetProbeBasisCountFromClass(Header.Class);
    // The number of merges required to reduce the number of SGs
    int MergeCount = max(NumBasis - CurrentProbeBasisCount, 0);

    // Progressively merges the candidate SGs.
    {
        const int REPEAT = (SSRC_MAX_NUM_BASIS_PER_PROBE * 4 + WAVE_SIZE-1) / WAVE_SIZE;
        [unroll(4)]
        for(int Iteration = 0; MergeCount > 0 && Iteration < 4; Iteration ++) {
            // Compute the distance between each pair of SGs
            {
#if SSRC_MAX_NUM_BASIS_PER_PROBE <= 8
            int BasisRankBase = 0;
#else
            [unroll((SSRC_MAX_NUM_BASIS_PER_PROBE * 4 + WAVE_SIZE - 1) / WAVE_SIZE)]
            for(int BasisRankBase = 0; BasisRankBase < NumBasis; BasisRankBase += WAVE_SIZE) {
#endif
                int BasisRank = BasisRankBase + LocalID;
                int MaxIndex  = -1;
                float MaxSimilarity = 0.f;
                SGData CurrentSG = LocalSGData4[BasisRank];
                [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
                for (int i = 0; i<NumBasis; i++) {
                    float X = EvaluateSG(LocalSGData4[BasisRank], CurrentSG.Direction);
                    float Y = EvaluateSG(CurrentSG, LocalSGData4[i].Direction);
                    float Similarity = X * Y;
                    if(Similarity > MaxSimilarity) {
                        MaxSimilarity = Similarity;
                        MaxIndex = i;
                    }
                }
                LocalSGMaxMatchIndex[BasisRank] = MaxIndex;
#if SSRC_MAX_NUM_BASIS_PER_PROBE > 8
            }
#endif
            }
            int NumNewBasis = 0;
            // Pairing the SGs for merging, single threaded algorithm
            if(WaveIsFirstLane()) {
                // Simple greedy algorithm instead of dfs alike precise algirithm
                [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
                for(int i = 0; i<NumBasis; i++) {
                    int MaxIndex = LocalSGMaxMatchIndex[i];
                    if(MaxIndex >= 0) {
                        if(MergeCount > 0) {
                            LocalSGMaxMatchIndex[MaxIndex] = -1;
                            MergeCount --;
                        } else {
                            LocalSGMaxMatchIndex[i] = i;
                        }
                        LocalSGNewIndex[i] = NumNewBasis++;
                    }
                }
            }
            NumNewBasis = WaveReadLaneFirst(NumNewBasis);
            MergeCount  = WaveReadLaneFirst(MergeCount);
            GroupMemoryBarrierWithGroupSync();
            // Merge the SGs
            {
#if SSRC_MAX_NUM_BASIS_PER_PROBE <= 8
            int BasisRankBase = 0;
#else
            [unroll((SSRC_MAX_NUM_BASIS_PER_PROBE * 4 + WAVE_SIZE - 1) / WAVE_SIZE)]
            for(int BasisRankBase = 0; BasisRankBase < NumBasis; BasisRankBase += WAVE_SIZE) {
#endif
                int BasisRank = BasisRankBase + LocalID;
                int MaxIndex  = LocalSGMaxMatchIndex[BasisRank];
                if(MaxIndex >= 0) {
                    SGData X = LocalSGData4[BasisRank];
                    SGData Y = LocalSGData4[MaxIndex];
                    SGData NewSG = MergeSG(X, Y);
                    LocalSGData4New[LocalSGNewIndex[BasisRank]] = NewSG;
                }
#if SSRC_MAX_NUM_BASIS_PER_PROBE > 8
            }
#endif
            }
            // Swap the data
            {
                [unroll((SSRC_MAX_NUM_BASIS_PER_PROBE * 4 + WAVE_SIZE - 1) / WAVE_SIZE)]
                for(int i = 0; i * WAVE_SIZE < NumNewBasis; i++) {
                    int BasisRank = i * WAVE_SIZE + LocalID;
                    if(BasisRank < NumNewBasis) {
                        LocalSGData4[BasisRank] = LocalSGData4New[BasisRank];
                    }
                }
            }
            NumBasis = NumNewBasis;
            GroupMemoryBarrierWithGroupSync();
        }
    }
    // Write the new SGs to the buffer
    {
#if SSRC_MAX_BASIS_PER_TILE > WAVE_SIZE
#error "SSRC_MAX_BASIS_PER_TILE must be less than or equal to WAVE_SIZE"
#endif
        if(WaveIsFirstLane()) {
            float3 Irradiance = 
                GetScreenProbeIrradiance(Sample.Index[0]) * Sample.Weights[0] +
                GetScreenProbeIrradiance(Sample.Index[1]) * Sample.Weights[1] +
                GetScreenProbeIrradiance(Sample.Index[2]) * Sample.Weights[2] +
                GetScreenProbeIrradiance(Sample.Index[3]) * Sample.Weights[3];
            WriteScreenProbeIrradiance(ProbeIndex, Irradiance);
        }
        int BasisOffset = Header.BasisOffset;
        if(LocalID < NumBasis) {
            WriteBasisData(BasisOffset + LocalID, LocalSGData4[LocalID]);
        }
    }
}

// Allocate update rays for each probe
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateUpdateRays (int DispatchID : SV_DispatchThreadID) {
    // NOTE: the allocation number must be a multiple of WAVE_SIZE
    // NOTE: and no greater than SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE

    // Naive uniform
    // TODO actually allocate rays 
    g_RWProbeUpdateRayCountBuffer[DispatchID] = WAVE_SIZE;
    // NOTE: importance sampling need to update 
}

// TODO: Should we study from Lumen to use a large number?
#define MIN_PDF_TO_TRACE 1e-4f //1e-1f

// A scan sum is performed to accumulate raycount
SGData LocalSGData[SSRC_MAX_NUM_BASIS_PER_PROBE];
float LocalSGSize[SSRC_MAX_NUM_BASIS_PER_PROBE];
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_SampleUpdateRays (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {

    const float Epsilon = 1e-6f;

    // We assume that ray count is always a multiple of WAVE_SIZE
    int  ProbeIndex1 = GroupID;
    int2 ProbeIndex  = int2(ProbeIndex1 % MI.TileDimensions.x, ProbeIndex1 / MI.TileDimensions.x);
    int  RayCount    = g_RWProbeUpdateRayCountBuffer[ProbeIndex1];
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    int  BasisCount  = GetProbeBasisCountFromClass(Header.Class);
    // Reuse the shmem from reprojection kernel
#if SSRC_MAX_NUM_BASIS_PER_PROBE > WAVE_SIZE
#error "SSRC_MAX_NUM_BASIS_PER_PROBE must be less than or equal to WAVE_SIZE"
#endif
    {
        int BasisRank = LocalID;
        if(BasisRank < BasisCount) {
            SGData SG = FetchBasisData(Header.BasisOffset + BasisRank);
            LocalSGData[BasisRank] = SG;
            float SGSize = SGIntegrate(SG.Lambda) * dot(SG.Color, 1.f.xxx);
            LocalSGSize[BasisRank] = SGSize;
        } else if(BasisRank < SSRC_MAX_NUM_BASIS_PER_PROBE) {
            LocalSGSize[BasisRank] = 0;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    float IrradianceSize = FOUR_PI * dot(g_RWProbeIrradianceTexture[ProbeIndex].xyz, 1.f.xxx);
    float ThreadSizeSums[SSRC_MAX_NUM_BASIS_PER_PROBE];
    [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE)]
    for(int i = 0; i < BasisCount; i++) {
        ThreadSizeSums[i] = i == 0 ? 0 : ThreadSizeSums[i-1];
        ThreadSizeSums[i] += LocalSGSize[i];
    }
    float SumSizeBasis = ThreadSizeSums[BasisCount - 1];
    float SumSize = SumSizeBasis + IrradianceSize;
    
    Random rng = MakeRandom(GroupID * WAVE_SIZE + LocalID, MI.FrameSeed);
    // Sample ray SG
#if SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE % WAVE_SIZE != 0
#error "SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE must be a multiple of WAVE_SIZE"
#endif
    [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
    for(int RayRankBase = 0; RayRankBase < RayCount; RayRankBase += WAVE_SIZE) {
        // We assume that ray count is always a multiple of WAVE_SIZE
        int RayRank = RayRankBase + LocalID;
        float u    = rng.rand();
        float U    = u * SumSize;
        int BasisRank = BasisCount;
        [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE)]
        for(int i = 0; i<BasisCount; i++) {
            if(U < ThreadSizeSums[i]) {
                BasisRank = i;
                break;
            }
        }
        // TODO: weight the cosine term when sampling
        // Really necessary? Lumen may not be doing that.
        float3 RayDirection, Normal;
        float  RayPdf = 0;
        if(BasisRank == BasisCount) {
            // Sample from the irradiance (uniform hemisphere)
            float3 Irradiance = g_RWProbeIrradianceTexture[ProbeIndex].xyz;
            RayDirection  = UniformSampleHemisphere(rng.rand2());
            Normal        = GetScreenProbeNormal(ProbeIndex);
        } else {
            SGData SG = LocalSGData[BasisRank];
            RayDirection = SampleSG(rng.rand2(), SG.Lambda, RayPdf);
            Normal       = SG.Direction;
        }
        float3 Tangent, Bitangent;
        TangentVectors(Normal, Tangent, Bitangent);
        RayDirection = normalize(Tangent * RayDirection.x + Bitangent * RayDirection.y + Normal * RayDirection.z);
        // Compute ray pdf
        {
            [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE)]
            for(int i = 0; i < BasisCount; i++) {
                SGData SG = LocalSGData[i];
                RayPdf += LocalSGSize[i] * SampleSGPDF(SG.Lambda, dot(RayDirection, SG.Direction));
            }
            if(dot(RayDirection, Normal) > 0) {
                RayPdf += UniformSampleHemispherePdf() * dot(g_RWProbeIrradianceTexture[ProbeIndex].xyz, 1.f.xxx);
            }
            RayPdf = RayPdf / max(SumSize, Epsilon);
        }
        // Pack the ray
        // TODO jitter the ray origin ?
        if(RayPdf >= MIN_PDF_TO_TRACE) {
            WriteUpdateRay(ProbeIndex, Header.ScreenPosition, RayRank, RayDirection, RayPdf);
        } else {
            // No need to do compressing since there're just a tiny number of rays being canceled
            WriteUpdateRay(ProbeIndex, Header.ScreenPosition, RayRank, float3(0, 0, 0), 0);
        }
    }
}


#define SSRC_DISPATCH_RAYS_GROUP_SIZE 8

[numthreads(1, 1, 1)]
void SSRC_GenerateTraceUpdateRays () {
    int ProbeCount = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0];
    int RayCount   = g_RWProbeUpdateRayOffsetBuffer[ProbeCount];
    DispatchRaysCommand dispatch_command_rays = (DispatchRaysCommand)0;
    dispatch_command_rays.ray_generation_shader_record = g_RTConstants.ray_generation_shader_record;
    dispatch_command_rays.miss_shader_table = g_RTConstants.miss_shader_table;
    dispatch_command_rays.hit_group_table = g_RTConstants.hit_group_table;
    dispatch_command_rays.callable_shader_table = g_RTConstants.callable_shader_table;
    dispatch_command_rays.width = RayCount;
    dispatch_command_rays.height = 1;
    dispatch_command_rays.depth = 1;
    g_RWDispatchRaysCommandBuffer[0] = dispatch_command_rays;

    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = 
        (RayCount + SSRC_DISPATCH_RAYS_GROUP_SIZE - 1) 
        / SSRC_DISPATCH_RAYS_GROUP_SIZE;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

void ScreenCacheUpdateHandleHit(uint DispatchID, inout ScreenCacheUpdatePayload payload, RayDesc ray, HitInfo hit_info)
{
    HashGridCache_Data data;
    data.eye_position = g_CameraPosition;
    data.hit_position = ray.Origin + payload.hit_dist * ray.Direction;
    data.direction    = ray.Direction;
    data.hit_distance = payload.hit_dist;

    // Record hit distance
    g_RWUpdateRayLinearDepthBuffer[DispatchID] = data.hit_distance;

    uint tile_index;
    bool is_new_tile;
    uint cell_index = HashGridCache_InsertCell(data, tile_index, is_new_tile);

    if (cell_index != kGI10_InvalidId)
    {
        // Bump the cell's decay to the max. now that it's been 'touched'
        uint previous_tile_decay;
        InterlockedExchange(g_HashGridCache_DecayTileBuffer[tile_index], g_FrameIndex, previous_tile_decay);

        HashGridCache_Visibility visibility;
        visibility.is_front_face   = hit_info.frontFace;
        visibility.instance_index  = hit_info.instanceIndex;
        visibility.geometry_index  = hit_info.geometryIndex;
        visibility.primitive_index = hit_info.primitiveIndex;
        visibility.barycentrics    = hit_info.barycentrics;

        // We update the cell index for later passes
        uint visibility_index;
        InterlockedAdd(g_HashGridCache_VisibilityCountBuffer[0], 1, visibility_index);
        g_HashGridCache_VisibilityBuffer[visibility_index]      = HashGridCache_PackVisibility(visibility);
        g_HashGridCache_VisibilityCellBuffer[visibility_index]  = cell_index;
        g_HashGridCache_VisibilityQueryBuffer[visibility_index] = DispatchID;

        // Write out bounds of visibility
        requestLightSampleLocation(data.hit_position);

        // If this cell is inside a new tile, we need to add the tile to the packed storage and clear its cells.
        if (is_new_tile)
        {
            uint packed_tile_index;
            InterlockedAdd(g_HashGridCache_PackedTileCountBuffer[0], 1, packed_tile_index);
            g_HashGridCache_PackedTileIndexBuffer[packed_tile_index] = tile_index;

            // Clear mip0 cells (others will be reset anyways by UpdateTiles)
            for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile_mip0; ++cell_offset)
            {
                uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
                g_HashGridCache_ValueBuffer[cell_index] = uint2(0, 0);
            }
        }

        // If we're the 1st invocation touching this cell (this frame), we want to clear the
        // scratch storage that'll be used for atomically updating the radiance.
        // The accumulation will be resolved in the 'UpdateTiles()' kernel to
        // avoid integer overflow.
        if (is_new_tile || previous_tile_decay != g_FrameIndex)
        {
            uint update_tile_index;
            InterlockedAdd(g_HashGridCache_UpdateTileCountBuffer[0], 1, update_tile_index);
            g_HashGridCache_UpdateTileBuffer[update_tile_index] = tile_index;
        }

#ifdef DEBUG_HASH_CELLS
        // For debugging purposes, we need to be able to retrieve the position
        // & orientation of cells as we iterate the content of the cache.
        // So, write the packed cell descriptor out to memory in this case.
        if (is_new_tile)
        {
            // Clear debug cells (all mips)
            for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile; ++cell_offset)
            {
                uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
                g_HashGridCache_DebugCellBuffer[cell_index] = HashGridCache_ClearDebugCell();
            }
        }

        float4 packed_debug_cell;
        uint debug_cell_index = HashGridCache_PackDebugCell(data, tile_index, packed_debug_cell);

        // BE CAREFUL: writing to g_HashGridCache_DebugCellBuffer isn't atomic and several writings could occur
        uint previous_cell_decay;
        InterlockedExchange(g_HashGridCache_DecayCellBuffer[debug_cell_index], g_FrameIndex, previous_cell_decay);
        if (previous_cell_decay != g_FrameIndex)
        {
            g_HashGridCache_DebugCellBuffer[debug_cell_index] = packed_debug_cell;
        }
#endif // DEBUG_HASH_CELLS
    }
}

void ScreenCacheUpdateHandleMiss(inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    payload.sky_sample = g_EnvironmentBuffer.SampleLevel(g_TextureSampler, ray.Direction, 0.0f).xyz;
}

void ScreenCacheUpdateTraceRayInline(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    ClosestRayQuery ray_query = TraceRay<ClosestRayQuery>(ray);

    // If we hit some geometry, we append a new world-space hash-grid cache query
    if (ray_query.CommittedStatus() == COMMITTED_NOTHING)
    {
        payload.hit_dist = ray_query.CommittedRayT();
        ScreenCacheUpdateHandleMiss(payload, ray);
    }
    else
    {
        payload.hit_dist = ray_query.CommittedRayT();
        ScreenCacheUpdateHandleHit(did, payload, ray, GetHitInfoRtInlineCommitted(ray_query));
    }
}

void ScreenCacheUpdateTraceRayRt(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    TraceRay(g_Scene, RAY_FLAG_NONE, 0xFFu, 0, 0, 0, ray, payload);
}

void ScreenCacheUpdateTraceRay(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
#if USE_INLINE_RT
    ScreenCacheUpdateTraceRayInline(did, payload, ray);
#else
    ScreenCacheUpdateTraceRayRt(did, payload, ray);
#endif
}

// Trace visibility rays to generate intersections for secondary vertices
void SSRC_TraceUpdateRays (uint DispatchID) {
    int ProbeCount = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0];
    int RayCount   = g_RWProbeUpdateRayOffsetBuffer[ProbeCount];
    if(DispatchID >= RayCount) return ;
    
    // Unpack ray data
    int2   ProbeIndex = UnpackUint16x2(g_RWUpdateRayProbeBuffer[DispatchID / WAVE_SIZE]);

    float3 GeometryNormal = GetScreenProbeNormal(ProbeIndex);
    float3 RayOrigin = offsetPosition(GetScreenProbePosition(ProbeIndex), GeometryNormal);

    float3 RayDirection   = OctahedronToUnitVector(unpackUnorm2x16(g_RWUpdateRayDirectionBuffer[DispatchID]) * 2 - 1);
    float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[DispatchID]);
    float  InvPdf = RayRadianceInvPdf.w;

    // Early out if the ray is invalid / clipped for too tiny pdf.
    if(InvPdf == 0) return ;

    // FIXME
    if(MI.DebugLight != 0 || dot(RayDirection, GeometryNormal) < 0.0f) {
        // Learn negative samples.
        g_RWUpdateRayRadianceInvPdfBuffer[DispatchID] = PackFp16x4Safe(float4(0.0f.xxx, InvPdf));
        float3 LightPos = MI.DebugLightPosition;
        float  DistSqr  = lengthSqr(LightPos - RayOrigin);
        float  R2       = MI.DebugLightSize * MI.DebugLightSize;
        float  MaxCosTheta = sqrt(DistSqr - R2) / sqrt(DistSqr);
        float  CosTheta = dot(normalize(LightPos - RayOrigin), RayDirection);
        float3 L = (CosTheta > MaxCosTheta) ? MI.DebugLightColor : 0.f;
        g_RWUpdateRayRadianceInvPdfBuffer[DispatchID] = PackFp16x4Safe(float4(L, InvPdf));
        g_RWUpdateRayLinearDepthBuffer[DispatchID] = asfdasdf;
        return ;
    }

    // Trace a visibility ray only.
    RayDesc VisibilityRayDesc;
    VisibilityRayDesc.Origin = RayOrigin;
    VisibilityRayDesc.Direction = RayDirection;
    VisibilityRayDesc.TMin = 0.f;
    VisibilityRayDesc.TMax = MAX_HIT_DISTANCE;

    ScreenCacheUpdatePayload payload;
    payload.sky_sample = float3(0.0f, 0.0f, 0.0f);
    ScreenCacheUpdateTraceRay(
        DispatchID,
        payload, VisibilityRayDesc
    );
    // Fallback to sky sample if no intersection
    g_RWUpdateRayRadianceInvPdfBuffer[DispatchID] = PackFp16x4Safe(float4(payload.sky_sample, InvPdf));
    g_RWUpdateRayLinearDepthBuffer[DispatchID]    = MI.CameraFar;
}

[numthreads(SSRC_DISPATCH_RAYS_GROUP_SIZE, 1, 1)]
void SSRC_TraceUpdateRaysMain (uint DispatchID : SV_DispatchThreadID) {
    SSRC_TraceUpdateRays(DispatchID);
}


// HiZ required for injection culling
[numthreads(8, 8, 1)]
void PrecomputeHiZ (int2 DispatchID : SV_DispatchThreadID) {
    int2 Dimensions;
    g_RWHiZ_Out.GetDimensions(Dimensions.x, Dimensions.y);
    if(any(DispatchID >= Dimensions)) {
        return;
    }
    float X00 = g_RWHiZ_In[int2(2 * DispatchID.x + 0, 2 * DispatchID.y + 0)].x;
    float X01 = g_RWHiZ_In[int2(2 * DispatchID.x + 0, 2 * DispatchID.y + 1)].x;
    float X10 = g_RWHiZ_In[int2(2 * DispatchID.x + 1, 2 * DispatchID.y + 0)].x;
    float X11 = g_RWHiZ_In[int2(2 * DispatchID.x + 1, 2 * DispatchID.y + 1)].x;
#ifdef HIZ_MIN
    float X0 = min(X00, X01);
    float X1 = min(X10, X11);
    float X = min(X0, X1);
#else
    if(X00 == 1.f) X00 = 0.f;
    if(X01 == 1.f) X01 = 0.f;
    if(X10 == 1.f) X10 = 0.f;
    if(X11 == 1.f) X11 = 0.f;
    float X0 = max(X00, X01);
    float X1 = max(X10, X11);
    float X = max(X0, X1);
    if(X == 0.f) X = 1.f;
#endif
    g_RWHiZ_Out[DispatchID] = X;
}


[numthreads(SSRC_TILE_SIZE, SSRC_TILE_SIZE, 1)]
void SSRC_ReprojectPreviousUpdateError (int2 DispatchID : SV_DispatchThreadID) {
    if(any(DispatchID >= MI.ScreenDimensions)) {
        return;
    }

    float3 NormalPrev = g_GeometryNormalTexture.Load(int3(DispatchID, 0)).xyz;
    bool   IsSkyPixel = (dot(NormalPrev, NormalPrev) == 0.0f ? true : false);

    if (IsSkyPixel)
    {
        g_RWUpdateErrorSplatTexture[DispatchID] = 0.f;
        return;
    }
    float3 Normal = normalize(2.f * NormalPrev - 1.f);

    // Reproject the update error texture from previous frame to current frame
    float4 packed_visibility = g_VisibilityTexture.Load(int3(DispatchID, 0));
    float2 Barycentrics      = packed_visibility.xy;
    int   InstanceIndex      = asint(packed_visibility.z);
    int   PrimitiveIndex      = asint(packed_visibility.w);

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[InstanceIndex];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    TriangleNormUV vertices = fetchVerticesNormUV(mesh, PrimitiveIndex);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);

    vertices.n0 = transformNormal(vertices.n0, transform);
    vertices.n1 = transformNormal(vertices.n1, transform);
    vertices.n2 = transformNormal(vertices.n2, transform);

    float3   world    = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);

    float3 homogeneous = transformPointProjection(world, MI.CameraProjView);

    float2 UV          = 0.5f * float2(homogeneous.x, -homogeneous.y) + 0.5f;
    float  Depth       = homogeneous.z;

    // Severe precision loss here if we use the following reprojection method
    // float2 UV = (float2(DispatchID) + 0.5f) * MI.OutputDimensionsInv;
    // float Depth = g_DepthTexture.Load(int3(UV, 0)).x;
    // float3 Normal = normalize(2.f * g_GeometryNormalTexture.Load(int3(UV, 0)).xyz - 1.f);
    // float3 homogeneous = float3(UV2NDC2(UV), Depth);

    if (all(UV > 0.0f) && all(UV < 1.0f) && Depth > 0.0f && Depth < 1.0f)
    {
        float2 previous_uv = UV - g_VelocityTexture.SampleLevel(g_NearestSampler, UV, 0.0f).xy;

        if (all(previous_uv > 0.0f) && all(previous_uv < 1.0f))
        {
            float3 homogeneous2 = transformPointProjection(homogeneous, MI.Reprojection);
            homogeneous2.z      = GetLinearDepth(homogeneous2.z);

            float  previous_depth  = GetLinearDepth(g_PreviousDepthTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).x);
            float3 previous_normal = normalize(2.0f * g_PreviousGeometryNormalTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz - 1.0f);

            if (dot(previous_normal, Normal) > 0.5f && abs(previous_depth - homogeneous2.z) / homogeneous2.z < 5e-2f)
            {
                // Using linear sampler in reprojection can significantly increase the reprojected error, why?
                float PreviousError = g_PreviousUpdateErrorSplatTexture.SampleLevel(g_NearestSampler, previous_uv, 0).x;
                g_RWUpdateErrorSplatTexture[DispatchID] = PreviousError;
                return; 
            }
        }
    }
    
    // TODO allocate a initial weight for the update error
    // FIXME
    g_RWUpdateErrorSplatTexture[DispatchID] = 0.f;
}

// UpdateErrorSplatTexture is later mipmapped.

[numthreads(WAVE_SIZE, 1, 1)]
void ClearReservoirs(in uint did : SV_DispatchThreadID)
{
    g_Reservoir_HashBuffer[did]      = 0;
    g_Reservoir_HashCountBuffer[did] = 0;
}


[numthreads(WAVE_SIZE, 1, 1)]
void GenerateReservoirs(in uint DispatchID : SV_DispatchThreadID)
{
    if (DispatchID >= g_HashGridCache_VisibilityCountBuffer[0])
    {
        return; // out of bounds
    }

    // Load our visibility sample
    float4                   packed_visibility = g_HashGridCache_VisibilityBuffer[DispatchID];
    HashGridCache_Visibility visibility        = HashGridCache_UnpackVisibility(packed_visibility);

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[visibility.instance_index];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index + visibility.geometry_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    TriangleNormUV vertices = fetchVerticesNormUV(mesh, visibility.primitive_index);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);

    vertices.n0 = transformNormal(vertices.n0, transform);
    vertices.n1 = transformNormal(vertices.n1, transform);
    vertices.n2 = transformNormal(vertices.n2, transform);

    float3   world    =                                                       interpolate(vertices.v0, vertices.v1, vertices.v2, visibility.barycentrics);
    float3   normal   = (visibility.is_front_face ? 1.0f : -1.0f) * normalize(interpolate(vertices.n0, vertices.n1, vertices.n2, visibility.barycentrics));
    Material material = g_MaterialBuffer[instance.material_index];

    // Recover the ray origin
    uint query_index = g_HashGridCache_VisibilityQueryBuffer[DispatchID];
    // Queries are indexed with ray index
    int2 ProbeIndex = UnpackUint16x2(g_RWUpdateRayProbeBuffer[query_index / WAVE_SIZE]);
    float3 origin = GetScreenProbePosition(ProbeIndex);
    float2 mesh_uv = interpolate(vertices.uv0, vertices.uv1, vertices.uv2, visibility.barycentrics);

    // Patch the screen space cache with some emissivity information:
    // We bypass the hash-grid cache entirely here, as adding emissive information to the cells
    // effectively enlarges the area light (due to the spatial nature of the grid) and leads to
    // light leaks and generally poorer visuals.

    if (visibility.is_front_face && dot(material.emissivity.xyz, material.emissivity.xyz) > 0.0f)
    {
        MaterialEmissive emissive = MakeMaterialEmissive(material, mesh_uv);
        float4 RadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[query_index]);
        RadianceInvPdf.xyz = emissive.emissive;
        g_RWUpdateRayRadianceInvPdfBuffer[query_index] = PackFp16x4Safe(RadianceInvPdf);
        return; // do not continue past an emissive surface
    }

    // We can perform some temporal radiance feedback from last frame if direct lighting was
    // evaluated.
    // If successful, we inject the reprojected radiance into the cache so it can be re-used
    // by neighbor vertices but bypass the filtered readback as the sample is already denoised.
    {
        float3 homogeneous = transformPointProjection(world, MI.CameraProjView);

        float2 uv    = 0.5f * float2(homogeneous.x, -homogeneous.y) + 0.5f;
        float  depth = homogeneous.z;

        if (all(uv > 0.0f) && all(uv < 1.0f) && depth > 0.0f && depth < 1.0f)
        {
            float2 previous_uv = uv - g_VelocityTexture.SampleLevel(g_NearestSampler, uv, 0.0f).xy;

            if (all(previous_uv > 0.0f) && all(previous_uv < 1.0f))
            {
                float3 homogeneous2 = transformPointProjection(float3(2.0f * float2(uv.x, 1.0f - uv.y) - 1.0f, depth), g_Reprojection);
                homogeneous2.z      = GetLinearDepth(homogeneous2.z);

                float  previous_depth  = GetLinearDepth(g_PreviousDepthTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).x);
                float3 previous_normal = normalize(2.0f * g_PreviousGeometryNormalTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz - 1.0f);

                if (dot(previous_normal, normal) > 5e-1f && abs(previous_depth - homogeneous2.z) / homogeneous2.z < 5e-2f)
                {
                    float3 previous_lighting = g_PrevCombinedIlluminationTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz;

                    uint  cell_index         = g_HashGridCache_VisibilityCellBuffer[DispatchID];
                    uint4 quantized_radiance = HashGridCache_QuantizeRadiance(previous_lighting);
#ifdef ENABLE_INDIRECT
                    float4 RayRadianceInvPdf    = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[query_index]);
                    RayRadianceInvPdf.xyz      += previous_lighting;
                    g_RWUpdateRayRadianceInvPdfBuffer[query_index] = PackFp16x4Safe(RayRadianceInvPdf);
#endif // ENABLE_INDIRECT
                    if (dot(previous_lighting, previous_lighting) > 0.0f)
                    {
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0], quantized_radiance.x);
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1], quantized_radiance.y);
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2], quantized_radiance.z);
                    }
                    InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3], quantized_radiance.w);

                    return; // we can skip the shadow ray for this sample :)
                }
            }
        }
    }

    float3 view_direction = normalize(origin - world);

    // Sample new lights
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 1.5f);
    MaterialEvaluated material2 = MakeMaterialEvaluated(material, mesh_uv);
    MaterialBRDF materialBRDF = MakeMaterialBRDF(material2);
    // Make the seed different from the one used in TraceUpdateRays
    Random random = MakeRandom(DispatchID ^ 0x8a197727, g_FrameSeed);
    LightSampler lightSampler = MakeLightSampler(random);
    Reservoir reservoir = lightSampler.sampleLightListCone<kReservoir_SampleCount>(world, normal, view_direction, solid_angle, materialBRDF);

    if (!reservoir.isValid())
    {
        return;
    }

    // Append our resampled shadow ray, generate a ray index for later tracing and updates
    uint ray_index;
    InterlockedAdd(g_HashGridCache_VisibilityRayCountBuffer[0], 1, ray_index);

    g_HashGridCache_VisibilityRayBuffer[ray_index] = DispatchID;   // compact the surviving shadow rays

    // Here, we check that the ray has traversed at least a full hash cell
    // before hitting something.
    // If it hasn't, we bypass the filtering from the cache (although we
    // still accumulate the contribution into the cell).
    //
    // This avoids possible light leaks in the following configuration:
    //
    //    bright area   +--------------+
    //                  |    dark area |
    //                  | |            |
    //                  | x            |
    //                  |/|            |
    //                 /|\             |
    //                / | eye          |
    // bright radiance  +--------------+
    //
    // Here the point 'x' is reached after bouncing from the first vertex.
    // (i.e., it is a 2nd vertex, the ones filtered through the hash grid)
    // Because it is close to the wall and has a similar direction to the
    // 'bright radiance' event, both vertices will share the same hash cell
    // leading to a light leak on the bounced lighting from the inner wall.
    //
    // Such a scenario mostly occurs if the length of the ray connecting
    // the 2nd vertex is less than the size of the hash cell being used.
    // So, we detect this case and flag a bypass of the filtered readback.
    float cell_size  = HashGridCache_GetCellSize(world);
    float ray_length = distance(origin, world);

    if (ray_length < cell_size)
    {
        g_HashGridCache_VisibilityRayBuffer[ray_index] |= 0x80000000u;
    }

    // Insert the reservoir into the hash table
#ifdef USE_RESAMPLING
    float3 b1, b2;
    GetOrthoVectors(normal, b1, b2);
    float2 jitter = 2.0f * random.rand2() - 1.0f;
    jitter *= Reservoir_GetCellSize(world) * kReservoir_SpatialJitter;
    Reservoir_InsertEntry(ray_index, world + jitter.x * b1 + jitter.y * b2);

    g_Reservoir_IndirectSampleBuffer[ray_index]       = Reservoir_PackIndirectSample(origin, world);
    g_Reservoir_IndirectSampleNormalBuffer[ray_index] = packNormal(normal);
#endif // USE_RESAMPLING

    // Write the results out to memory
    g_Reservoir_IndirectSampleMaterialBuffer[ray_index]  = packMaterial(material2);  // cannot afford to re-fetch the full material each time, so we need to approximate it...
    g_Reservoir_IndirectSampleReservoirBuffer[ray_index] = packReservoir(reservoir);
}


[numthreads(WAVE_SIZE, 1, 1)]
void CompactReservoirs(in uint did : SV_DispatchThreadID)
{
    if (did >= g_Reservoir_HashListCountBuffer[0])
    {
        return; // out of bounds
    }

    uint4 list_element = g_Reservoir_HashListBuffer[did];
    uint  value_index  = g_Reservoir_HashIndexBuffer[list_element.y] + list_element.z;

    g_Reservoir_HashValueBuffer[value_index] = list_element.x;
}

// Temporal resampling only
[numthreads(WAVE_SIZE, 1, 1)]
void ResampleReservoirs(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    // Load our shading information
    float3 origin, world;
    Reservoir_UnpackIndirectSample(g_Reservoir_IndirectSampleBuffer[did], origin, world);

    float3       normal    = unpackNormal(g_Reservoir_IndirectSampleNormalBuffer[did]);
    MaterialBRDF material  = unpackMaterial(g_Reservoir_IndirectSampleMaterialBuffer[did]);
    Reservoir    reservoir = unpackReservoir(g_Reservoir_IndirectSampleReservoirBuffer[did]);

    // Normalize the sample count M (a.k.a. confidence weight) with the initial sample count for simplicity.
    reservoir.M = 1.0f;

    // Make the random numbers different from previous samples
    Random random = MakeRandom(did + MI.OutputDimensions.x * MI.OutputDimensions.y, g_FrameSeed);

    // Locate our hash table cell
    float3 b1, b2;
    GetOrthoVectors(normal, b1, b2);
    float2 jitter = 2.0f * random.rand2() - 1.0f;
    jitter *= Reservoir_GetCellSize(world) * kReservoir_SpatialJitter;
    uint entry_index = Reservoir_FindPreviousEntry(world + jitter.x * b1 + jitter.y * b2);

    if (entry_index == kGI10_InvalidId)
    {
        return; // no previous reservoir cell - temporal resampling failed :'(
    }

    uint index = g_Reservoir_PreviousHashIndexBuffer[entry_index];
    uint count = g_Reservoir_PreviousHashCountBuffer[entry_index];

    // Stochastically iterate the cell content
    uint max_count = 4;
    uint increment = (count + max_count - 1) / max_count;
    uint offset    = random.randInt(increment);

    // And combine the reservoirs
    float3 view_direction = normalize(origin - world);
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 12000.0f);
    ReservoirUpdater updater = MakeReservoirUpdater();
    mergeReservoirsCone(updater, reservoir, random, material, world, normal, view_direction, solid_angle);
    for (uint i = 0; i < count; i += increment)
    {
        // Load up the iterated reservoir
        uint      reservoir_index = g_Reservoir_PreviousHashValueBuffer[index + ((i + offset) % count)];
        Reservoir reservoir2      = unpackReservoir(g_Reservoir_PreviousIndirectSampleReservoirBuffer[reservoir_index]);
        float3    filter_normal   = unpackNormal(g_Reservoir_PreviousIndirectSampleNormalBuffer[reservoir_index]);

        if (!reservoir2.isValid())
        {
            continue;   // skip invalid reservoir(s)
        }

        // Bilaterally filter the neighbor reservoir
        float bilateral_weight = max(dot(normal, filter_normal), 0.0f);
        bilateral_weight = squared(squared(bilateral_weight)); // make it steep
        if (bilateral_weight < kReservoir_BilateralThreshold) continue;

        // And combine it with our current reservoir
        Reservoir_ClampPrevious(reservoir2);
        mergeReservoirsCone(updater, reservoir2, random, material, world, normal, view_direction, solid_angle);
    }

    if (!updater.reservoir.M)
    {
        return; // reprojection failed
    }

    // Finalize our reservoir
    reservoir = updater.reservoir;

    // And write it out to memory
    g_Reservoir_IndirectSampleReservoirBuffer[did] = packReservoir(reservoir);
}

void PopulateCellsHandleHit(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    payload.lighting    = float3(0.0f, 0.0f, 0.0f);

    Reservoir reservoir = payload.reservoir;
    // Update our reservoir cache for next frame's temporal resampling
#ifdef USE_RESAMPLING
    reservoir.W = 0.0f; // invalidate the reservoir

    g_Reservoir_IndirectSampleReservoirBuffer[did] = packReservoir(reservoir);
#endif // USE_RESAMPLING
}

void PopulateCellsHandleMiss(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    float3       light_radiance = payload.lighting;
    float        light_weight   = payload.reservoir.W;
    int2         ProbeIndex     = UnpackUint16x2(g_RWUpdateRayProbeBuffer[payload.query_index]);
    MaterialBRDF material       = unpackMaterial(g_Reservoir_IndirectSampleMaterialBuffer[did]);

    // Recover the ray origin
    float3       origin = GetScreenProbePosition(ProbeIndex);

    // And evaluate our lighting
    payload.lighting =
        evaluateBRDF(material, payload.normal, normalize(origin - payload.world), ray.Direction)
        * light_radiance * light_weight;
}

void PopulateCellsTraceRayInline(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    ShadowRayQuery ray_query = TraceRay<ShadowRayQuery>(ray);

    if (ray_query.CommittedStatus() == COMMITTED_NOTHING)
    {
        PopulateCellsHandleMiss(did, payload, ray);
    }
    else
    {
        PopulateCellsHandleHit(did, payload, ray);
    }
}

void PopulateCellsTraceRayRt(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    TraceRay(g_Scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH, 0xFFu, 0, 0, 0, ray, payload);
}

void PopulateCellsTraceRay(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
#if USE_INLINE_RT
    return PopulateCellsTraceRayInline(did, payload, ray);
#else
    return PopulateCellsTraceRayRt(did, payload, ray);
#endif
}

// Light sampling completed, actually trace a shadow ray for each hash grid cache query.
void PopulateCells(uint did)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    uint                     visibility_index = (g_HashGridCache_VisibilityRayBuffer[did] & ~0x80000000u);
    HashGridCache_Visibility visibility       = HashGridCache_UnpackVisibility(g_HashGridCache_VisibilityBuffer[visibility_index]);

    uint query_index = g_HashGridCache_VisibilityQueryBuffer[visibility_index];

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[visibility.instance_index];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index + visibility.geometry_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    Triangle vertices = fetchVertices(mesh, visibility.primitive_index);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);
    float3 world = interpolate(vertices.v0, vertices.v1, vertices.v2, visibility.barycentrics);
    float3 edge10 = vertices.v1 - vertices.v0;
    float3 edge20 = vertices.v2 - vertices.v0;
    float3 normal = normalize(transformNormal(cross(edge10, edge20) * (visibility.is_front_face ? 1.0f : -1.0f), transform));

    // Retrieve the light sample that we should use for our shadow ray
    Reservoir reservoir    = unpackReservoir(g_Reservoir_IndirectSampleReservoirBuffer[did]);

    // Decode the light sample from our reservoir
    float3 direction, light_position;
    // Approximate visible light surface based on number of samples being used
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 12000.0f);
    Light selected_light = getLight(reservoir.lightSample.index);
    float3 light_radiance = evaluateLightConeSampled(selected_light, world, reservoir.lightSample.sampleParams, solid_angle, direction, light_position);

    // Traverse the BVH
    RayDesc ray_desc;
    ray_desc.Direction = direction;
    ray_desc.Origin    = offsetPosition(world, normal);
    ray_desc.TMin      = 0.0f;
    ray_desc.TMax      = hasLightPosition(selected_light) ? length(light_position - ray_desc.Origin) : FLT_MAX;

    PopulateCellsPayload payload;
    payload.query_index = query_index;
    payload.world       = world;
    payload.normal      = normal;
    payload.lighting    = light_radiance;
    payload.reservoir   = reservoir;
    PopulateCellsTraceRay(did, payload, ray_desc);

    // And update the hash-grid cell payload
    uint  cell_index         = g_HashGridCache_VisibilityCellBuffer[visibility_index];
    uint4 quantized_radiance = HashGridCache_QuantizeRadiance(payload.lighting);

    if (dot(payload.lighting, payload.lighting) > 0.0f)
    {
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0], quantized_radiance.x);
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1], quantized_radiance.y);
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2], quantized_radiance.z);
    }
    InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3], quantized_radiance.w);

    // In some cases, we want to bypass the cache to avoid light leaks;
    // so we simply patch the screen probes directly and invalidate the
    // cache connection.
    bool is_bypass_cache = ((g_HashGridCache_VisibilityRayBuffer[did] >> 31) != 0);

    if (is_bypass_cache)
    {
        float4 RadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[query_index]);
        RadianceInvPdf.xyz   += payload.lighting;
        g_RWUpdateRayRadianceInvPdfBuffer[query_index] = PackFp16x4Safe(RadianceInvPdf);
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void PopulateCellsMain(in uint did : SV_DispatchThreadID)
{
    PopulateCells(did);
}

// BE CAREFUL: we assume
//             UPDATE_TILES_NOT_SLICED_GROUP_* >= g_HashGridCacheConstants.size_tile_mip0
//             UPDATE_TILES_NOT_SLICED_GROUP_*  % g_HashGridCacheConstants.size_tile_mip0 == 0
//
#define UPDATE_TILES_GROUP_X 8
#define UPDATE_TILES_GROUP_Y 8
#define UPDATE_TILES_GROUP_SIZE (UPDATE_TILES_GROUP_X * UPDATE_TILES_GROUP_Y)

groupshared uint2 lds_UpdateTiles_ValueBuffer[UPDATE_TILES_GROUP_X][UPDATE_TILES_GROUP_Y];

[numthreads(1, 1, 1)]
void GenerateUpdateTilesDispatch()
{
    uint num_tiles_by_group = UPDATE_TILES_GROUP_SIZE / g_HashGridCacheConstants.num_cells_per_tile_mip0;

    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = (g_HashGridCache_UpdateTileCountBuffer[0] + num_tiles_by_group - 1) / num_tiles_by_group;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

[numthreads(UPDATE_TILES_GROUP_X, UPDATE_TILES_GROUP_Y, 1)]
void UpdateTiles(in uint group_id : SV_GroupID, in uint2 group_thread_id : SV_GroupThreadID)
{
    // A group cover from 1 tile/subgroup (8x8) to 64 tiles/subgroups (1x1)
    uint2 subgroup_id        = group_thread_id / g_HashGridCacheConstants.size_tile_mip0;
    uint2 subgroup_thread_id = group_thread_id % g_HashGridCacheConstants.size_tile_mip0;
    uint2 subgroup_size      = uint2(UPDATE_TILES_GROUP_X, UPDATE_TILES_GROUP_Y) / g_HashGridCacheConstants.size_tile_mip0;
    uint  update_tile_index  = group_id * subgroup_size.x * subgroup_size.y +
                               subgroup_id.y * subgroup_size.x +
                               subgroup_id.x;

    if (update_tile_index >= g_HashGridCache_UpdateTileCountBuffer[0])
    {
        return;
    }

    uint tile_index = g_HashGridCache_UpdateTileBuffer[update_tile_index];

    // MIP 0
    {
        uint cell_index  = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 0);

        // Temporal accumulation
        float4 radiance     = HashGridCache_UnpackRadiance(g_HashGridCache_ValueBuffer[cell_index]);
        float4 new_radiance = HashGridCache_RecoverRadiance(uint4(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3]));

        float sample_count = min(radiance.w + new_radiance.w, g_HashGridCacheConstants.max_sample_count);

        radiance     /= max(radiance.w, 1.0f);
        new_radiance /= max(new_radiance.w, 1.0f);

        if (radiance.w <= 0.0f)
        {
            radiance = new_radiance;
        }
        else
        {
            radiance = lerp(radiance, new_radiance, 1.0f / sample_count);
        }

        radiance *= sample_count;   // sample count is used as a hint for picking prefiltering amount

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;

        // Clear scratch
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3] = 0;
    }

    // MIP 1
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip1 > 0 && all((group_thread_id % 2) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 1);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance10 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 1][group_thread_id.y + 0];
        uint2 packed_radiance01 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 1];
        uint2 packed_radiance11 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 1][group_thread_id.y + 1];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance10);
        radiance += HashGridCache_UnpackRadiance(packed_radiance01);
        radiance += HashGridCache_UnpackRadiance(packed_radiance11);

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;
    }

    // MIP 2
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip2 > 0 && all((group_thread_id % 4) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 2);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance20 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 2][group_thread_id.y + 0];
        uint2 packed_radiance02 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 2];
        uint2 packed_radiance22 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 2][group_thread_id.y + 2];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance20);
        radiance += HashGridCache_UnpackRadiance(packed_radiance02);
        radiance += HashGridCache_UnpackRadiance(packed_radiance22);

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;
    }

    // MIP 3
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip3 > 0 && all((group_thread_id % 8) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 3);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance40 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 4][group_thread_id.y + 0];
        uint2 packed_radiance04 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 4];
        uint2 packed_radiance44 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 4][group_thread_id.y + 4];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance40);
        radiance += HashGridCache_UnpackRadiance(packed_radiance04);
        radiance += HashGridCache_UnpackRadiance(packed_radiance44);

        // Pack
        g_HashGridCache_ValueBuffer[cell_index] = HashGridCache_PackRadiance(radiance);
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void ResolveCells(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    uint visibility_index = g_HashGridCache_VisibilityRayBuffer[did];

    if ((visibility_index >> 31) != 0)
    {
        return; // do not use filtered radiance
    }

    uint cell_index  = g_HashGridCache_VisibilityCellBuffer[visibility_index];
    uint query_index = g_HashGridCache_VisibilityQueryBuffer[visibility_index];

    float4 radiance = HashGridCache_FilteredRadiance(cell_index, false);

#ifdef ENABLE_INDIRECT
    float4 RadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[query_index]);
    RadianceInvPdf.xyz   += GIDenoiser_RemoveNaNs(radiance.xyz / max(radiance.w, 1.0f));
    g_RWUpdateRayRadianceInvPdfBuffer[query_index] = PackFp16x4Safe(RadianceInvPdf);
#endif
}


// Update the probe cache
float3 LocalEvaluatedRadiance[SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE];
float3 LocalDColorPrefixSum[WAVE_SIZE];
float3 LocalDDirectionPrefixSum[WAVE_SIZE];
float3 LocalDLambdaPrefixSum[WAVE_SIZE];

float  LocalSampleWeightPrefixSum[WAVE_SIZE];
float  LocalDirectionWeightPrefixSum[WAVE_SIZE];
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_UpdateProbes (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {
    int2 ProbeIndex = int2(GroupID % MI.TileDimensions.x, GroupID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    int  BasisCount = GetProbeBasisCountFromClass(Header.Class);
    int  ProbeRayCount   = g_RWProbeUpdateRayCountBuffer[GroupID];
    int  ProbeRayOffset  = g_RWProbeUpdateRayOffsetBuffer[GroupID];
    float3 ProbeIrradiance = g_RWProbeIrradianceTexture[ProbeIndex];
    
    if(LocalID < BasisCount) {
        LocalSGData[LocalID] = FetchBasisData(Header.BasisOffset + LocalID);
    }
    GroupMemoryBarrierWithGroupSync();

    float  SumSampleWeight = 0.f;
    float3 SumWeightedDiffRadiance = 0.f.xxx;
    float3 SumWeightedRadiance = 0.f.xxx;
#if SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE % WAVE_SIZE != 0
#error "SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE must be a multiple of WAVE_SIZE"
#endif
    [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
    for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
        int RayRank  = RayRankBase + LocalID;
        int RayIndex = ProbeRayOffset + RayRank;
        float3 RayDirection = OctahedronToUnitVector(unpackUnorm2x16(g_RWUpdateRayDirectionBuffer[RayIndex]) * 2 - 1);
        float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
        float3 RayRadiance       = RayRadianceInvPdf.xyz;
        float  InvPdf            = RayRadianceInvPdf.w;
        if(InvPdf > 0) {
            float3 EvaluatedRadiance = 0.f.xxx;
            [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE)]
            for(int i = 0; i < BasisCount; i++)
                EvaluatedRadiance += EvaluateSG(LocalSGData[i], RayDirection);
            LocalEvaluatedRadiance[RayRank] = EvaluatedRadiance + ProbeIrradiance;
            SumSampleWeight += InvPdf;
            SumWeightedDiffRadiance += InvPdf * (RayRadiance - (EvaluatedRadiance + ProbeIrradiance));
            SumWeightedRadiance += InvPdf * RayRadiance;
        }
    }
    SumSampleWeight         = WaveActiveSum(SumSampleWeight);
    SumWeightedDiffRadiance = WaveActiveSum(SumWeightedDiffRadiance);
    SumWeightedRadiance     = WaveActiveSum(SumWeightedRadiance);
    GroupMemoryBarrierWithGroupSync();

    // The chosen thread to update the irradiance
    if(WaveIsFirstLane()) {
        float3 NewProbeIrradiance = lerp(ProbeIrradiance, SumWeightedRadiance, );
        g_RWProbeIrradianceTexture[ProbeIndex] = NewProbeIrradiance;
    }

    int ThreadPerBasis = WAVE_SIZE / BasisCount;
    int BasisRank      = LocalID / ThreadPerBasis;
    int BasisThread    = LocalID % ThreadPerBasis;
    SGData SG = LocalSGData[BasisRank];
    SGGradients SumStepSize = (SGGradients)0;

    if(BasisRank < BasisCount) {
        
        // TODO classifying update ray count & basis count into different levels running different kernels,
        // so we can completely unroll the loops
        [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
        for(int RayGroupOffset = 0; RayGroupOffset < ProbeRayCount; RayGroupOffset += ThreadPerBasis) {
            int RayRank = RayGroupOffset + BasisThread;
            if(RayRank < ProbeRayCount) {
                int RayIndex = ProbeRayOffset + RayRank;
                float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
                float  RayLinearDepth    = g_RWUpdateRayLinearDepthBuffer[RayIndex];
                float3 RayDirection      = OctahedronToUnitVector(unpackUnorm2x16(g_RWUpdateRayDirectionBuffer[RayIndex]) * 2 - 1);
                float3 RayRadiance       = RayRadianceInvPdf.xyz;
                float  InvPdf            = RayRadianceInvPdf.w;
                if(InvPdf > 0) {
                    float3 SGEvaluatedRaw    = EvaluateSGRaw(SG, RayDirection);
                    float3 SGEvaluatedRadiance = SGEvaluatedRaw * SG.Color;

                    float3 dColorExtra;
                    SGGradients Gradients;
                    EvaluateSG_Gradients(SG, RayDirection, Gradients, dColorExtra);
                    float3 DiffRadiance   = RayRadiance - LocalEvaluatedRadiance[RayRank];
                    float3 TargetRadiance = DiffRadiance + SGEvaluatedRadiance;
                    float3 X = -2.f * DiffRadiance;
                    float  Y = dot(X, 1.f.xxx);

                    // The weight for balancing sample distribution
                    float  SampleWeight     = InvPdf;
#ifndef OPTIMAL_COLOR_UPDATE
                    SumStepSize.dColor     -= X * Gradients.dColor     * SampleWeight;
#else
                    SumStepSize.dColor     += TargetRadiance * SGEvaluatedRaw * SampleWeight;
#endif
                    
#ifndef HEURISTIC_DIRECTION_UPDATE
                    SumStepSize.dDirection -= Y * Gradients.dDirection * SampleWeight;
#else
                    float  TargetRadianceWeight = dot(TargetRadiance, TargetRadiance);
                    SumStepSize.dDirection += RayDirection * TargetRadianceWeight * SampleWeight;
#endif
                    SumStepSize.dLambda    -= Y * Gradients.dLambda    * SampleWeight;
                }
            }
        }
        // Accumulate weights
        LocalDColorPrefixSum[LocalID]     = WavePrefixSum(SumStepSize.dColor);
        LocalDDirectionPrefixSum[LocalID] = WavePrefixSum(SumStepSize.dDirection);
        LocalDLambdaPrefixSum[LocalID]    = WavePrefixSum(SumStepSize.dLambda);
#ifdef HEURISTIC_DIRECTION_UPDATE
        LocalDirectionWeightPrefixSum[LocalID] = WavePrefixSum(SumDirectionWeight);
#endif
        GroupMemoryBarrierWithGroupSync();
        // The chosen thread for updating each basis
        if(BasisThread == ThreadPerBasis - 1) {
            // Accumulate and normalize
            SumStepSize.dColor     += LocalDColorPrefixSum[LocalID] - LocalDColorPrefixSum[LocalID - ThreadPerBasis];
            SumStepSize.dDirection += LocalDDirectionPrefixSum[LocalID] - LocalDDirectionPrefixSum[LocalID - ThreadPerBasis];
            SumStepSize.dLambda    += LocalDLambdaPrefixSum[LocalID] - LocalDLambdaPrefixSum[LocalID - ThreadPerBasis];
#ifdef OPTIMAL_COLOR_UPDATE
            SumStepSize.dColor     /= SumSampleWeight;
#endif
#ifdef HEURISTIC_DIRECTION_UPDATE
            SumStepSize.dDirection /= SumSampleWeight;
#endif

            // Update the basis
            // FIXME pick the right normalization factor
            float3 NormalizationFactors = 1.f.xxx;
            if(MI.CacheUpdate_SGColor) {
#ifdef OPTIMAL_COLOR_UPDATE
                SG.Color = lerp(SG.Color, SumStepSize.dColor, MI.CacheUpdateLearningRate);
#else
                SG.Color += SumStepSize.dColor     * MI.CacheUpdateLearningRate * NormalizationFactors.x;
#endif
                SG.Color = max(SG.Color, 0.001f.xxx); // Color is in [0.001, inf)
            }
            if(MI.CacheUpdate_SGDirection) {
#ifndef HEURISTIC_DIRECTION_UPDATE
                // Prevent violent directional flipping across frames by orthogonalizing the delta direction
                float3 Ortho  = SumStepSize.dDirection - dot(SumStepSize.dDirection, SG.Direction) * SG.Direction;
                SG.Direction += Ortho * MI.CacheUpdateLearningRate * NormalizationFactors.y;
                SG.Direction  = normalize(SG.Direction);
#else 
                // Heuristic direction update
                float DstFactor = MI.CacheUpdateLearningRate;
                // Larger SG is harder to shift direction
                float SrcFactor = SGIntegrate(SG.Lambda) * dot(SG.Color, 1.f.xxx);
                SG.Direction = SG.Direction * SrcFactor + SumStepSize.dDirection * DstFactor;
                SG.Direction = normalize(SG.Direction);
#endif
            }
            if(MI.CacheUpdate_SGLambda) {
                SG.Lambda    += SumStepSize.dLambda    * MI.CacheUpdateLearningRate * NormalizationFactors.z;
                SG.Lambda    = clamp(SG.Lambda, 0.8f, 100.f); // Lambda is in [0.8f, 100.f]
            }
        }
    }
}


[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_IntegrateASG (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * MI.TileDimensions.x;
    int2 TileTextureBaseOffset = int2(GroupID) * SSRC_TILE_SIZE;
    const int PIXEL_PER_THREAD = SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE;
    for(int i = 0; i< PIXEL_PER_THREAD; i++) {
        int PixelIndex = i * WAVE_SIZE + LocalID;
        // Operate in subtiles (8x8) to get better coherency in loop branching
        // with the more likely the same number of basis to access for each thread
        int SubtileIndex  = PixelIndex / (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int SubPixelIndex = PixelIndex % (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int PixelX = (SSRC_TILE_SIZE/2) * (SubtileIndex % 2) + SubPixelIndex % (SSRC_TILE_SIZE/2);
        int PixelY = (SSRC_TILE_SIZE/2) * (SubtileIndex / 2) + SubPixelIndex / (SSRC_TILE_SIZE/2);
        int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
        float2 UV = (TexCoords + 0.5f) / MI.ScreenDimensions;
        float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
        if(Depth < 1.f) {
            float LinearDepth   = GetLinearDepth(Depth);
            // Texture coordinates
            float4 Visibility   = g_VisibilityTexture[TexCoords];
            float2 Barycentrics = Visibility.xy;
            uint   InstanceID   = asuint(Visibility.z);
            uint   PrimitiveID  = asuint(Visibility.w);

            Instance InstanceData = g_InstanceBuffer[InstanceID];
            Mesh     mesh     = g_MeshBuffer[InstanceData.mesh_index];

            Triangle vertices = fetchVertices(mesh, PrimitiveID);

            // Reconstruct world space position from barycentrics
            float3x4 transform = g_TransformBuffer[InstanceData.transform_index];
            vertices.v0 = transformPoint(vertices.v0, transform);
            vertices.v1 = transformPoint(vertices.v1, transform);
            vertices.v2 = transformPoint(vertices.v2, transform);

            // Frame
            float3 WorldPosition = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);
            float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
            float3 ShadingNormal  = normalize(2.f * g_ShadingNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);

            UVs PrimitiveUVs = fetchUVs(g_MeshBuffer[InstanceData.mesh_index], PrimitiveID);
            float2 MeshUV = interpolate(PrimitiveUVs.uv0, PrimitiveUVs.uv1, PrimitiveUVs.uv2, Barycentrics);
            Material MaterialData = g_MaterialBuffer[InstanceData.material_index];
            MaterialEmissive EmissiveMaterialData = MakeMaterialEmissive(MaterialData, MeshUV);
            MaterialBRDF MaterialBRDFData = MakeMaterialBRDF(MaterialData, MeshUV);
            
            float3 ViewDirection = normalize(MI.CameraPosition - WorldPosition);
            float DotNV = saturate(dot(ShadingNormal, ViewDirection));

            SSRC_SampleData Sample;
            CalculateSSRCSampleWeights(
                TexCoords,
                WorldPosition,
                LinearDepth, 
                GeometryNormal,
                Sample
            );
            ProbeHeader Headers[4];
            Headers[0] = GetScreenProbeHeader(Sample.Index[0]);
            Headers[1] = GetScreenProbeHeader(Sample.Index[1]);
            Headers[2] = GetScreenProbeHeader(Sample.Index[2]);
            Headers[3] = GetScreenProbeHeader(Sample.Index[3]);
            int BasisCounts[4];
            BasisCounts[0] = GetProbeBasisCountFromClass(Headers[0].Class);
            BasisCounts[1] = GetProbeBasisCountFromClass(Headers[1].Class);
            BasisCounts[2] = GetProbeBasisCountFromClass(Headers[2].Class);
            BasisCounts[3] = GetProbeBasisCountFromClass(Headers[3].Class);
            int BasisCount0 = BasisCounts[0] + BasisCounts[1];
            int BasisCount1 = BasisCounts[2] + BasisCounts[3];
            int BasisCount  = BasisCount0 + BasisCount1;

            float3 SumRadiance = 0.f.xxx;

            [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
            for(int BasisRank = 0; BasisRank < BasisCount; BasisRank++) {
                int ProbeRank, ProbeBasisIndex;
                if(BasisRank < BasisCount0) {
                    ProbeRank = BasisRank < BasisCounts[0] ? 0 : 1;
                    ProbeBasisIndex = BasisRank - (BasisRank < BasisCounts[0] ? 0 : BasisCounts[0]);
                } else {
                    ProbeRank = BasisRank < BasisCounts[2] ? 2 : 3;
                    ProbeBasisIndex = BasisRank - (BasisRank < BasisCounts[2] ? 2 : BasisCounts[2]);
                }
                int BasisIndex = Headers[ProbeRank].BasisOffset + ProbeBasisIndex;
                SGData SG = FetchBasisData(BasisIndex);
                float3 LightDirection = SG.Direction;
                float3 ReflectionDirection = calculateGGXSpecularDirection(ShadingNormal, ViewDirection, sqrt(MaterialBRDFData.roughnessAlpha));
                float3 HalfVector = normalize(LightDirection + ViewDirection);
                float3 HalfVector_Spec = normalize(ReflectionDirection + ViewDirection);
                float dotNL = saturate(dot(LightDirection, ShadingNormal));
                float dotNV = saturate(dot(ShadingNormal, ViewDirection));
                float dotHV = saturate(dot(HalfVector, ViewDirection));
                float dotSpecHV = saturate(dot(HalfVector_Spec, ViewDirection));
                // Approximate \int D * Li with ASG
                // we use RoughnessAlpha here
                float3 GGX_D_Li_Approx = SpecularTermASGWarp(SG, ShadingNormal, MaterialBRDFData.roughnessAlphaSqr, ViewDirection);
                float3 FresnelTerm = fresnel(MaterialBRDFData.F0, dotHV);
                float  VisibilityTerm   = evaluateVisibilityGGX(MaterialBRDFData.roughnessAlphaSqr, dotNL, dotNV);
                float3 GGXIntegrationApprox = (FresnelTerm / VisibilityTerm) * GGX_D_Li_Approx;
                float3 DiffuseCompensation = diffuseCompensationTerm(FresnelTerm, dotSpecHV);
                float3 LambertIntegration = SGDiffuseInnerProduct(SG, ShadingNormal, MaterialBRDFData.albedo)* DiffuseCompensation;
                SumRadiance += (GGXIntegrationApprox + LambertIntegration) * Sample.Weights[ProbeRank];
            }
            // Store shading results
            float3 Emission = EmissiveMaterialData.emissive;
            g_RWGlobalIlluminationOutput[TexCoords] = 
                float4(SumRadiance + Emission, 1.0f);
        } else {
            g_RWGlobalIlluminationOutput[TexCoords] = float4(0.f, 0.f, 0.f, 1.0f);
        }
    }
}

// [numthreads(WAVE_SIZE, 1, 1)]
// void SSRC_AccumulateUpdateError (int DispatchID : SV_DispatchThreadID) {
//     // >= 96 registers for each thread (meanwhile < 128)
//     // anyway that's not big deal
//     float ThreadErrorAccumulation[SSRC_TILE_SIZE][SSRC_TILE_SIZE];
//     float ThreadErrorAccumulationWeight[SSRC_TILE_SIZE][SSRC_TILE_SIZE];
//     for(int i = 0; i<SSRC_TILE_SIZE; i++) 
//         for(int j = 0; j<SSRC_TILE_SIZE; j++) {
//             ThreadErrorAccumulation[i][j] = 0;
//         }
//     for(int i = 0; i<SSRC_TILE_SIZE; i++) 
//         for(int j = 0; j<SSRC_TILE_SIZE; j++) {
//             ThreadErrorAccumulationWeight[i][j] = 0;
//         }
//     int2 TileCoords = int2(DispatchID % g_TileDimensions.x, DispatchID / g_TileDimensions.x);
//     int2 TexOffset = TileCoords * SSRC_TILE_SIZE;
//     int TileID = DispatchID;
//     int TileRayCount = g_RWTileRayCountBuffer[TileID];
//     int TileRayOffset = g_RWTileRayOffsetBuffer[TileID];
//     for(int TileRayRank = 0; TileRayRank < TileRayCount; TileRayRank++) {
//         int RayIndex = TileRayOffset + TileRayRank;
//         int2 TexCoords  = UnpackUint16x2(g_RWUpdateRayOriginBuffer[RayIndex]);
//         float4 RadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
//         if(RadianceInvPdf.w > 0) {
//             float3 Error    = RadianceInvPdf.xyz;
//             float  InvPdf   = RadianceInvPdf.w;

//             float  Contrib  = (dot(Error, Error) ) * InvPdf;

//             // Accumulate the error
//             int2  PixelCoords = TexCoords - TexOffset;
//             ThreadErrorAccumulation[PixelCoords.y][PixelCoords.x] += Contrib;
//             ThreadErrorAccumulationWeight[PixelCoords.y][PixelCoords.x] += InvPdf;
//         }
//     }
//     for(int j = 0; j<SSRC_TILE_SIZE; j++) {
//         for(int i = 0; i<SSRC_TILE_SIZE; i++) {
//             int2 TexCoords = TexOffset + int2(i, j);
//             float Error  = ThreadErrorAccumulation[j][i];
//             float Weight = ThreadErrorAccumulationWeight[j][i];
//             float PrevError = g_RWUpdateErrorSplatTexture[TexCoords];
//             if(Weight > 0) {
//                 g_RWUpdateErrorSplatTexture[TexCoords] = lerp(PrevError, Error / Weight, 0.005f);
//             } else {
//                 g_RWUpdateErrorSplatTexture[TexCoords] = lerp(PrevError, 0.f,  0.005f);
//             }
//         }
//     }
// }

// [numthreads(8, 8, 1)]
// void DebugSSRC_ShowDifference (uint2 DispatchID : SV_DispatchThreadID) {
//     if(any(DispatchID >= MI.OutputDimensions)) {
//         return;
//     }
//     if(g_DebugVisualizeMode == 0) {
//         float Depth = g_DepthTexture.Load(int3(DispatchID, 0)).x;
//         if(Depth < 1.f) {
//             float2 UV = (DispatchID + 0.5f.xx) / MI.OutputDimensions;
//             float Difference = g_UpdateErrorSplatTexture.SampleLevel(g_LinearSampler, UV, ERROR_BLUR_LOD).x;
//             g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(Difference * g_DebugTonemapExposure), 1.f);
//         } else {
//             g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
//         }
//     } else if(g_DebugVisualizeMode == 1) {
//         int2 TileCoords = DispatchID / SSRC_TILE_SIZE;
//         int TileID = TileCoords.x + TileCoords.y * g_TileDimensions.x;
//         int TileRayCount = g_RWTileRayCountBuffer[TileID];
//         if(TileRayCount == 0) {
//             g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
//         } else {
//             g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(TileRayCount / 128.f), 1.f);
//         }
//     } else if(g_DebugVisualizeMode == 2) {
//         float Depth = g_DepthTexture.Load(int3(DispatchID, 0)).x;
//         if(Depth < 1.f) {
//             float Difference = g_UpdateErrorSplatTexture.Load(int3(DispatchID, 0)).x;
//             g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(Difference * g_DebugTonemapExposure), 1.f);
//         } else {
//             g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
//         }
//     }
// }

// ***********************************************
// *                 Misc                        *
// ***********************************************


// [numthreads(1, 1, 1)]
// void DebugSSRC_GenerateDrawIndexed (uint DispatchID : SV_DispatchThreadID) {
//     DrawIndexedCommand draw_command;
//     draw_command.index_count_per_instance = 3;
//     draw_command.instance_count  = g_RWActiveBasisCountBuffer[0];
//     draw_command.index_offset    = 0;
//     draw_command.vertex_offset   = 0;
//     draw_command.instance_offset = 0;
//     g_RWDrawIndexedCommandBuffer[0] = draw_command;
// }

[numthreads(1, 1, 1)]
void DebugSSRC_FetchCursorPos (uint DipspatchID : SV_DispatchThreadID) {
    float4 Visibility = g_VisibilityTexture.Load(int3(MI.DebugCursorPixelCoords, 0));
    float2 Barycentrics = Visibility.xy;
    uint InstanceID = asuint(Visibility.z);
    uint PrimitiveID = asuint(Visibility.w);
    Instance InstanceData = g_InstanceBuffer[InstanceID];
    Mesh mesh = g_MeshBuffer[InstanceData.mesh_index];
    Triangle vertices = fetchVertices(mesh, PrimitiveID);
    float3x4 transform = g_TransformBuffer[InstanceData.transform_index];
    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);
    float3 WorldPosition = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);
    g_RWDebugCursorWorldPosBuffer[0] = WorldPosition;
}

// [numthreads(WAVE_SIZE, 1, 1)]
// void DebugSSRC_PrecomputeIncidentRadiance (uint DispatchID : SV_DispatchThreadID) {
//     if(DispatchID >= MI.DebugVisualizeIncidentRadianceNumPoints) {
//         return;
//     }
//     if(DispatchID == 0) {
//         // 3 channel sum
//         g_RWReduceCountBuffer[0] = MI.DebugVisualizeIncidentRadianceNumPoints * 3;
//     }
//     float3 Direction      = FibonacciSphere(DispatchID, MI.DebugVisualizeIncidentRadianceNumPoints);
//     float3 DebugWorldPos  = g_RWDebugCursorWorldPosBuffer[0];
//     float3 Homogeneous    = transformPointProjection(DebugWorldPos, MI.CameraProjView);
//     float2 UV             = NDC22UV(Homogeneous.xy);
//     int2   TexCoords      = int2(UV * MI.ScreenDimensions);
//     int2   TileCoords     = int2(TexCoords.x / SSRC_TILE_SIZE, TexCoords.y / SSRC_TILE_SIZE);
//     int    TileID         = TileCoords.x + TileCoords.y * g_TileDimensions.x;
//     int    TileBasisCount = g_RWTileBasisCountBuffer[TileID];
//     int    TileBasisOffset= g_RWTileBaseSlotOffsetBuffer[TileID];
//     float3 SumRadiance = 0.f.xxx;
//     float  SumWeight   = 0.f;
//     for(int i = 0; i < TileBasisCount; i++) {
//         int BasisIndex = g_RWTileBasisIndexBuffer[TileBasisOffset + i];
//         SGData SG;
//         WData  W;
//         FetchBasisData_W(BasisIndex, SG, W);
//         float3 BasisWorldPosition;
//         FetchBasisLocation(BasisIndex, BasisWorldPosition);
//         float3 DeltaPosition = BasisWorldPosition - DebugWorldPos;
//         float  EvaluatedW    = EvaluateW(W, DeltaPosition);
//         float3 EvaluatedSG   = EvaluateSG(SG, Direction);
//         SumRadiance += EvaluatedSG * EvaluatedW;
//         SumWeight   += EvaluatedW;
//     }
//     if(SumWeight > 0) {
//         g_RWDebugVisualizeIncidentRadianceBuffer[DispatchID] = SumRadiance / SumWeight;
//     } else {
//         g_RWDebugVisualizeIncidentRadianceBuffer[DispatchID] = 0.f.xxx;
//     }
// }

[numthreads(1, 1, 1)]
void DebugSSRC_PrepareUpdateRays () {
    int2   TexCoords      = MI.DebugCursorPixelCoords;
    int2   TileCoords     = int2(TexCoords.x / SSRC_TILE_SIZE, TexCoords.y / SSRC_TILE_SIZE);
    int    TileID         = TileCoords.x + TileCoords.y * MI.TileDimensions.x;
    float  Depth          = g_DepthTexture.Load(int3(TexCoords, 0)).x;
    if(Depth < 1.f) {
        float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
        SSRC_SampleData Sample;
        CalculateSSRCSampleWeights(
            TexCoords,
            g_RWDebugCursorWorldPosBuffer[0],
            GetLinearDepth(Depth),
            GeometryNormal,
            Sample
        );
        int MinIndex;
        if(Sample.Weights[0] < Sample.Weights[1]) {
            MinIndex = 0;
        } else {
            MinIndex = 1;
        }
        if(Sample.Weights[2] < Sample.Weights[MinIndex]) {
            MinIndex = 2;
        }
        if(Sample.Weights[3] < Sample.Weights[MinIndex]) {
            MinIndex = 3;
        }
        int ProbeIndex = Sample.Index[MinIndex];
        int ProbeRayCount = g_RWProbeUpdateRayCountBuffer[ProbeIndex];
        DrawCommand draw_command = (DrawCommand)0;
        draw_command.vertex_count_per_instance = 2;
        draw_command.instance_count  = ProbeRayCount;
        draw_command.vertex_offset   = 0;
        draw_command.instance_offset = 0;
        g_RWDrawCommandBuffer[0] = draw_command;
    } else {
        DrawCommand draw_command = (DrawCommand)0;
        draw_command.vertex_count_per_instance = 0;
        draw_command.instance_count  = 0;
        draw_command.vertex_offset   = 0;
        draw_command.instance_offset = 0;
        g_RWDrawCommandBuffer[0] = draw_command;
    }
}



// New line required for termination.
