#ifndef USE_INLINE_RT
#define USE_INLINE_RT 1
#endif

#ifndef WAVE_SIZE
// NVIDIA's default warp size
#define WAVE_SIZE 32
#endif

#define MIN_COLOR 0.000001f

// Shared structs among CPU and GPU
#include "../../gpu_shared.h"

// Parameters & Globals & Helper functions
#include "migi_inc.hlsl"

// Library for MIGI
#include "migi_lib.hlsl"

// Hash grid cache library
#include "hash_grid_cache.hlsl"
// World space ReSTIR library
#include "world_space_restir.hlsl"

#define MAX_HIT_DISTANCE 1e9f

struct ScreenCacheUpdatePayload
{
    float3 sky_sample;
    float hit_dist;
};

struct PopulateCellsPayload
{
    uint      query_index;
    float3    world;
    float3    normal;
    float3    lighting;
    Reservoir reservoir;
};

struct TraceReflectionsPayload
{
    int2   full_pos;
    float3 radiance;
    float2 s;
    float  hit_distance;
};


// A naive kernel for generating dispatch commands
[numthreads(1, 1, 1)]
void GenerateDispatch()
{
    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = (g_CountBuffer[0] + g_GroupSize - 1) / g_GroupSize;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

[numthreads(1, 1, 1)]
void GenerateDispatchRays()
{
    DispatchRaysCommand dispatch_rays_command;
    dispatch_rays_command.ray_generation_shader_record = g_RTConstants.ray_generation_shader_record;
    dispatch_rays_command.miss_shader_table = g_RTConstants.miss_shader_table;
    dispatch_rays_command.hit_group_table = g_RTConstants.hit_group_table;
    dispatch_rays_command.callable_shader_table = g_RTConstants.callable_shader_table;
    dispatch_rays_command.width = g_CountBuffer[0];
    dispatch_rays_command.height = 1;
    dispatch_rays_command.depth = 1;
    dispatch_rays_command.padding[0] = 0;
    dispatch_rays_command.padding[1] = 0;
    dispatch_rays_command.padding[2] = 0;
    g_RWDispatchRaysCommandBuffer[0] = dispatch_rays_command;
}

[numthreads(64, 1, 1)]
void PurgeTiles(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_PreviousPackedTileCountBuffer[0])
    {
        return; // out of bounds
    }

    // We opt for calculating the decay of each tile from the
    // current frame index, as it saves many writes per frame
    // and is quite a bit faster than having to decrement all
    // cell's decay values.
    uint tile_index = g_HashGridCache_PreviousPackedTileIndexBuffer[did];
    uint tile_decay = g_HashGridCache_DecayTileBuffer[tile_index];

    if (g_FrameIndex < tile_decay)   // account for integer wraparound case
    {
        tile_decay = ((0xFFFFFFFFu - tile_decay) + g_FrameIndex + 1);
    }
    else
    {
        tile_decay = (g_FrameIndex - tile_decay);
    }

    if (tile_decay >= kHashGridCache_TileDecay)
    {
        g_HashGridCache_HashBuffer[tile_index] = 0;

#ifdef DEBUG_HASH_CELLS
        // Clear all mipmaps
        for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile; ++cell_offset)
        {
            uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
            g_HashGridCache_DecayCellBuffer[cell_index] = 0xFFFFFFFFu;
        }
#endif // DEBUG_HASH_CELLS

        return; // kill the tile
    }

    uint packed_tile_index;
    InterlockedAdd(g_HashGridCache_PackedTileCountBuffer[0], 1, packed_tile_index);
    g_HashGridCache_PackedTileIndexBuffer[packed_tile_index] = tile_index;
}

[numthreads(1, 1, 1)]
void ClearCounters()
{
    g_Reservoir_HashListCountBuffer[0] = 0; // reset counters

    g_HashGridCache_PackedTileCountBuffer[0]    = 0;
    g_HashGridCache_UpdateTileCountBuffer[0]    = 0;
    g_HashGridCache_VisibilityCountBuffer[0]    = 0;
    g_HashGridCache_VisibilityRayCountBuffer[0] = 0;
    
}

void ScreenCacheUpdateHandleHit(uint DispatchID, inout ScreenCacheUpdatePayload payload, RayDesc ray, HitInfo hit_info)
{
    HashGridCache_Data data;
    data.eye_position = g_CameraPosition;
    data.hit_position = ray.Origin + payload.hit_dist * ray.Direction;
    data.direction    = ray.Direction;
    data.hit_distance = payload.hit_dist;

    uint tile_index;
    bool is_new_tile;
    uint cell_index = HashGridCache_InsertCell(data, tile_index, is_new_tile);

    if (cell_index != kGI10_InvalidId)
    {
        // Bump the cell's decay to the max. now that it's been 'touched'
        uint previous_tile_decay;
        InterlockedExchange(g_HashGridCache_DecayTileBuffer[tile_index], g_FrameIndex, previous_tile_decay);

        HashGridCache_Visibility visibility;
        visibility.is_front_face   = hit_info.frontFace;
        visibility.instance_index  = hit_info.instanceIndex;
        visibility.geometry_index  = hit_info.geometryIndex;
        visibility.primitive_index = hit_info.primitiveIndex;
        visibility.barycentrics    = hit_info.barycentrics;

        // We update the cell index for later passes
        uint visibility_index;
        InterlockedAdd(g_HashGridCache_VisibilityCountBuffer[0], 1, visibility_index);
        g_HashGridCache_VisibilityBuffer[visibility_index]      = HashGridCache_PackVisibility(visibility);
        g_HashGridCache_VisibilityCellBuffer[visibility_index]  = cell_index;
        g_HashGridCache_VisibilityQueryBuffer[visibility_index] = DispatchID;

        // Write out bounds of visibility
        requestLightSampleLocation(data.hit_position);

        // If this cell is inside a new tile, we need to add the tile to the packed storage and clear its cells.
        if (is_new_tile)
        {
            uint packed_tile_index;
            InterlockedAdd(g_HashGridCache_PackedTileCountBuffer[0], 1, packed_tile_index);
            g_HashGridCache_PackedTileIndexBuffer[packed_tile_index] = tile_index;

            // Clear mip0 cells (others will be reset anyways by UpdateTiles)
            for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile_mip0; ++cell_offset)
            {
                uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
                g_HashGridCache_ValueBuffer[cell_index] = uint2(0, 0);
            }
        }

        // If we're the 1st invocation touching this cell (this frame), we want to clear the
        // scratch storage that'll be used for atomically updating the radiance.
        // The accumulation will be resolved in the 'UpdateTiles()' kernel to
        // avoid integer overflow.
        if (is_new_tile || previous_tile_decay != g_FrameIndex)
        {
            uint update_tile_index;
            InterlockedAdd(g_HashGridCache_UpdateTileCountBuffer[0], 1, update_tile_index);
            g_HashGridCache_UpdateTileBuffer[update_tile_index] = tile_index;
        }

#ifdef DEBUG_HASH_CELLS
        // For debugging purposes, we need to be able to retrieve the position
        // & orientation of cells as we iterate the content of the cache.
        // So, write the packed cell descriptor out to memory in this case.
        if (is_new_tile)
        {
            // Clear debug cells (all mips)
            for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile; ++cell_offset)
            {
                uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
                g_HashGridCache_DebugCellBuffer[cell_index] = HashGridCache_ClearDebugCell();
            }
        }

        float4 packed_debug_cell;
        uint debug_cell_index = HashGridCache_PackDebugCell(data, tile_index, packed_debug_cell);

        // BE CAREFUL: writing to g_HashGridCache_DebugCellBuffer isn't atomic and several writings could occur
        uint previous_cell_decay;
        InterlockedExchange(g_HashGridCache_DecayCellBuffer[debug_cell_index], g_FrameIndex, previous_cell_decay);
        if (previous_cell_decay != g_FrameIndex)
        {
            g_HashGridCache_DebugCellBuffer[debug_cell_index] = packed_debug_cell;
        }
#endif // DEBUG_HASH_CELLS
    }
}

void ScreenCacheUpdateHandleMiss(inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    payload.sky_sample = g_EnvironmentBuffer.SampleLevel(g_TextureSampler, ray.Direction, 0.0f).xyz;
}

void ScreenCacheUpdateTraceRayInline(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    ClosestRayQuery ray_query = TraceRay<ClosestRayQuery>(ray);

    // If we hit some geometry, we append a new world-space hash-grid cache query
    if (ray_query.CommittedStatus() == COMMITTED_NOTHING)
    {
        payload.hit_dist = ray_query.CommittedRayT();
        ScreenCacheUpdateHandleMiss(payload, ray);
    }
    else
    {
        payload.hit_dist = ray_query.CommittedRayT();
        ScreenCacheUpdateHandleHit(did, payload, ray, GetHitInfoRtInlineCommitted(ray_query));
    }
}

void ScreenCacheUpdateTraceRayRt(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    TraceRay(g_Scene, RAY_FLAG_NONE, 0xFFu, 0, 0, 0, ray, payload);
}

void ScreenCacheUpdateTraceRay(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
#if USE_INLINE_RT
    ScreenCacheUpdateTraceRayInline(did, payload, ray);
#else
    ScreenCacheUpdateTraceRayRt(did, payload, ray);
#endif
}


[numthreads(1, 1, 1)]
void SSRC_ClearActiveCounter() {
    g_RWActiveBasisCountBuffer[0] = 0;
}

// Reproject basis from previous frame, filter dead basis
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_ReprojectAndFilter (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= g_MaxBasisCount) {
        return;
    }
    uint Flags = g_RWBasisFlagsBuffer[DispatchID];
    // The basis has been inactive for at least 1 frame.
    // Omit it.
    if(g_FrameIndex - Flags > BASIS_RETIRE_FRAME_COUNT) {
        return ;
    }
    if(g_FreezeBasisAllocation) {
        // Refresh all basis every frame if the freezing mode is on
        g_RWBasisFlagsBuffer[DispatchID] = g_FrameIndex;
    }

    // Clear the step size for step accumulation
    ScreenCache_ResetStepSize(DispatchID);

    SGData SG;
    WData W;
    float3 BasisPosition;
    FetchBasisData_W(DispatchID, SG, W);
    FetchBasisLocation(DispatchID, BasisPosition);
    float3 CurrentHomogeneous = transformPointProjection(BasisPosition, g_CameraProjView);

    float2 CurrentUV = 0.5f * float2(CurrentHomogeneous.x, -CurrentHomogeneous.y) + 0.5f;
    float  CurrentDepth = CurrentHomogeneous.z;

    int ActiveFlag = 1;

    // The basis turns inactive this frame.
    if(g_FrameIndex - Flags == BASIS_RETIRE_FRAME_COUNT) {
        ActiveFlag = 0;
    }

    // Free the slot if reprojection failed
    if(any(CurrentUV < -0.01f) || any(CurrentUV > 1.01f) || CurrentDepth < 0.f || CurrentDepth >= 1.f) {
        ActiveFlag = 0;
    }
    
    float LinearDepth = dot(BasisPosition - g_CameraPosition, g_CameraDirection);
    float PixelDepth  = g_DepthTexture.SampleLevel(g_LinearSampler, CurrentUV, 0.0f).x;
    float LinearPixelDepth = GetLinearDepth(PixelDepth);
    
    // Malfunction with TAA
    // Remove the basis if the depth is not consistent
    // if(abs(LinearDepth - LinearPixelDepth) > 0.01f) {
    //     ActiveFlag = 0;
    // }
    
    float BasisEffectiveRadius = EvaluateW_EffectiveRadius(W, g_MinWeightE);
    // The basis is too small for injection, remove it right on the way
    if(BasisEffectiveRadius == 0) {
        ActiveFlag = 0;
    }

    if(ActiveFlag == 0 && !g_FreezeBasisAllocation) {
        uint Slot;
        InterlockedAdd(g_RWFreeBasisIndicesCountBuffer[0], 1, Slot);
        g_RWFreeBasisIndicesBuffer[Slot] = DispatchID;
        g_RWBasisFlagsBuffer[DispatchID] = g_FrameIndex - BASIS_RETIRE_FRAME_COUNT;
        return ;
    }

    // The basis is still active this frame.
    // Get ready for injection and later computation.
    int  Rank = WavePrefixCountBits(1);
    uint Sum  = WaveActiveSum(1);
    uint Offset;
    if(WaveIsFirstLane()) {
        InterlockedAdd(g_RWActiveBasisCountBuffer[0], Sum, Offset);
    }
    Offset = WaveReadLaneFirst(Offset);
    g_RWActiveBasisIndexBuffer[Offset + Rank] = DispatchID;

    // Cache per instance effective radius for later injection rasterization
    g_RWBasisEffectiveRadiusBuffer[DispatchID] = BasisEffectiveRadius;
    // Update the center projection for this basis
    // g_RWBasisFilmPositionBuffer[DispatchID] = packUnorm2x16(CurrentUV);
    // Update screen lambda parameter
    if(ActiveFlag) {
        float  BasisLinearDepth = dot(BasisPosition - g_CameraPosition, g_CameraDirection);
        float  BasisEffectiveRadiusFilm = BasisEffectiveRadius / (BasisLinearDepth * g_CameraPixelScale);
        g_RWBasisEffectiveRadiusFilmBuffer[DispatchID] = BasisEffectiveRadiusFilm;
    } else {
        // Make sure we do inject correctly when the basis is inactive under freeze mode
        g_RWBasisEffectiveRadiusFilmBuffer[DispatchID] = 0.1f;
    }
}


// HiZ required for injection culling
[numthreads(8, 8, 1)]
void PrecomputeHiZ (int2 DispatchID : SV_DispatchThreadID) {
    int2 Dimensions;
    g_RWHiZ_Out.GetDimensions(Dimensions.x, Dimensions.y);
    if(any(DispatchID >= Dimensions)) {
        return;
    }
    float X00 = g_RWHiZ_In[int2(2 * DispatchID.x + 0, 2 * DispatchID.y + 0)].x;
    float X01 = g_RWHiZ_In[int2(2 * DispatchID.x + 0, 2 * DispatchID.y + 1)].x;
    float X10 = g_RWHiZ_In[int2(2 * DispatchID.x + 1, 2 * DispatchID.y + 0)].x;
    float X11 = g_RWHiZ_In[int2(2 * DispatchID.x + 1, 2 * DispatchID.y + 1)].x;
#ifdef HIZ_MIN
    float X0 = min(X00, X01);
    float X1 = min(X10, X11);
    float X = min(X0, X1);
#else
    if(X00 == 1.f) X00 = 0.f;
    if(X01 == 1.f) X01 = 0.f;
    if(X10 == 1.f) X10 = 0.f;
    if(X11 == 1.f) X11 = 0.f;
    float X0 = max(X00, X01);
    float X1 = max(X10, X11);
    float X = max(X0, X1);
    if(X == 0.f) X = 1.f;
#endif
    g_RWHiZ_Out[DispatchID] = X;
}

// Clear tile injection index
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_ClearTileInjectionIndex (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    g_RWTileBasisCountBuffer[DispatchID] = 0;
}

// Generate draw command for injection
[numthreads(1, 1, 1)]
void SSRC_InjectGenerateDrawIndexed () {
    DrawIndexedCommand draw_command;
    draw_command.index_count_per_instance = 3 * (g_CR_DiskVertexCount - 2);
    draw_command.instance_count  = g_RWActiveBasisCountBuffer[0];
    draw_command.index_offset    = 0;
    draw_command.vertex_offset   = 0;
    draw_command.instance_offset = 0;
    g_RWDrawIndexedCommandBuffer[0] = draw_command;
}

// Inject reprojected basis to tile injection index
// Performed within the fragment shader with conservative rasterization
// InjectReprojectedBasis : TOPOLOGY_TRIANGLEFAN

// Clip overflowing tile index
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_ClipOverflowTileIndex (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID > g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    if(g_RWTileBasisCountBuffer[DispatchID] > SSRC_MAX_BASIS_PER_TILE) {
        g_RWTileBasisCountBuffer[DispatchID] = SSRC_MAX_BASIS_PER_TILE;
    }
}

// A scan sum is performed to accumulate g_RWTileBasisBaseOffsetBuffer

// Allocate one extra slot for each tile and accumulate it to the accumulated base basis index offset,
// which is used to store the newly allocated basis index this frame
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateExtraSlotForBasisGeneration (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    g_RWTileBaseSlotOffsetBuffer[DispatchID] = g_RWTileBaseSlotOffsetBuffer[DispatchID] + DispatchID;
}

// Compress the tile basis index
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_CompressTileBasisIndex (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    if(any(GroupID >= g_TileDimensions)) {
        return;
    }
    int TileID = GroupID.x + GroupID.y * g_TileDimensions.x;
    int UncompressedTileSlotOffset = TileID * SSRC_MAX_BASIS_PER_TILE;
    int CompressedTileSlotOffset   = g_RWTileBaseSlotOffsetBuffer[TileID];
    // Cooperatively fill the compressed index
    int Count = g_RWTileBasisCountBuffer[TileID];
    
    for(int TileSlotOffset = 0; TileSlotOffset < Count; TileSlotOffset += WAVE_SIZE) {
        int TileSlot = TileSlotOffset + LocalID;
        if(TileSlot < Count) {
            g_RWTileBasisIndexBuffer[CompressedTileSlotOffset + TileSlot] = 
                g_RWTileBasisIndexInjectionBuffer[UncompressedTileSlotOffset + TileSlot];
        }
    }
}

[numthreads(SSRC_TILE_SIZE, SSRC_TILE_SIZE, 1)]
void SSRC_ReprojectPreviousUpdateError (int2 DispatchID : SV_DispatchThreadID) {
    if(any(DispatchID >= g_OutputDimensions)) {
        return;
    }

    float3 NormalPrev = g_GeometryNormalTexture.Load(int3(DispatchID, 0)).xyz;
    bool   IsSkyPixel = (dot(NormalPrev, NormalPrev) == 0.0f ? true : false);

    if (IsSkyPixel)
    {
        g_RWUpdateErrorSplatTexture[DispatchID] = 0.f;
        return;
    }
    float3 Normal = normalize(2.f * NormalPrev - 1.f);

    // Reproject the update error texture from previous frame to current frame
    float4 packed_visibility = g_VisibilityTexture.Load(int3(DispatchID, 0));
    float2 Barycentrics      = packed_visibility.xy;
    int   InstanceIndex      = asint(packed_visibility.z);
    int   PrimitiveIndex      = asint(packed_visibility.w);

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[InstanceIndex];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    TriangleNormUV vertices = fetchVerticesNormUV(mesh, PrimitiveIndex);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);

    vertices.n0 = transformNormal(vertices.n0, transform);
    vertices.n1 = transformNormal(vertices.n1, transform);
    vertices.n2 = transformNormal(vertices.n2, transform);

    float3   world    = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);

    float3 homogeneous = transformPointProjection(world, g_CameraProjView);

    float2 UV          = 0.5f * float2(homogeneous.x, -homogeneous.y) + 0.5f;
    float  Depth       = homogeneous.z;

    // Severe (precision?) error here
    // float2 UV = (float2(DispatchID) + 0.5f) * g_OutputDimensionsInv;
    // float Depth = g_DepthTexture.Load(int3(UV, 0)).x;
    // float3 Normal = normalize(2.f * g_GeometryNormalTexture.Load(int3(UV, 0)).xyz - 1.f);
    // float3 homogeneous = float3(UV2NDC2(UV), Depth);

    if (all(UV > 0.0f) && all(UV < 1.0f) && Depth > 0.0f && Depth < 1.0f)
    {
        float2 previous_uv = UV - g_VelocityTexture.SampleLevel(g_NearestSampler, UV, 0.0f).xy;

        if (all(previous_uv > 0.0f) && all(previous_uv < 1.0f))
        {
            float3 homogeneous2 = transformPointProjection(homogeneous, g_Reprojection);
            homogeneous2.z      = GetLinearDepth(homogeneous2.z);

            float  previous_depth  = GetLinearDepth(g_PreviousDepthTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).x);
            float3 previous_normal = normalize(2.0f * g_PreviousGeometryNormalTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz - 1.0f);

            if (dot(previous_normal, Normal) > 0.5f && abs(previous_depth - homogeneous2.z) / homogeneous2.z < 5e-2f)
            {
                // Using linear sampler in reprojection can significantly increase the reprojected error, why?
                float PreviousError = g_PreviousUpdateErrorSplatTexture.SampleLevel(g_NearestSampler, previous_uv, 0).x;
                g_RWUpdateErrorSplatTexture[DispatchID] = PreviousError;
                return; 
            }
        }
    }
    
    // TODO allocate a initial weight for the update error
    // FIXME
    g_RWUpdateErrorSplatTexture[DispatchID] = 0.f;

}

// UpdateErrorSplatTexture is later mipmapped.

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_PrecomputeRayBudgetForTiles (int DispatchID : SV_DispatchThreadID, int GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int  TileID = DispatchID;
    if(TileID > g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    int2 TileCoords = int2(TileID % g_TileDimensions.x, TileID / g_TileDimensions.x);
    float TileAvgUpdateError = g_UpdateErrorSplatTexture.Load(int3(TileCoords, SSRC_TILE_SIZE_L2)).x;

    int   WaveActiveLaneCount       = WaveActiveSum(1);
    float WaveTileAvgUpdateErrorSum = WaveActiveSum(TileAvgUpdateError);
    if(LocalID == 0) {
        g_RWTileUpdateErrorSumsBuffer[GroupID] = WaveTileAvgUpdateErrorSum;
    }
}

[numthreads(1, 1, 1)]
void SSRC_TilesSetReduceCount32 () {
    g_RWReduceCountBuffer[0] = (g_TileDimensions.x * g_TileDimensions.y + WAVE_SIZE - 1) / WAVE_SIZE;
}

[numthreads(1, 1, 1)]
void SSRC_TilesSetReduceCount () {
    g_RWReduceCountBuffer[0] = g_TileDimensions.x * g_TileDimensions.y;
}

// A reduce sum is performed to accumulate g_RWTileUpdateErrorSumsBuffer into g_RWUpdateErrorBuffer

// Allocate update rays for each tile
// To achieve maximum parallelism, we allocate rays by WAVE_SIZE * X for each tile (X <= WAVE_RAY_SIZE)
// Using russian roulette to round the number of rays to one of the nearest multiples of WAVE_SIZE
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateUpdateRays (int DispatchID : SV_DispatchThreadID) {
    int TileID = DispatchID;
    if(TileID >= g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    int2  TileCoords         = int2(TileID % g_TileDimensions.x, TileID / g_TileDimensions.x);
    float TileAvgUpdateError = g_UpdateErrorSplatTexture.Load(int3(TileCoords, SSRC_TILE_SIZE_L2)).x;
    float Denominator        = max(g_RWUpdateErrorBuffer[0], 1e-4f);
    float Mean               = 1.f * g_TileDimensionsInv.x * g_TileDimensionsInv.y;
    float Fraction           = lerp(TileAvgUpdateError / Denominator, Mean, g_TileFractionPadding);
    float ExpectedRayCount   = Fraction * g_UpdateRayBudget;
    // RR
    // Only allocate rays for non-empty tiles
    int NonEmptyTile         = g_TileHiZ_Min.Load(int3(TileCoords, 0)).x < 1.f;
    uint FrameSeed = g_DebugFreezeFrameSeed ? g_DebugFreezeFrameSeedValue : g_FrameSeed;
    if(NonEmptyTile) {
        int X                    = max(int(ExpectedRayCount / WAVE_SIZE), 1);
        float Remainder          = (ExpectedRayCount - X * WAVE_SIZE) / WAVE_SIZE;
        Random rng = MakeRandom(97462891 + DispatchID, FrameSeed);
        if(rng.rand() < Remainder) {
            X++;
        }
        g_RWTileRayCountBuffer[TileID] = min(X, WAVE_RAY_SIZE) * WAVE_SIZE;
    } else {
        g_RWTileRayCountBuffer[TileID] = 0;
    }
}

// A scan sum is performed to accumulate g_RWTileRayCountBuffer into g_RWTileRayBaseOffsetBuffer

#define SAMPLE_ORIGIN_ERROR_PADDING (2e-3f)
#define ERROR_BLUR_LOD (2.25f)

// Importance sample the allocated update rays for each tile
groupshared float LocalUpdateErrorMip0[SSRC_TILE_SIZE][SSRC_TILE_SIZE];
groupshared float LocalUpdateErrorMip1[SSRC_TILE_SIZE / 2][SSRC_TILE_SIZE / 2];
groupshared float LocalUpdateErrorMip2[SSRC_TILE_SIZE / 4][SSRC_TILE_SIZE / 4];
groupshared SGData LocalSG[SSRC_MAX_BASIS_PER_TILE];
// Used to store the importance for overlapping basis when doing importance sampling
groupshared float LocalBasisImportance[SSRC_MAX_BASIS_PER_TILE];
groupshared float LocalBasisImportanceSum[SSRC_MAX_BASIS_PER_TILE + 1];
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_SampleUpdateRays (int GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID;
    if(TileID >= g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    int2 TileCoords = int2(TileID % g_TileDimensions.x, TileID / g_TileDimensions.x);
    int2 TileBaseTextureOffset = TileCoords * SSRC_TILE_SIZE;
    // Cooperatively load the update error mipmaps
    int L0PixelCount = SSRC_TILE_SIZE * SSRC_TILE_SIZE;
    for(int i = 0; i < L0PixelCount; i += WAVE_SIZE) {
        int PixelIndex = i + LocalID;
        if(PixelIndex < L0PixelCount) {
            int  PixelX = PixelIndex % SSRC_TILE_SIZE;
            int  PixelY = PixelIndex / SSRC_TILE_SIZE;
            int2 TexCoords = TileBaseTextureOffset + int2(PixelX, PixelY);
            float2 UV   = (float2(TexCoords) + 0.5f) * g_OutputDimensionsInv;
            float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
            if(Depth < 1.f) {
                // Sample mip ERROR_BLUR_LOD to achieve natural blurry effect
                LocalUpdateErrorMip0[PixelY][PixelX] = 
                    // FIXME
                    1.f;
                    //max(g_UpdateErrorSplatTexture.SampleLevel(g_LinearSampler, UV, ERROR_BLUR_LOD).x, SAMPLE_ORIGIN_ERROR_PADDING);
            } else { 
                LocalUpdateErrorMip0[PixelY][PixelX] = 0.f;
            }
        }
    }
    GroupMemoryBarrierWithGroupSync();
    int L1PixelCount = (SSRC_TILE_SIZE * SSRC_TILE_SIZE) / 4;
    for(int i = 0; i < L1PixelCount; i += WAVE_SIZE) {
        int PixelIndex = i + LocalID;
        if(PixelIndex < L1PixelCount) {
            int  PixelX = PixelIndex % (SSRC_TILE_SIZE / 2);
            int  PixelY = PixelIndex / (SSRC_TILE_SIZE / 2);
            int2 TexCoords = TileBaseTextureOffset / 2 + int2(PixelX, PixelY);
            LocalUpdateErrorMip1[PixelY][PixelX] = 
                LocalUpdateErrorMip0[2 * PixelY + 0][2 * PixelX + 0] +
                LocalUpdateErrorMip0[2 * PixelY + 0][2 * PixelX + 1] +
                LocalUpdateErrorMip0[2 * PixelY + 1][2 * PixelX + 0] +
                LocalUpdateErrorMip0[2 * PixelY + 1][2 * PixelX + 1];
        }
    }
    GroupMemoryBarrierWithGroupSync();
    int L2PixelCount = (SSRC_TILE_SIZE * SSRC_TILE_SIZE) / 16;
    for(int i = 0; i < L2PixelCount; i += WAVE_SIZE) {
        int PixelIndex = i + LocalID;
        if(PixelIndex < L2PixelCount) {
            int  PixelX = PixelIndex % (SSRC_TILE_SIZE / 4);
            int  PixelY = PixelIndex / (SSRC_TILE_SIZE / 4);
            int2 TexCoords = TileBaseTextureOffset / 4 + int2(PixelX, PixelY);
            LocalUpdateErrorMip2[PixelY][PixelX] = 
                LocalUpdateErrorMip1[2 * PixelY + 0][2 * PixelX + 0] +
                LocalUpdateErrorMip1[2 * PixelY + 0][2 * PixelX + 1] +
                LocalUpdateErrorMip1[2 * PixelY + 1][2 * PixelX + 0] +
                LocalUpdateErrorMip1[2 * PixelY + 1][2 * PixelX + 1];
        }
    }
    GroupMemoryBarrierWithGroupSync();
    float SumTileUpdateError = 
        LocalUpdateErrorMip2[0][0] +
        LocalUpdateErrorMip2[0][1] +
        LocalUpdateErrorMip2[1][0] +
        LocalUpdateErrorMip2[1][1];
    // Compute and load the SG importance to threads
    int TileBasisCount     = g_RWTileBasisCountBuffer[TileID];
    int TileBasisIndexBase = g_RWTileBaseSlotOffsetBuffer[TileID];
    // Jitter the representative sample point within the tile
    // First use of the blue noise samples, no dimension offset is needed
    uint   FrameSeed = g_DebugFreezeFrameSeed ? g_DebugFreezeFrameSeedValue : g_FrameSeed;
    float2 RepresentativeJitter = clamp(BlueNoise_Sample2D(TileCoords, FrameSeed), 0.f.xx, 0.999f.xx);
    int2   RepresentativeCoords = TileCoords * SSRC_TILE_SIZE + RepresentativeJitter * SSRC_TILE_SIZE;
    float2 RepresentativeUV     = (RepresentativeCoords + 0.5f.xx) * g_OutputDimensionsInv;
    float  RepresentativeDepth  = g_DepthTexture.Load(int3(RepresentativeCoords, 0)).x;
    float3 WorldPosition_R      = InverseProject(g_CameraProjViewInv, RepresentativeUV, RepresentativeDepth);
    bool   MeanSample           = false;
    if(RepresentativeDepth >= 1.f) {
        // Sampled a sky pixel
        // Use mean to replace W.
        MeanSample = true;
    }

    for(int TileBasisRankBase = 0; TileBasisRankBase < TileBasisCount; TileBasisRankBase += WAVE_SIZE) {
        int TileBasisRank = TileBasisRankBase + LocalID;
        if(TileBasisRank < TileBasisCount) {
            int BasisIndex = g_RWTileBasisIndexBuffer[TileBasisIndexBase + TileBasisRank];
            float3 BasisPosition;
            FetchBasisLocation(BasisIndex, BasisPosition);
            SGData SG; WData W;
            FetchBasisData_W(BasisIndex, SG, W);
            LocalSG[TileBasisRank] = SG;
            float3 DeltaPosition = BasisPosition - WorldPosition_R;
            // TODO replace constant 
            float EvaluatedW_B   = (MeanSample ? 0 : EvaluateW(W, DeltaPosition)) + 0.05f;
            float Intensity      = SGIntegrate(SG.Lambda) * dot(SG.Color, 1.f.xxx);
            float Weight = EvaluatedW_B * Intensity;
            LocalBasisImportance[TileBasisRank] = Weight;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    float PreviousSum = 0.f;
    for(int TileBasisRankBase = 0; TileBasisRankBase < TileBasisCount; TileBasisRankBase += WAVE_SIZE) {
        int TileBasisRank = TileBasisRankBase + LocalID;
        float Weight = 0.f;
        if(TileBasisRank < TileBasisCount) {
            Weight = LocalBasisImportance[TileBasisRank];   
        }
        float T      = PreviousSum + WavePrefixSum(Weight);
        LocalBasisImportanceSum[TileBasisRank] = T;
        // All lanes are active, so we can use the last lane's sum as the total sum
        PreviousSum = WaveReadLaneAt(T + Weight, WAVE_SIZE - 1);
    }
    if(LocalID == 0) {
        LocalBasisImportanceSum[TileBasisCount] = PreviousSum;
    }
    GroupMemoryBarrierWithGroupSync();

    int TileRayCount  = g_RWTileRayCountBuffer[TileID];
    int TileRayOffset = g_RWTileRayOffsetBuffer[TileID];
    int REPEAT        = (TileRayCount + WAVE_SIZE - 1) / WAVE_SIZE;
    Random rng        = MakeRandom(34622891 + TileID * WAVE_SIZE + LocalID, FrameSeed);
    for(int i = 0; i < REPEAT; i++) {
        int RayRank = i * WAVE_SIZE + LocalID;
        if(RayRank < TileRayCount) {
            float u = rng.rand();
            float U = u * SumTileUpdateError;
            int2  Offset = 0;
            // Assume the tile size is 8x8
            // 8x8 sub tile sampling
            {
                float X00 = LocalUpdateErrorMip2[Offset.y][Offset.x];
                float X01 = LocalUpdateErrorMip2[Offset.y][Offset.x + 1];
                float X10 = LocalUpdateErrorMip2[Offset.y + 1][Offset.x];
                float X11 = LocalUpdateErrorMip2[Offset.y + 1][Offset.x + 1];
                if(U < X00) {
                    // Do nothing
                } else if(U < X00 + X01) {
                    Offset.x += 1;
                    U -= X00;
                } else if(U < X00 + X01 + X10) {
                    Offset.y += 1;
                    U -= X00 + X01;
                } else {
                    Offset.x += 1;
                    Offset.y += 1;
                    U -= X00 + X01 + X10;
                }
            }
            Offset = Offset * 2;
            // 4x4 sub tile sampling
            {
                float X00 = LocalUpdateErrorMip1[Offset.y][Offset.x];
                float X01 = LocalUpdateErrorMip1[Offset.y][Offset.x + 1];
                float X10 = LocalUpdateErrorMip1[Offset.y + 1][Offset.x];
                float X11 = LocalUpdateErrorMip1[Offset.y + 1][Offset.x + 1];
                if(U < X00) {
                    // Do nothing
                } else if(U < X00 + X01) {
                    Offset.x += 1;
                    U -= X00;
                } else if(U < X00 + X01 + X10) {
                    Offset.y += 1;
                    U -= X00 + X01;
                } else {
                    Offset.x += 1;
                    Offset.y += 1;
                    U -= X00 + X01 + X10;
                }
            }
            Offset = Offset * 2;
            // 2x2 sub tile sampling
            {
                float X00 = LocalUpdateErrorMip0[Offset.y][Offset.x];
                float X01 = LocalUpdateErrorMip0[Offset.y][Offset.x + 1];
                float X10 = LocalUpdateErrorMip0[Offset.y + 1][Offset.x];
                float X11 = LocalUpdateErrorMip0[Offset.y + 1][Offset.x + 1];
                if(U < X00) {
                    // Do nothing
                } else if(U < X00 + X01) {
                    Offset.x += 1;
                    U -= X00;
                } else if(U < X00 + X01 + X10) {
                    Offset.y += 1;
                    U -= X00 + X01;
                } else {
                    Offset.x += 1;
                    Offset.y += 1;
                    U -= X00 + X01 + X10;
                }
            }
            float PixelError = LocalUpdateErrorMip0[Offset.y][Offset.x];
            // Pdf == 0 means the sample is invalid (sampled a sky pixel)
            float Pdf = (PixelError / SumTileUpdateError) * (SSRC_TILE_SIZE * SSRC_TILE_SIZE);

            // Sample ray origin
            int2   SubTileCoords = Offset;
            // uint2 SampledTexCoords = TileBaseTextureOffset + SubTileCoords;
            // float SampledDepth = g_DepthTexture.Load(int3(SampledTexCoords, 0)).x;
            // float2 SampledUV   = (SampledTexCoords + 0.5f) * g_OutputDimensionsInv;
            // float SampledRayOrigin = InverseProject(g_CameraProjViewInv, SampledUV, SampledDepth);
            
            // Sample ray direction using another random number
            u = rng.rand() * PreviousSum;
            int L = 0, R = TileBasisCount;
            while(L < R) {
                int M = (L + R) / 2;
                if(LocalBasisImportanceSum[M] < u) {
                    L = M + 1;
                } else {
                    R = M;
                }
            }
            float2 u2 = rng.rand2();
            SGData SG = LocalSG[max(L-1, 0)];
            float Pdf_Dir;
            float3 RayDirection = SampleSG(u2, SG.Lambda, Pdf_Dir);
            // Directional pdf is taken into consideration in later stages.
            // We simply drops the directional pdf here.
            float3 Tangent, Bitangent;
            TangentVectors(SG.Direction, Tangent, Bitangent);
            RayDirection = normalize(RayDirection.x * Tangent + RayDirection.y * Bitangent + RayDirection.z * SG.Direction);
            // FIXME
            RayDirection = UniformSampleSphere(u2);
            Pdf = 1.f;
            // Record the generated update ray
            g_RWUpdateRayDirectionBuffer[TileRayOffset + RayRank] = PackNormal(RayDirection);
            g_RWUpdateRayOriginBuffer[TileRayOffset + RayRank] = PackUint16x2(TileCoords * SSRC_TILE_SIZE + SubTileCoords);
            g_RWUpdateRayRadiancePdfBuffer[TileRayOffset + RayRank] = PackFp16x4(float4(0.f.xxx, Pdf));
        }
    }
}

#define SSRC_DISPATCH_RAYS_GROUP_SIZE 8

[numthreads(1, 1, 1)]
void SSRC_GenerateTraceUpdateRays () {
    DispatchRaysCommand dispatch_command_rays = (DispatchRaysCommand)0;
    // FIXME DXR support
    dispatch_command_rays.width = g_RWUpdateRayCountBuffer[0];
    dispatch_command_rays.height = 1;
    dispatch_command_rays.depth = 1;
    g_RWDispatchRaysCommandBuffer[0] = dispatch_command_rays;

    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = 
        (g_RWUpdateRayCountBuffer[0] + SSRC_DISPATCH_RAYS_GROUP_SIZE - 1) 
        / SSRC_DISPATCH_RAYS_GROUP_SIZE;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

// Trace visibility rays to generate intersections for secondary vertices
void SSRC_TraceUpdateRays (uint DispatchID) {
    if(DispatchID >= g_RWUpdateRayCountBuffer[0]) return ;
    
    // Unpack ray data
    int2   TexCoords  = UnpackUint16x2(g_RWUpdateRayOriginBuffer[DispatchID]);
    float2 UV         = (TexCoords + 0.5f) * g_OutputDimensionsInv;

    // Unpack G-buffer data
    float4 Visibility   = g_VisibilityTexture.Load(int3(TexCoords, 0));
    float2 Barycentrics = Visibility.xy;
    uint   InstanceID   = asuint(Visibility.z);
    uint   PrimitiveID  = asuint(Visibility.w);

    Instance InstanceData  = g_InstanceBuffer[InstanceID];
    Mesh     MeshData      = g_MeshBuffer[InstanceData.mesh_index];
    float3x4 Transform     = g_TransformBuffer[InstanceData.transform_index];

    Triangle vertices = fetchVertices(MeshData, PrimitiveID);
    float3 v0 = transformPoint(vertices.v0, Transform);
    float3 v1 = transformPoint(vertices.v1, Transform);
    float3 v2 = transformPoint(vertices.v2, Transform);

    float3 WorldPixelPosition  = interpolate(v0, v1, v2, Barycentrics);
    
    float3 GeometryNormal = normalize(2.0f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.0f);

    float3 RayOrigin = offsetPosition(WorldPixelPosition, GeometryNormal);

    float3 RayDirection   = UnpackNormal(g_RWUpdateRayDirectionBuffer[DispatchID]);
    float4 RayRadiancePdf = UnpackFp16x4(g_RWUpdateRayRadiancePdfBuffer[DispatchID]);
    float Pdf = RayRadiancePdf.w;

    if(dot(RayDirection, GeometryNormal) < 0.0f) {
        // Learn negative samples.
        g_RWUpdateRayRadiancePdfBuffer[DispatchID] = PackFp16x4(float4(0.0f.xxx, Pdf));
        return ;
    }

    // Trace a visibility ray only.
    RayDesc VisibilityRayDesc;
    VisibilityRayDesc.Origin = RayOrigin;
    VisibilityRayDesc.Direction = RayDirection;
    VisibilityRayDesc.TMin = 0.f;
    VisibilityRayDesc.TMax = MAX_HIT_DISTANCE;

    ScreenCacheUpdatePayload payload;
    payload.sky_sample = float3(0.0f, 0.0f, 0.0f);
    ScreenCacheUpdateTraceRay(
        DispatchID,
        payload, VisibilityRayDesc
    );
    // Fallback to sky sample if no intersection
    g_RWUpdateRayRadiancePdfBuffer[DispatchID] = PackFp16x4(float4(payload.sky_sample, Pdf));
}

[numthreads(SSRC_DISPATCH_RAYS_GROUP_SIZE, 1, 1)]
void SSRC_TraceUpdateRaysMain (uint DispatchID : SV_DispatchThreadID) {
    SSRC_TraceUpdateRays(DispatchID);
}

[numthreads(WAVE_SIZE, 1, 1)]
void ClearReservoirs(in uint did : SV_DispatchThreadID)
{
    g_Reservoir_HashBuffer[did]      = 0;
    g_Reservoir_HashCountBuffer[did] = 0;
}


[numthreads(WAVE_SIZE, 1, 1)]
void GenerateReservoirs(in uint DispatchID : SV_DispatchThreadID)
{
    if (DispatchID >= g_HashGridCache_VisibilityCountBuffer[0])
    {
        return; // out of bounds
    }

    // Load our visibility sample
    float4                   packed_visibility = g_HashGridCache_VisibilityBuffer[DispatchID];
    HashGridCache_Visibility visibility        = HashGridCache_UnpackVisibility(packed_visibility);

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[visibility.instance_index];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index + visibility.geometry_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    TriangleNormUV vertices = fetchVerticesNormUV(mesh, visibility.primitive_index);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);

    vertices.n0 = transformNormal(vertices.n0, transform);
    vertices.n1 = transformNormal(vertices.n1, transform);
    vertices.n2 = transformNormal(vertices.n2, transform);

    float3   world    =                                                       interpolate(vertices.v0, vertices.v1, vertices.v2, visibility.barycentrics);
    float3   normal   = (visibility.is_front_face ? 1.0f : -1.0f) * normalize(interpolate(vertices.n0, vertices.n1, vertices.n2, visibility.barycentrics));
    Material material = g_MaterialBuffer[instance.material_index];

    // Recover the ray origin
    uint query_index = g_HashGridCache_VisibilityQueryBuffer[DispatchID];
    // Queries are indexed with ray index
    int2 pixel_coords = UnpackUint16x2(g_RWUpdateRayOriginBuffer[query_index]);
    float depth = g_DepthTexture.Load(int3(pixel_coords, 0)).x;
    float2 uv = (pixel_coords + 0.5f) / g_OutputDimensions;
    float3 origin = InverseProject(g_CameraProjViewInv, uv, depth);
    float2 mesh_uv = interpolate(vertices.uv0, vertices.uv1, vertices.uv2, visibility.barycentrics);

    // Patch the screen space cache with some emissivity information:
    // We bypass the hash-grid cache entirely here, as adding emissive information to the cells
    // effectively enlarges the area light (due to the spatial nature of the grid) and leads to
    // light leaks and generally poorer visuals.

    // Double sided emissive
    if (/*visibility.is_front_face && */dot(material.emissivity.xyz, material.emissivity.xyz) > 0.0f)
    {
        MaterialEmissive emissive = MakeMaterialEmissive(material, mesh_uv);
        float4 RadiancePdf = UnpackFp16x4(g_RWUpdateRayRadiancePdfBuffer[query_index]);
        RadiancePdf.xyz = emissive.emissive;
        g_RWUpdateRayRadiancePdfBuffer[query_index] = PackFp16x4(RadiancePdf);

        return; // do not continue past an emissive surface
    }

    // We can perform some temporal radiance feedback from last frame if direct lighting was
    // evaluated.
    // If successful, we inject the reprojected radiance into the cache so it can be re-used
    // by neighbor vertices but bypass the filtered readback as the sample is already denoised.
    {
        float3 homogeneous = transformPointProjection(world, g_CameraProjView);

        uv    = 0.5f * float2(homogeneous.x, -homogeneous.y) + 0.5f;
        depth = homogeneous.z;

        if (all(uv > 0.0f) && all(uv < 1.0f) && depth > 0.0f && depth < 1.0f)
        {
            float2 previous_uv = uv - g_VelocityTexture.SampleLevel(g_NearestSampler, uv, 0.0f).xy;

            if (all(previous_uv > 0.0f) && all(previous_uv < 1.0f))
            {
                float3 homogeneous2 = transformPointProjection(float3(2.0f * float2(uv.x, 1.0f - uv.y) - 1.0f, depth), g_Reprojection);
                homogeneous2.z      = GetLinearDepth(homogeneous2.z);

                float  previous_depth  = GetLinearDepth(g_PreviousDepthTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).x);
                float3 previous_normal = normalize(2.0f * g_PreviousGeometryNormalTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz - 1.0f);

                if (dot(previous_normal, normal) > 5e-1f && abs(previous_depth - homogeneous2.z) / homogeneous2.z < 5e-2f)
                {
                    float3 previous_lighting = g_PrevCombinedIlluminationTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz;

                    uint  cell_index         = g_HashGridCache_VisibilityCellBuffer[DispatchID];
                    uint4 quantized_radiance = HashGridCache_QuantizeRadiance(previous_lighting);
#ifdef ENABLE_INDIRECT
                    float4 RayRadiancePdf    = UnpackFp16x4(g_RWUpdateRayRadiancePdfBuffer[query_index]);
                    RayRadiancePdf.xyz      += previous_lighting;
                    g_RWUpdateRayRadiancePdfBuffer[query_index] = PackFp16x4(RayRadiancePdf);
#endif // ENABLE_INDIRECT
                    if (dot(previous_lighting, previous_lighting) > 0.0f)
                    {
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0], quantized_radiance.x);
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1], quantized_radiance.y);
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2], quantized_radiance.z);
                    }
                    InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3], quantized_radiance.w);

                    return; // we can skip the shadow ray for this sample :)
                }
            }
        }
    }

    float3 view_direction = normalize(origin - world);

    // Sample new lights
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 1.5f);
    MaterialEvaluated material2 = MakeMaterialEvaluated(material, mesh_uv);
    MaterialBRDF materialBRDF = MakeMaterialBRDF(material2);
    // Make the seed different from the one used in TraceUpdateRays
    Random random = MakeRandom(DispatchID ^ 0x8a197727, g_FrameSeed);
    LightSampler lightSampler = MakeLightSampler(random);
    Reservoir reservoir = lightSampler.sampleLightListCone<kReservoir_SampleCount>(world, normal, view_direction, solid_angle, materialBRDF);

    if (!reservoir.isValid())
    {
        return;
    }

    // Append our resampled shadow ray, generate a ray index for later tracing and updates
    uint ray_index;
    InterlockedAdd(g_HashGridCache_VisibilityRayCountBuffer[0], 1, ray_index);

    g_HashGridCache_VisibilityRayBuffer[ray_index] = DispatchID;   // compact the surviving shadow rays

    // Here, we check that the ray has traversed at least a full hash cell
    // before hitting something.
    // If it hasn't, we bypass the filtering from the cache (although we
    // still accumulate the contribution into the cell).
    //
    // This avoids possible light leaks in the following configuration:
    //
    //    bright area   +--------------+
    //                  |    dark area |
    //                  | |            |
    //                  | x            |
    //                  |/|            |
    //                 /|\             |
    //                / | eye          |
    // bright radiance  +--------------+
    //
    // Here the point 'x' is reached after bouncing from the first vertex.
    // (i.e., it is a 2nd vertex, the ones filtered through the hash grid)
    // Because it is close to the wall and has a similar direction to the
    // 'bright radiance' event, both vertices will share the same hash cell
    // leading to a light leak on the bounced lighting from the inner wall.
    //
    // Such a scenario mostly occurs if the length of the ray connecting
    // the 2nd vertex is less than the size of the hash cell being used.
    // So, we detect this case and flag a bypass of the filtered readback.
    float cell_size  = HashGridCache_GetCellSize(world);
    float ray_length = distance(origin, world);

    if (ray_length < cell_size)
    {
        g_HashGridCache_VisibilityRayBuffer[ray_index] |= 0x80000000u;
    }

    // Insert the reservoir into the hash table
#ifdef USE_RESAMPLING
    float3 b1, b2;
    GetOrthoVectors(normal, b1, b2);
    float2 jitter = 2.0f * random.rand2() - 1.0f;
    jitter *= Reservoir_GetCellSize(world) * kReservoir_SpatialJitter;
    Reservoir_InsertEntry(ray_index, world + jitter.x * b1 + jitter.y * b2);

    g_Reservoir_IndirectSampleBuffer[ray_index]       = Reservoir_PackIndirectSample(origin, world);
    g_Reservoir_IndirectSampleNormalBuffer[ray_index] = packNormal(normal);
#endif // USE_RESAMPLING

    // Write the results out to memory
    g_Reservoir_IndirectSampleMaterialBuffer[ray_index]  = packMaterial(material2);  // cannot afford to re-fetch the full material each time, so we need to approximate it...
    g_Reservoir_IndirectSampleReservoirBuffer[ray_index] = packReservoir(reservoir);
}


[numthreads(WAVE_SIZE, 1, 1)]
void CompactReservoirs(in uint did : SV_DispatchThreadID)
{
    if (did >= g_Reservoir_HashListCountBuffer[0])
    {
        return; // out of bounds
    }

    uint4 list_element = g_Reservoir_HashListBuffer[did];
    uint  value_index  = g_Reservoir_HashIndexBuffer[list_element.y] + list_element.z;

    g_Reservoir_HashValueBuffer[value_index] = list_element.x;
}

// Temporal resampling only
[numthreads(WAVE_SIZE, 1, 1)]
void ResampleReservoirs(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    // Load our shading information
    float3 origin, world;
    Reservoir_UnpackIndirectSample(g_Reservoir_IndirectSampleBuffer[did], origin, world);

    float3       normal    = unpackNormal(g_Reservoir_IndirectSampleNormalBuffer[did]);
    MaterialBRDF material  = unpackMaterial(g_Reservoir_IndirectSampleMaterialBuffer[did]);
    Reservoir    reservoir = unpackReservoir(g_Reservoir_IndirectSampleReservoirBuffer[did]);

    // Normalize the sample count M (a.k.a. confidence weight) with the initial sample count for simplicity.
    reservoir.M = 1.0f;

    // Make the random numbers different from previous samples
    Random random = MakeRandom(did + g_OutputDimensions.x * g_OutputDimensions.y, g_FrameSeed);

    // Locate our hash table cell
    float3 b1, b2;
    GetOrthoVectors(normal, b1, b2);
    float2 jitter = 2.0f * random.rand2() - 1.0f;
    jitter *= Reservoir_GetCellSize(world) * kReservoir_SpatialJitter;
    uint entry_index = Reservoir_FindPreviousEntry(world + jitter.x * b1 + jitter.y * b2);

    if (entry_index == kGI10_InvalidId)
    {
        return; // no previous reservoir cell - temporal resampling failed :'(
    }

    uint index = g_Reservoir_PreviousHashIndexBuffer[entry_index];
    uint count = g_Reservoir_PreviousHashCountBuffer[entry_index];

    // Stochastically iterate the cell content
    uint max_count = 4;
    uint increment = (count + max_count - 1) / max_count;
    uint offset    = random.randInt(increment);

    // And combine the reservoirs
    float3 view_direction = normalize(origin - world);
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 12000.0f);
    ReservoirUpdater updater = MakeReservoirUpdater();
    mergeReservoirsCone(updater, reservoir, random, material, world, normal, view_direction, solid_angle);
    for (uint i = 0; i < count; i += increment)
    {
        // Load up the iterated reservoir
        uint      reservoir_index = g_Reservoir_PreviousHashValueBuffer[index + ((i + offset) % count)];
        Reservoir reservoir2      = unpackReservoir(g_Reservoir_PreviousIndirectSampleReservoirBuffer[reservoir_index]);
        float3    filter_normal   = unpackNormal(g_Reservoir_PreviousIndirectSampleNormalBuffer[reservoir_index]);

        if (!reservoir2.isValid())
        {
            continue;   // skip invalid reservoir(s)
        }

        // Bilaterally filter the neighbor reservoir
        float bilateral_weight = max(dot(normal, filter_normal), 0.0f);
        bilateral_weight = squared(squared(bilateral_weight)); // make it steep
        if (bilateral_weight < kReservoir_BilateralThreshold) continue;

        // And combine it with our current reservoir
        Reservoir_ClampPrevious(reservoir2);
        mergeReservoirsCone(updater, reservoir2, random, material, world, normal, view_direction, solid_angle);
    }

    if (!updater.reservoir.M)
    {
        return; // reprojection failed
    }

    // Finalize our reservoir
    reservoir = updater.reservoir;

    // And write it out to memory
    g_Reservoir_IndirectSampleReservoirBuffer[did] = packReservoir(reservoir);
}

void PopulateCellsHandleHit(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    payload.lighting    = float3(0.0f, 0.0f, 0.0f);

    Reservoir reservoir = payload.reservoir;
    // Update our reservoir cache for next frame's temporal resampling
#ifdef USE_RESAMPLING
    reservoir.W = 0.0f; // invalidate the reservoir

    g_Reservoir_IndirectSampleReservoirBuffer[did] = packReservoir(reservoir);
#endif // USE_RESAMPLING
}

void PopulateCellsHandleMiss(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    float3       light_radiance = payload.lighting;
    float        light_weight   = payload.reservoir.W;
    int2         pixel_coords   = UnpackUint16x2(g_RWUpdateRayOriginBuffer[payload.query_index]);
    MaterialBRDF material       = unpackMaterial(g_Reservoir_IndirectSampleMaterialBuffer[did]);

    // Recover the ray origin
    float  depth  = g_DepthTexture.Load(int3(pixel_coords, 0)).x;
    float2 uv     = (pixel_coords + 0.5f) / g_OutputDimensions;
    float3 origin = InverseProject(g_CameraProjViewInv, uv, depth);

    // And evaluate our lighting
    payload.lighting =
        evaluateBRDF(material, payload.normal, normalize(origin - payload.world), ray.Direction)
        * light_radiance * light_weight;
}

void PopulateCellsTraceRayInline(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    ShadowRayQuery ray_query = TraceRay<ShadowRayQuery>(ray);

    if (ray_query.CommittedStatus() == COMMITTED_NOTHING)
    {
        PopulateCellsHandleMiss(did, payload, ray);
    }
    else
    {
        PopulateCellsHandleHit(did, payload, ray);
    }
}

void PopulateCellsTraceRayRt(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    TraceRay(g_Scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH, 0xFFu, 0, 0, 0, ray, payload);
}

void PopulateCellsTraceRay(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
#if USE_INLINE_RT
    return PopulateCellsTraceRayInline(did, payload, ray);
#else
    return PopulateCellsTraceRayRt(did, payload, ray);
#endif
}

// Light sampling completed, actually trace a shadow ray for each hash grid cache query.
void PopulateCells(uint did)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    uint                     visibility_index = (g_HashGridCache_VisibilityRayBuffer[did] & ~0x80000000u);
    HashGridCache_Visibility visibility       = HashGridCache_UnpackVisibility(g_HashGridCache_VisibilityBuffer[visibility_index]);

    uint query_index = g_HashGridCache_VisibilityQueryBuffer[visibility_index];
    int2 pixel_coords = UnpackUint16x2(g_RWUpdateRayOriginBuffer[query_index]);

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[visibility.instance_index];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index + visibility.geometry_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    Triangle vertices = fetchVertices(mesh, visibility.primitive_index);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);
    float3 world = interpolate(vertices.v0, vertices.v1, vertices.v2, visibility.barycentrics);
    float3 edge10 = vertices.v1 - vertices.v0;
    float3 edge20 = vertices.v2 - vertices.v0;
    float3 normal = normalize(transformNormal(cross(edge10, edge20) * (visibility.is_front_face ? 1.0f : -1.0f), transform));

    // Retrieve the light sample that we should use for our shadow ray
    Reservoir reservoir    = unpackReservoir(g_Reservoir_IndirectSampleReservoirBuffer[did]);

    // Decode the light sample from our reservoir
    float3 direction, light_position;
    // Approximate visible light surface based on number of samples being used
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 12000.0f);
    Light selected_light = getLight(reservoir.lightSample.index);
    float3 light_radiance = evaluateLightConeSampled(selected_light, world, reservoir.lightSample.sampleParams, solid_angle, direction, light_position);

    // Traverse the BVH
    RayDesc ray_desc;
    ray_desc.Direction = direction;
    ray_desc.Origin    = offsetPosition(world, normal);
    ray_desc.TMin      = 0.0f;
    ray_desc.TMax      = hasLightPosition(selected_light) ? length(light_position - ray_desc.Origin) : FLT_MAX;

    PopulateCellsPayload payload;
    payload.query_index = query_index;
    payload.world       = world;
    payload.normal      = normal;
    payload.lighting    = light_radiance;
    payload.reservoir   = reservoir;
    PopulateCellsTraceRay(did, payload, ray_desc);

    // And update the hash-grid cell payload
    uint  cell_index         = g_HashGridCache_VisibilityCellBuffer[visibility_index];
    uint4 quantized_radiance = HashGridCache_QuantizeRadiance(payload.lighting);

    if (dot(payload.lighting, payload.lighting) > 0.0f)
    {
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0], quantized_radiance.x);
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1], quantized_radiance.y);
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2], quantized_radiance.z);
    }
    InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3], quantized_radiance.w);

    // In some cases, we want to bypass the cache to avoid light leaks;
    // so we simply patch the screen probes directly and invalidate the
    // cache connection.
    bool is_bypass_cache = ((g_HashGridCache_VisibilityRayBuffer[did] >> 31) != 0);

    if (is_bypass_cache)
    {
        float4 RadiancePdf = UnpackFp16x4(g_RWUpdateRayRadiancePdfBuffer[query_index]);
        RadiancePdf.xyz   += payload.lighting;
        g_RWUpdateRayRadiancePdfBuffer[query_index] = PackFp16x4(RadiancePdf);
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void PopulateCellsMain(in uint did : SV_DispatchThreadID)
{
    PopulateCells(did);
}

// BE CAREFUL: we assume
//             UPDATE_TILES_NOT_SLICED_GROUP_* >= g_HashGridCacheConstants.size_tile_mip0
//             UPDATE_TILES_NOT_SLICED_GROUP_*  % g_HashGridCacheConstants.size_tile_mip0 == 0
//
#define UPDATE_TILES_GROUP_X 8
#define UPDATE_TILES_GROUP_Y 8
#define UPDATE_TILES_GROUP_SIZE (UPDATE_TILES_GROUP_X * UPDATE_TILES_GROUP_Y)

groupshared uint2 lds_UpdateTiles_ValueBuffer[UPDATE_TILES_GROUP_X][UPDATE_TILES_GROUP_Y];

[numthreads(1, 1, 1)]
void GenerateUpdateTilesDispatch()
{
    uint num_tiles_by_group = UPDATE_TILES_GROUP_SIZE / g_HashGridCacheConstants.num_cells_per_tile_mip0;

    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = (g_HashGridCache_UpdateTileCountBuffer[0] + num_tiles_by_group - 1) / num_tiles_by_group;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

[numthreads(UPDATE_TILES_GROUP_X, UPDATE_TILES_GROUP_Y, 1)]
void UpdateTiles(in uint group_id : SV_GroupID, in uint2 group_thread_id : SV_GroupThreadID)
{
    // A group cover from 1 tile/subgroup (8x8) to 64 tiles/subgroups (1x1)
    uint2 subgroup_id        = group_thread_id / g_HashGridCacheConstants.size_tile_mip0;
    uint2 subgroup_thread_id = group_thread_id % g_HashGridCacheConstants.size_tile_mip0;
    uint2 subgroup_size      = uint2(UPDATE_TILES_GROUP_X, UPDATE_TILES_GROUP_Y) / g_HashGridCacheConstants.size_tile_mip0;
    uint  update_tile_index  = group_id * subgroup_size.x * subgroup_size.y +
                               subgroup_id.y * subgroup_size.x +
                               subgroup_id.x;

    if (update_tile_index >= g_HashGridCache_UpdateTileCountBuffer[0])
    {
        return;
    }

    uint tile_index = g_HashGridCache_UpdateTileBuffer[update_tile_index];

    // MIP 0
    {
        uint cell_index  = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 0);

        // Temporal accumulation
        float4 radiance     = HashGridCache_UnpackRadiance(g_HashGridCache_ValueBuffer[cell_index]);
        float4 new_radiance = HashGridCache_RecoverRadiance(uint4(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3]));

        float sample_count = min(radiance.w + new_radiance.w, g_HashGridCacheConstants.max_sample_count);

        radiance     /= max(radiance.w, 1.0f);
        new_radiance /= max(new_radiance.w, 1.0f);

        if (radiance.w <= 0.0f)
        {
            radiance = new_radiance;
        }
        else
        {
            radiance = lerp(radiance, new_radiance, 1.0f / sample_count);
        }

        radiance *= sample_count;   // sample count is used as a hint for picking prefiltering amount

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;

        // Clear scratch
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3] = 0;
    }

    // MIP 1
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip1 > 0 && all((group_thread_id % 2) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 1);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance10 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 1][group_thread_id.y + 0];
        uint2 packed_radiance01 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 1];
        uint2 packed_radiance11 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 1][group_thread_id.y + 1];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance10);
        radiance += HashGridCache_UnpackRadiance(packed_radiance01);
        radiance += HashGridCache_UnpackRadiance(packed_radiance11);

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;
    }

    // MIP 2
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip2 > 0 && all((group_thread_id % 4) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 2);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance20 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 2][group_thread_id.y + 0];
        uint2 packed_radiance02 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 2];
        uint2 packed_radiance22 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 2][group_thread_id.y + 2];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance20);
        radiance += HashGridCache_UnpackRadiance(packed_radiance02);
        radiance += HashGridCache_UnpackRadiance(packed_radiance22);

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;
    }

    // MIP 3
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip3 > 0 && all((group_thread_id % 8) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 3);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance40 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 4][group_thread_id.y + 0];
        uint2 packed_radiance04 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 4];
        uint2 packed_radiance44 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 4][group_thread_id.y + 4];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance40);
        radiance += HashGridCache_UnpackRadiance(packed_radiance04);
        radiance += HashGridCache_UnpackRadiance(packed_radiance44);

        // Pack
        g_HashGridCache_ValueBuffer[cell_index] = HashGridCache_PackRadiance(radiance);
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void ResolveCells(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    uint visibility_index = g_HashGridCache_VisibilityRayBuffer[did];

    if ((visibility_index >> 31) != 0)
    {
        return; // do not use filtered radiance
    }

    uint cell_index  = g_HashGridCache_VisibilityCellBuffer[visibility_index];
    uint query_index = g_HashGridCache_VisibilityQueryBuffer[visibility_index];

    float4 radiance = HashGridCache_FilteredRadiance(cell_index, false);

    int2 pixel_coords = UnpackUint16x2(g_RWUpdateRayOriginBuffer[query_index]);
#ifdef ENABLE_INDIRECT
    float4 RadiancePdf = UnpackFp16x4(g_RWUpdateRayRadiancePdfBuffer[query_index]);
    RadiancePdf.xyz   += GIDenoiser_RemoveNaNs(radiance.xyz / max(radiance.w, 1.0f));
    g_RWUpdateRayRadiancePdfBuffer[query_index] = PackFp16x4(RadiancePdf);
#endif
}

// Precompute the cache update
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_PrecomputeCacheUpdate (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID             = GroupID.x + GroupID.y * g_TileDimensions.x;
    int TileBasisCount     = g_RWTileBasisCountBuffer[TileID];
    int TileSlotBaseOffset = g_RWTileBaseSlotOffsetBuffer[TileID];
    int2 TileTextureBaseOffset = int2(GroupID.x * SSRC_TILE_SIZE, GroupID.y * SSRC_TILE_SIZE);

    // Thread local accumulators
    float3 ThreadSumRadiance[WAVE_RAY_SIZE];
    float  ThreadSumWeight  [WAVE_RAY_SIZE];
    for(int i = 0; i < WAVE_RAY_SIZE; i++) {
        ThreadSumRadiance[i] = 0.f.xxx;
        ThreadSumWeight  [i] = 0.f;
    }

    // Pixel related data
    const int PIXEL_PER_THREAD = SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE;
    float3 ThreadPixelPos     [PIXEL_PER_THREAD];
    bool   ThreadPixelValid   [PIXEL_PER_THREAD];
    float  ThreadPixelCoverage[PIXEL_PER_THREAD];
    for(int i = 0; i< PIXEL_PER_THREAD; i++) {
        int PixelRank = i * WAVE_SIZE + LocalID;
        // Assume SSRC_TILE_SIZE ** 2 is a multiple of WAVE_SIZE
        {
            int2 TexCoords = TileTextureBaseOffset 
                + int2(PixelRank % SSRC_TILE_SIZE, PixelRank / SSRC_TILE_SIZE);
            float2 UV = (float2(TexCoords) + 0.5f) * g_OutputDimensionsInv;
            float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
            float3 PixelWorldPosition = InverseProject(g_CameraProjViewInv, UV, Depth);
            ThreadPixelPos    [i] = PixelWorldPosition;
            ThreadPixelValid  [i] = Depth < 1.f;
            ThreadPixelCoverage[i] = 0.f;
        }
    }

    float3 ThreadRayDirection[WAVE_RAY_SIZE];
    float3 ThreadRayOrigin   [WAVE_RAY_SIZE];
    uint   TileUpdateRayOffset = g_RWTileRayOffsetBuffer[TileID];
    uint   TileUpdateRayCount  = g_RWTileRayCountBuffer[TileID];
    const int REPEAT = min(WAVE_RAY_SIZE, (TileUpdateRayCount + WAVE_SIZE - 1) / WAVE_SIZE);
    for(int i = 0; i< REPEAT; i++) {
        int TileRayRank = i * WAVE_SIZE + LocalID;
        if(TileRayRank < TileUpdateRayCount) {
            int    RayIndex = TileUpdateRayOffset + TileRayRank;
            float3 RayDirection   = UnpackNormal(g_RWUpdateRayDirectionBuffer[RayIndex]);
            int2   TexCoords      = UnpackUint16x2(g_RWUpdateRayOriginBuffer[RayIndex]);
            float2 UV = (float2(TexCoords) + 0.5f) * g_OutputDimensionsInv;
            float  Depth = g_DepthTexture.Load(int3(UV * g_OutputDimensions, 0)).x;
            float3 RayOrigin    = InverseProject(g_CameraProjViewInv, UV, Depth);
            ThreadRayDirection[i] = RayDirection;
            ThreadRayOrigin   [i] = RayOrigin;
        }
    }
    
    // Iterate over each basis overlapping with this tile
    for(int Slot = 0; Slot < TileBasisCount; Slot ++) {
        bool AccessedSG = false;
        int  BasisIndex = g_RWTileBasisIndexBuffer[TileSlotBaseOffset + Slot];
        SGData SG;
        WData  W;
        FetchBasisData_W(BasisIndex, SG, W);
        float3 BasisWorldPosition;
        FetchBasisLocation(BasisIndex, BasisWorldPosition);
        float2 BasisScreenPosition = transformPointProjection(BasisWorldPosition, g_CameraProjView).xy;
        BasisScreenPosition = NDC22UV(BasisScreenPosition) * g_OutputDimensions;
        // Cooperatively iterate over all pixels of this tile (for coverage computation)
        for(int i = 0; i < PIXEL_PER_THREAD; i++) {
            int  PixelRank = i * WAVE_SIZE + LocalID;
            int2 PixelCoords = int2(PixelRank % SSRC_TILE_SIZE, PixelRank / SSRC_TILE_SIZE);
            // Assume SSRC_TILE_SIZE ** 2 is a multiple of WAVE_SIZE
            if(ThreadPixelValid[i]) {
                int2 TexCoords = TileTextureBaseOffset + PixelCoords;
                float3 PixelWorldPosition = ThreadPixelPos[i];
                float3 DeltaPosition  = PixelWorldPosition - BasisWorldPosition;
                float2 DeltaPosition2 = float2(TexCoords) + 0.5f - BasisScreenPosition;
                float EvaluatedW = EvaluateW(W, DeltaPosition);
                // Accumulate weight for this pixel
                ThreadPixelCoverage[i] += sqrt((EvaluatedW + g_WCoveragePadding) * EvaluateFilmCoverage(DeltaPosition2));
            }
        }
        // Cooperatively iterate over all update rays of this tile
        for(int i = 0; i < REPEAT; i++) {
            int TileRayRank = i * WAVE_SIZE + LocalID;
            if(TileRayRank < TileUpdateRayCount) {
                // There is no bank conflict as the stride is 3 * 4 bytes for float3
                // Loading from shmem is done in 1 cycle per word
                float3 RayDirection = ThreadRayDirection[i];

                float3 EvaluatedRadiance = EvaluateSG(SG, RayDirection);
                float3 DeltaPosition     = ThreadRayOrigin[i] - BasisWorldPosition;
                float  EvaluatedW        = EvaluateW(W, DeltaPosition);

                // Use thread local registers to accumulate results
                ThreadSumRadiance[i] += EvaluatedRadiance * EvaluatedW;
                ThreadSumWeight  [i] += EvaluatedW;
            }
        }
    }
    // Cooperatively write back the data
    for(int i = 0; i < PIXEL_PER_THREAD; i++) {
        int PixelRank = i * WAVE_SIZE + LocalID;
        {
            int2 TexCoords = TileTextureBaseOffset + int2(PixelRank % SSRC_TILE_SIZE, PixelRank / SSRC_TILE_SIZE);
            g_RWCacheCoverageTexture[TexCoords] = ThreadPixelCoverage[i];
        }
    }
    for(int i = 0; i < REPEAT; i++) {
        int TileRayRank = i * WAVE_SIZE + LocalID;
        if(TileRayRank < TileUpdateRayCount) {
            int UpdateRayIndex = TileUpdateRayOffset + TileRayRank;
            float3 SumRadiance = ThreadSumRadiance[i];
            float  SumWeight   = ThreadSumWeight  [i];
            if(SumWeight != 0) {
                float3 Eval = SumRadiance / SumWeight;
                g_RWUpdateRayCacheBuffer[UpdateRayIndex] = PackFp16x4(float4(Eval, SumWeight));
            } else 
                g_RWUpdateRayCacheBuffer[UpdateRayIndex] = PackFp16x4(0.f.xxxx);
        }
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_ComputeCacheUpdateStep (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID             = GroupID.x + GroupID.y * g_TileDimensions.x;
    int TileBasisCount     = g_RWTileBasisCountBuffer[TileID];
    int TileSlotBaseOffset = g_RWTileBaseSlotOffsetBuffer[TileID];
    int2 TileTextureBaseOffset = int2(GroupID.x * SSRC_TILE_SIZE, GroupID.y * SSRC_TILE_SIZE);

    uint   TileUpdateRayOffset = g_RWTileRayOffsetBuffer[TileID];
    uint   TileUpdateRayCount  = g_RWTileRayCountBuffer[TileID];
    const int REPEAT = min(WAVE_RAY_SIZE, (TileUpdateRayCount + WAVE_SIZE - 1) / WAVE_SIZE);

    // Omit invalid pixels
    // Register occ: 14 x WAVE_RAY_SIZE = 56
    float3 ThreadRayDirection[WAVE_RAY_SIZE];
    float3 ThreadRayRadianceDifference[WAVE_RAY_SIZE];
    float  ThreadSumWeight[WAVE_RAY_SIZE];
    float3 ThreadRayOrigin[WAVE_RAY_SIZE];
    float  ThreadRayInvPdf[WAVE_RAY_SIZE];
    float3 ThreadWeightedSumEvaluatedRadiance[WAVE_RAY_SIZE];
    for(int i = 0; i< REPEAT; i++) {
        int TileRayRank = i * WAVE_SIZE + LocalID;
        if(TileRayRank < TileUpdateRayCount) {
            int    RayIndex = TileUpdateRayOffset + TileRayRank;
            float4 RayCache = UnpackFp16x4(g_RWUpdateRayCacheBuffer[RayIndex]);
            float3 RayDirection   = UnpackNormal(g_RWUpdateRayDirectionBuffer[RayIndex]);
            float4 RayRadiancePdf = UnpackFp16x4(g_RWUpdateRayRadiancePdfBuffer[RayIndex]);
            float3 RayRadiance    = RayRadiancePdf.xyz;
            float  RayInvPdf      = 1.f / RayRadiancePdf.w;
            int2   TexCoords      = UnpackUint16x2(g_RWUpdateRayOriginBuffer[RayIndex]);
            float2 UV = (float2(TexCoords) + 0.5f) * g_OutputDimensionsInv;
            float  Depth = g_DepthTexture.Load(int3(UV * g_OutputDimensions, 0)).x;
            float3 RayOrigin    = InverseProject(g_CameraProjViewInv, UV, Depth);
            ThreadRayDirection[i]          = RayDirection;
            ThreadWeightedSumEvaluatedRadiance[i]  = RayCache.xyz * RayCache.w;
            ThreadRayRadianceDifference[i] = RayRadiance - RayCache.xyz;
            ThreadSumWeight[i]             = RayCache.w;
            ThreadRayOrigin[i]             = RayOrigin;
            ThreadRayInvPdf[i]             = RayInvPdf;
        }
    }
    
    // The balance factor to scale the gradients by dividing the total number of rays for this tile
    float BalanceFactor = 1.f / max((float)TileUpdateRayCount, 1.f);

    // Iterate over each basis overlapping with this tile
    for(int Slot = 0; Slot < TileBasisCount; Slot ++) {
        // Thread local accumulators
        SGGradients SumStepSize   = (SGGradients)0;
        WGradients  SumStepSize_W = (WGradients)0;
        int BasisIndex = g_RWTileBasisIndexBuffer[TileSlotBaseOffset + Slot];
        SGData SG;
        WData  W;
        FetchBasisData_W(BasisIndex, SG, W);
        float3 BasisWorldPosition;
        FetchBasisLocation(BasisIndex, BasisWorldPosition);
#ifdef HEURISTIC_DIRECTION_UPDATE
        float SumContrib = 0.f;
#endif
        // Cooperatively iterate over all pixels of the grid
        for(int i = 0; i < REPEAT; i++) {
            int TileRayRank = i * WAVE_SIZE + LocalID;
            if(TileRayRank < TileUpdateRayCount) {
                // There is no bank conflict as the stride is (1 or 3) * 4 bytes for float3
                // Loading from shmem is done in 1 cycle per word
                float3 RayDirection          = ThreadRayDirection[i];
                float3 RayRadianceDifference = ThreadRayRadianceDifference[i];
                float  SumWeight             = ThreadSumWeight[i];
                float  InvSumWeight          = 1.f / SumWeight;
                float  InvPdf                = ThreadRayInvPdf[i];
                if(InvPdf > 0.f && SumWeight > 1e-6f) {

                    float3 SGEvaluatedRadiance   = EvaluateSG(SG, RayDirection);
                    float3 DeltaPosition         = ThreadRayOrigin[i] - BasisWorldPosition;
                    float  EvaluatedW            = EvaluateW(W, DeltaPosition);

                    float  RestWeight             = SumWeight - EvaluatedW;
                    float3 WeightedSumEvaluatedRadiance   = ThreadWeightedSumEvaluatedRadiance[i];
                    
                    // float3 A3 = 
                    //     (RestWeight * SGEvaluatedRadiance - (SumEvaluatedRadiance - SGEvaluatedRadiance * EvaluatedW))
                    //      / (SumWeight * SumWeight);
                    // float  A = dot(A3, 1.f.xxx);
                    float3 A3 = (SGEvaluatedRadiance * RestWeight - (WeightedSumEvaluatedRadiance - SGEvaluatedRadiance * EvaluatedW)) * (1.f / (SumWeight * SumWeight));
                    float  A  = dot(A3, 1.f.xxx);

                    // Compute gradients
                    SGGradients Gradients;
                    WGradients  Gradients_W;
                    float3 dColorExtra;
                    EvaluateSG_Gradients(SG, RayDirection, Gradients, dColorExtra);
                    Gradients.dColor += dColorExtra;
                    float3 DeltaRadiance    = RayRadianceDifference;
                    float  DeltaRadianceSum = dot(DeltaRadiance, 1.f.xxx);
                    // The weight of SG for the current shading point (SP)
                    float  SGWeightForSP    = EvaluatedW * InvSumWeight * InvPdf * BalanceFactor;
                    EvaluateW_Gradients(W, DeltaPosition, Gradients_W);
                    // Accumulate and combine gradients for optimal descending
                    // TODO adaptive learning rate based on the magnitude of the gradients
                    SumStepSize.dColor     += DeltaRadiance    * Gradients.dColor     * SGWeightForSP;
    #ifdef HEURISTIC_DIRECTION_UPDATE
                    // Approximate direction directly using the radiance difference
                    SumStepSize.dDirection += DeltaRadianceSum * RayDirection         * SGWeightForSP;
    #else
                    SumStepSize.dDirection += DeltaRadianceSum * Gradients.dDirection * SGWeightForSP;
    #endif
                    SumStepSize.dLambda    += DeltaRadianceSum * Gradients.dLambda    * SGWeightForSP;
                    // F = W / (S+W) * f, so the step size of W is calculated by the followings
                    SumStepSize_W.dLambda  += DeltaRadianceSum * A * Gradients_W.dLambda;
                    SumStepSize_W.dAlpha   += DeltaRadianceSum * A * Gradients_W.dAlpha;
    #ifdef HEURISTIC_DIRECTION_UPDATE
                    SumContrib += SGWeightForSP;
    #endif
                }
            }
        }
        // Wave reduce the gradients
        SumStepSize.dColor     = WaveActiveSum(SumStepSize.dColor);
        SumStepSize.dDirection = WaveActiveSum(SumStepSize.dDirection);
        SumStepSize.dLambda    = WaveActiveSum(SumStepSize.dLambda);
        SumStepSize_W.dLambda  = WaveActiveSum(SumStepSize_W.dLambda);
        SumStepSize_W.dAlpha   = WaveActiveSum(SumStepSize_W.dAlpha);
#ifdef HEURISTIC_DIRECTION_UPDATE
        SumContrib             = WaveActiveSum(SumContrib);
#endif
        if(WaveIsFirstLane()) {
            // Accumulate the gradients with atomic operations.
            // Note: Performance for atomic operations drops drastically when the quantlilized step buffer 
            // for accumulation overflows the L2 GPU cache (8MB for 3090). 
            // (about 1ms for 250000 basis, and 32 random basis for each tile)
            // However, if we kept some locallity in the accumulation (by processing adjacent tiles at one time), 
            // the performance is still acceptable.
            // (No L2 overflow: 200us)
#ifdef HEURISTIC_DIRECTION_UPDATE
            // Divide by total SG contribution to SPs to make adjacent SP more significant
            SumStepSize.dDirection = SumStepSize.dDirection / SumContrib;
#else
            // Here we accumulate the orthogonal gradients for the direction only
            // dColorExtra is already accumulated in the dColor
            SumStepSize.dDirection = SumStepSize.dDirection - dot(SumStepSize.dDirection, SG.Direction) * SG.Direction;
#endif
            ScreenCache_AccumulateStepSize(BasisIndex, SumStepSize, SumStepSize_W);
        }
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_NormalizeCacheUpdate (int DispatchID : SV_DispatchThreadID, int GroupID : SV_GroupID) {
    if(DispatchID >= g_RWActiveBasisCountBuffer[0]) {
        return;
    }
    uint BasisIndex = g_RWActiveBasisIndexBuffer[DispatchID];
    SGGradients Step_SG;
    WGradients  Step_W;
    // Compute the step size
    ScreenCache_GetStepSize(BasisIndex, Step_SG, Step_W);
    float Scale = 0.f;
    if(g_CacheUpdate_SGColor) {
        Scale += dot(Step_SG.dColor, Step_SG.dColor);
    }
    SGData SG;
    WData  W;
    FetchBasisData_W(BasisIndex, SG, W);
#ifndef  HEURISTIC_DIRECTION_UPDATE
    float3 Ortho = Step_SG.dDirection - dot(Step_SG.dDirection, SG.Direction) * SG.Direction;
    if(g_CacheUpdate_SGDirection) {
        Scale += dot(Ortho, Ortho);
    }
#endif
    if(g_CacheUpdate_SGLambda) {
        Scale += dot(Step_SG.dLambda, Step_SG.dLambda);
    }
    if(g_CacheUpdate_WAlpha) {
        Scale += Step_W.dAlpha * Step_W.dAlpha;
    }
    if(g_CacheUpdate_WLambda) {
        Scale += Step_W.dLambda * Step_W.dLambda;
    }
    float ScaleWave = WaveActiveSum(Scale);
    if(WaveIsFirstLane()) {
        g_RWUpdateStepScaleSumsBuffer[GroupID] = ScaleWave;
    }
}

[numthreads(1, 1, 1)]
void SSRC_NormalizeCacheUpdateSetReduceCount () {
    g_RWReduceCountBuffer[0] = (g_RWActiveBasisCountBuffer[0] + WAVE_SIZE - 1) / WAVE_SIZE;
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_ApplyCacheUpdate (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= g_RWActiveBasisCountBuffer[0]) {
        return;
    }
    uint BasisIndex = g_RWActiveBasisIndexBuffer[DispatchID];
    SGData SG;
    WData  W;
    SGGradients Step_SG;
    WGradients  Step_W;
    float3 BasisPosition;
    FetchBasisData_W(BasisIndex, SG, W);
    FetchBasisLocation(BasisIndex, BasisPosition);
    // Compute the step size
    ScreenCache_GetStepSize(BasisIndex, Step_SG, Step_W);
    float NormalizationFactor = 1000.f / sqrt(max(g_RWUpdateStepScaleBuffer[0], 1e-6f));
    // FIXME large basis is shattering the cache
    // FIXME adaptive normalization factor
    // NormalizationFactor = 1.f;
    float RandomStride = sin(DispatchID * 4.13f + g_FrameIndex * 71838.3f) * 0.5f + 0.5f;
    NormalizationFactor *= RandomStride;
    // Update the basis
    if(g_CacheUpdate_SGDirection) {
#ifndef HEURISTIC_DIRECTION_UPDATE
        float3 Ortho = Step_SG.dDirection - dot(Step_SG.dDirection, SG.Direction) * SG.Direction;
        SG.Direction += Ortho * g_CacheUpdateLearningRate * NormalizationFactor;
        SG.Direction =  lazyNormalize(SG.Direction);
#else
        float DstWeight     = length(Step_SG.dDirection);
        float3 DstDirection = Step_SG.dDirection / DstWeight;
        float SrcWeight     = dot(SG.Color, 1.f.xxx) * 10.f;
        float3 SrcDirection = SG.Direction;
        float3 Direction    = SrcDirection * SrcWeight + DstDirection * DstWeight;
        SG.Direction = lazyNormalize(Direction);
#endif
    }
    if(g_CacheUpdate_SGColor) {
        SG.Color     += Step_SG.dColor     * g_CacheUpdateLearningRate * NormalizationFactor;
        SG.Color     = max(SG.Color, 0.01f.xxx); // Color is in [0.01, inf)
    }
    if(g_CacheUpdate_SGLambda) {
        SG.Lambda    += Step_SG.dLambda    * g_CacheUpdateLearningRate * NormalizationFactor;
        SG.Lambda    = clamp(SG.Lambda, 0.85f, 12.f); // Lambda is in [0.85f, 12.f]
    }
    if(g_CacheUpdate_WAlpha) {
        W.Alpha      += Step_W.dAlpha      * g_CacheUpdateLearningRate * NormalizationFactor;
        W.Alpha      = clamp(W.Alpha, 0.02f, 0.9999f); // Alpha is in [0.02f, 1.f)
    }
    if(g_CacheUpdate_WLambda) {
        W.Lambda     += Step_W.dLambda     * g_CacheUpdateLearningRate * NormalizationFactor;
        W.Lambda     = clamp(W.Lambda, 100.f, 1e6f); // Lambda is in [1e3, 1e7]
    }
    // Write back the data
    WriteBasisData_W(BasisIndex, SG, W);
    // TODO update position
    // WriteBasisLocation(DispatchID, BasisPosition);
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_SpawnNewBasis (int3 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * g_TileDimensions.x;
    int TileBasisCount = g_RWTileBasisCountBuffer[TileID];
    if(TileBasisCount >= SSRC_MAX_BASIS_PER_TILE) {
        // Overflowed
        return ;
    }
    // Introduce blue noise spawnning pattern upon raw tiles.
    int2 MinLocation  = BlueNoise_Sample2D(GroupID.xy, g_FrameSeed) * 0.999f * SSRC_TILE_SIZE;
    uint TileMask = (MinLocation.x + MinLocation.y * SSRC_TILE_SIZE) & 0xfffu;
    // Find a pixel with minimum weight coverage
    uint MinCoveragePacked    = 0xffffffffu ^ TileMask;
    // We assume SSRC_TILE_SIZE * SSRC_TILE_SIZE is a multiple of WAVE_SIZE
    for(int Offset = 0; Offset < SSRC_TILE_SIZE * SSRC_TILE_SIZE; Offset += WAVE_SIZE) {
        int PixelIndex = Offset + LocalID;
        int PixelX = PixelIndex % SSRC_TILE_SIZE;
        int PixelY = PixelIndex / SSRC_TILE_SIZE;
        int2 TexCoords = int2(GroupID.x * SSRC_TILE_SIZE + PixelX, GroupID.y * SSRC_TILE_SIZE + PixelY);
        float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
        // Filter valid pixels
        if(Depth < 1.f) {
            float3 ViewDirection = GetCameraRayDirection(TexCoords);
            float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
            float Coverage = clamp(g_RWCacheCoverageTexture[TexCoords].x, 0.f, 15.9f).x;
            MinCoveragePacked = min(MinCoveragePacked, ((0xfffff & uint(Coverage * 0xffff)) << 12) | (uint(PixelIndex) ^ TileMask));
        }
    }
    MinCoveragePacked = WaveActiveMin(MinCoveragePacked);
    int BasisIndex = kGI10_InvalidId;
    float3 WorldPosition, SurfaceNormal;
    int2 SpawnTexCoords;
    float WLambda;
    if(WaveIsFirstLane()) {
        int2 BaseTexCoords = int2(GroupID.x * SSRC_TILE_SIZE, GroupID.y * SSRC_TILE_SIZE);
        uint MinPixelIndex = (MinCoveragePacked & 0xfff) ^ TileMask;
        float MinCoverage  = float(MinCoveragePacked >> 12) / 0xffff;
        // Pad to prevent over spawnning that overflows the tile index
        float OccupycationPadding = float(TileBasisCount) / SSRC_MAX_BASIS_PER_TILE;
        // FIXME Over Spawnning 
        MinCoverage += OccupycationPadding * OccupycationPadding * g_BasisSpawnCoverageThreshold * 4;
        // Spawn a new basis if the coverage is below the threshold
        bool ShouldSpawn = MinCoverage < g_BasisSpawnCoverageThreshold;
        if(ShouldSpawn && MinPixelIndex != 0xfff && !g_FreezeBasisAllocation) {
            // New basis is here!
            int2 PixelCoords = int2(MinPixelIndex % SSRC_TILE_SIZE, MinPixelIndex / SSRC_TILE_SIZE);
            SpawnTexCoords = BaseTexCoords + PixelCoords;
            uint BasisAllocIndex;
            InterlockedAdd(g_RWFreeBasisIndicesCountBuffer[0], -1, BasisAllocIndex);
            BasisAllocIndex = BasisAllocIndex - 1;
            if(BasisAllocIndex < 0x7fffffffu) {
                // Allocation succeeded
                BasisIndex = g_RWFreeBasisIndicesBuffer[BasisAllocIndex];
                // The last slot for each tile is reserved for the newly allocated basis
                // Inject it to the tile basis index
                g_RWTileBasisIndexBuffer[g_RWTileBaseSlotOffsetBuffer[TileID] + TileBasisCount] = BasisIndex;
                g_RWTileBasisCountBuffer[TileID] = TileBasisCount + 1;
                float2 UV = (SpawnTexCoords + 0.5f) / g_OutputDimensions;
                float  PixelDepth = g_DepthTexture.Load(int3(SpawnTexCoords, 0)).x;
                float3 PixelNormal = normalize(2.f * g_ShadingNormalTexture.Load(int3(SpawnTexCoords, 0)).xyz - 1.f);
                WorldPosition = InverseProject(g_CameraProjViewInv, UV, PixelDepth);
                float U = BlueNoise_Sample1D(GroupID.xy + int2(8271, 2983), g_FrameSeed).x;
                // Randomize radius
                float X  = GetLinearDepth(PixelDepth) * g_CameraPixelScale * g_BasisWInitialRadius;
                // FIXME
                X = X;//  * lerp(0.8f, 6.5f, U * U * U);
                WLambda = -log(g_MinWeightE) / (X * X);
                SurfaceNormal = PixelNormal;
            }
        }
    }

    BasisIndex = WaveReadLaneFirst(BasisIndex);
    // Quit the wave if no new basis is allocated
    [branch]
    if(BasisIndex == kGI10_InvalidId) return ;

    WorldPosition  = WaveReadLaneFirst(WorldPosition);
    SpawnTexCoords = WaveReadLaneFirst(SpawnTexCoords);
    SurfaceNormal  = WaveReadLaneFirst(SurfaceNormal);
    WData W = (WData)0;
    W.Lambda       = WaveReadLaneFirst(WLambda);
    W.Alpha        = 1.f;

    float  SumInitWeight    = 0.f;
    float3 SumInitRadiance  = 0.f.xxx;
    float3 SumInitDirection = 0.f.xxx;

    // Guess the SG direction with a heuristic
    uint   TileUpdateRayOffset = g_RWTileRayOffsetBuffer[TileID];
    uint   TileUpdateRayCount  = g_RWTileRayCountBuffer[TileID];
    const int REPEAT = min(WAVE_RAY_SIZE, (TileUpdateRayCount + WAVE_SIZE - 1) / WAVE_SIZE);
    for(int i = 0; i< REPEAT; i++) {
        int TileRayRank = i * WAVE_SIZE + LocalID;
        if(TileRayRank < TileUpdateRayCount) {
            int    RayIndex = TileUpdateRayOffset + TileRayRank;
            int2   TexCoords = UnpackUint16x2(g_RWUpdateRayOriginBuffer[RayIndex]);
            float  CurrentPixelDepth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
            float2 CurrentUV = (TexCoords + 0.5f) / g_OutputDimensions; 
            float3 CurrentWorldPos = InverseProject(g_CameraProjViewInv, CurrentUV, CurrentPixelDepth);
            float3 CurrentOutRayDirection  = UnpackNormal(g_RWUpdateRayDirectionBuffer[RayIndex]);
            uint2  RayCache                = g_RWUpdateRayCacheBuffer[RayIndex];
            float4 CurrentOutRayEvalWSum   = UnpackFp16x4(RayCache);
            uint2  RayRP                   = g_RWUpdateRayRadiancePdfBuffer[RayIndex];
            float4 CurrentOutRayRadiancePdf= UnpackFp16x4(RayRP);
            float3 CurrentOutRayDifference = CurrentOutRayRadiancePdf.xyz - CurrentOutRayEvalWSum.xyz;
            // Normalize probability for choosing different directions by dividing
            // ray direction pdf in sample weight averaging
            float  InvPdf = 1.f / CurrentOutRayRadiancePdf.w;
            float3 DeltaPosition = CurrentWorldPos - WorldPosition;
            // Clamp W to provide enough samples for the initial guess
            float EvaluatedW = EvaluateW(W, DeltaPosition) + 0.01f;
            // Find the direction with maximum difference (no matter positive or negative)
            float DifferenceWeight = dot(abs(CurrentOutRayDifference), 1.f.xxx);
            // Omit the direction with negative dot product with the surface normal
            if(dot(CurrentOutRayDirection, SurfaceNormal) < 0) continue ;
            SumInitDirection += CurrentOutRayDirection * DifferenceWeight * EvaluatedW * InvPdf;
        }
    }
    SumInitDirection = WaveActiveSum(SumInitDirection);
    
    SGData SG;
    if(length(SumInitDirection) != 0.f)
        SG.Direction = normalize(SumInitDirection);
    else SG.Direction = SurfaceNormal;
    // TODO better initialization of lambda
    float M      = BlueNoise_Sample1D(GroupID.xy + int2(3817, 4905), g_FrameSeed).x;
    // FIXME
    SG.Direction = SurfaceNormal;
    SG.Lambda    = 1.f;//0.85f;//lerp(0.35f, 1.2f, M);
    SG.Color     = 1.f.xxx;

    SumInitWeight = 0.f;
    // Initialize the Color of SG according to ray differences
    for(int i = 0; i< REPEAT; i++) {
        int TileRayRank = i * WAVE_SIZE + LocalID;
        if(TileRayRank < TileUpdateRayCount) {
            int    RayIndex = TileUpdateRayOffset + TileRayRank;
            int2   TexCoords = UnpackUint16x2(g_RWUpdateRayOriginBuffer[RayIndex]);
            float CurrentPixelDepth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
            float2 CurrentUV        = (TexCoords + 0.5f) * g_OutputDimensionsInv; 
            float3 CurrentWorldPos  = InverseProject(g_CameraProjViewInv, CurrentUV, CurrentPixelDepth);
            float3 CurrentOutRayDirection  = UnpackNormal(g_RWUpdateRayDirectionBuffer[RayIndex]);
            float4 RayRadiancePdf          = UnpackFp16x4(g_RWUpdateRayRadiancePdfBuffer[RayIndex]);
            float3 CurrentOutRayRadiance   = RayRadiancePdf.xyz;
            float  InvPdf                  = 1.f / RayRadiancePdf.w;
            float3 DeltaPosition = CurrentWorldPos - WorldPosition;
            // Clamp W to provide enough samples for the initial guess
            float EvaluatedW  = EvaluateW(W, DeltaPosition) + 0.01f;
            float  F          = EvaluateSG(SG, CurrentOutRayDirection).x;
            float  B          = EvaluatedW * InvPdf;
            float3 T          = CurrentOutRayRadiance;
            // Want minimize \sum B * |F * alpha - T| for alpha
            float3 BestAlpha  = T / F;
            float  DiffAlpha  = B * F;
            // Simply do an average

            SumInitWeight    += DiffAlpha;
            SumInitRadiance  += BestAlpha * DiffAlpha;
        }
    }
    SumInitWeight   = WaveActiveSum(SumInitWeight);
    SumInitRadiance = WaveActiveSum(SumInitRadiance);

    if(LocalID == 0) {
        // Fall back to 1.f.xxx if the guessing provides an invalid color
        if(SumInitWeight != 0.f) {
            SG.Color = SumInitRadiance / SumInitWeight;
        }
        // Write the basis data
        WriteBasisData_W(BasisIndex, SG, W);
        WriteBasisLocation(BasisIndex, WorldPosition);
        // Mark the basis as active
        g_RWBasisFlagsBuffer[BasisIndex] = g_FrameIndex;
    }
}

[numthreads(1, 1, 1)]
void SSRC_ClipOverAllocation () {
    if(g_RWFreeBasisIndicesCountBuffer[0] > 0x7fffffffu) {
        g_RWFreeBasisIndicesCountBuffer[0] = 0;
    }
}


groupshared uint LocalAccessedSG[SSRC_MAX_BASIS_PER_TILE];
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_IntegrateASG (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * g_TileDimensions.x;
    int TileBasisCount = g_RWTileBasisCountBuffer[TileID];
    int TileSlotBaseOffset = g_RWTileBaseSlotOffsetBuffer[TileID];
    int2 TileTextureBaseOffset = int2(GroupID) * SSRC_TILE_SIZE;

    GroupMemoryBarrierWithGroupSync();
    // Thread local compute resources
    const int PIXEL_PER_THREAD = SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE;
    float3 ThreadSumRadiance[PIXEL_PER_THREAD];
    float  ThreadSumWeight  [PIXEL_PER_THREAD];
    float3 ThreadWorldPosition[PIXEL_PER_THREAD];
    float3 ThreadGeometryNormal[PIXEL_PER_THREAD];
    float3 ThreadShadingNormal [PIXEL_PER_THREAD];
    MaterialBRDF ThreadMaterialBRDF[PIXEL_PER_THREAD];
    MaterialEmissive ThreadMaterialEmissive[PIXEL_PER_THREAD];
    for(int i = 0; i< PIXEL_PER_THREAD; i++) {
        int PixelIndex = i * WAVE_SIZE + LocalID;
        int PixelX = PixelIndex % SSRC_TILE_SIZE;
        int PixelY = PixelIndex / SSRC_TILE_SIZE;
        ThreadSumRadiance[i] = 0.f.xxx;
        ThreadSumWeight  [i] = 0.f;
        int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
        float2 UV = (TexCoords + 0.5f) / g_OutputDimensions;
        float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
        if(Depth < 1.f) {
            // Texture coordinates
            float4 Visibility   = g_VisibilityTexture[TexCoords];
            float2 Barycentrics = Visibility.xy;
            uint   InstanceID   = asuint(Visibility.z);
            uint   PrimitiveID  = asuint(Visibility.w);

            Instance InstanceData = g_InstanceBuffer[InstanceID];
            Mesh     mesh     = g_MeshBuffer[InstanceData.mesh_index];

            Triangle vertices = fetchVertices(mesh, PrimitiveID);

            // Reconstruct world space position from barycentrics
            float3x4 transform = g_TransformBuffer[InstanceData.transform_index];
            vertices.v0 = transformPoint(vertices.v0, transform);
            vertices.v1 = transformPoint(vertices.v1, transform);
            vertices.v2 = transformPoint(vertices.v2, transform);

            // Frame
            float3 WorldPosition = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);
            float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
            float3 ShadingNormal  = normalize(2.f * g_ShadingNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);

            UVs PrimitiveUVs = fetchUVs(g_MeshBuffer[InstanceData.mesh_index], PrimitiveID);
            float2 MeshUV = interpolate(PrimitiveUVs.uv0, PrimitiveUVs.uv1, PrimitiveUVs.uv2, Barycentrics);
            Material MaterialData = g_MaterialBuffer[InstanceData.material_index];
            MaterialEmissive EmissiveMaterialData = MakeMaterialEmissive(MaterialData, MeshUV);
            MaterialBRDF MaterialBRDFData = MakeMaterialBRDF(MaterialData, MeshUV);
            ThreadWorldPosition [i] = WorldPosition;
            ThreadGeometryNormal[i] = GeometryNormal;
            ThreadShadingNormal [i] = ShadingNormal;
            ThreadMaterialBRDF  [i] = MaterialBRDFData;
            ThreadMaterialEmissive [i] = EmissiveMaterialData;
        }
    }
    bool AccessedSG = false;
    // Iterate over each basis overlapping with this tile
    for(int Slot = 0; Slot < TileBasisCount; Slot ++) {
        int BasisIndex = g_RWTileBasisIndexBuffer[TileSlotBaseOffset + Slot];
        SGData SG;
        WData  W;
        FetchBasisData_W(BasisIndex, SG, W);
        float3 BasisWorldPosition;
        FetchBasisLocation(BasisIndex, BasisWorldPosition);
        // Cooperatively iterate over all pixels of the grid
        for(int i = 0; i < PIXEL_PER_THREAD; i++) {
            int PixelIndex = i * WAVE_SIZE + LocalID;
            int PixelX = PixelIndex % SSRC_TILE_SIZE;
            int PixelY = PixelIndex / SSRC_TILE_SIZE;
            float3 PixelPosition = ThreadWorldPosition[i];
            float3 ShadingNormal = ThreadShadingNormal[i];
            float3 GeometryNormal = ThreadGeometryNormal[i];
            MaterialBRDF MaterialBRDFData = ThreadMaterialBRDF[i];
            float3 ViewDirection = normalize(g_CameraPosition - PixelPosition);
            float DotNV = saturate(dot(ShadingNormal, ViewDirection));
            float3 LightDirection = SG.Direction;
            float3 ReflectionDirection = calculateGGXSpecularDirection(ShadingNormal, ViewDirection, sqrt(MaterialBRDFData.roughnessAlpha));
            float3 HalfVector = normalize(LightDirection + ViewDirection);
            float3 HalfVector_Spec = normalize(ReflectionDirection + ViewDirection);
            float dotNL = saturate(dot(LightDirection, ShadingNormal));
            float dotNV = saturate(dot(ShadingNormal, ViewDirection));
            float dotHV = saturate(dot(HalfVector, ViewDirection));
            float dotSpecHV = saturate(dot(HalfVector_Spec, ViewDirection));
            // Approximate \int D * Li with ASG
            // we use RoughnessAlpha here
            float3 GGX_D_Li_Approx = SpecularTermASGWarp(SG, ShadingNormal, MaterialBRDFData.roughnessAlphaSqr, ViewDirection);
            float3 FresnelTerm = fresnel(MaterialBRDFData.F0, dotHV);
            float  VisibilityTerm   = evaluateVisibilityGGX(MaterialBRDFData.roughnessAlphaSqr, dotNL, dotNV);
            // TODO will it be faster using lut approximation for (FresnelTerm / VisibilityTerm)?
            float3 GGXIntegrationApprox = (FresnelTerm / VisibilityTerm) * GGX_D_Li_Approx;
            float3 DiffuseCompensation = diffuseCompensationTerm(FresnelTerm, dotSpecHV);
            float3 LambertIntegration = SGDiffuseInnerProduct(SG, ShadingNormal, MaterialBRDFData.albedo)* DiffuseCompensation;
            float3 Jitter = 0.f.xxx;//BlueNoise_Sample2D(RealCoord, g_FrameIndex, 2) * 2.f - 1.f;
            float3 DeltaPosition = PixelPosition - BasisWorldPosition;
            // Pad the weight to make all pixels are shaded
            float EvaluatedW = EvaluateW(W, DeltaPosition + Jitter);
            ThreadSumRadiance[i] += (GGXIntegrationApprox + LambertIntegration) * EvaluatedW;
            ThreadSumWeight  [i] += EvaluatedW;
            if(EvaluatedW > 0) AccessedSG = true;
        }
        AccessedSG = WaveActiveAnyTrue(AccessedSG);
        if(LocalID == 0) {
            if(AccessedSG) LocalAccessedSG[Slot] = BasisIndex;
            else LocalAccessedSG[Slot] = kGI10_InvalidId;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    // Update basis decays
    for(int BaseOffset = 0; BaseOffset < TileBasisCount; BaseOffset += WAVE_SIZE) {
        int Slot = BaseOffset + LocalID;
        if(Slot < TileBasisCount) {
            uint BasisIndex = LocalAccessedSG[Slot];
            if(BasisIndex != kGI10_InvalidId) g_RWBasisFlagsBuffer[BasisIndex] = g_FrameIndex;
        }
    }
    // Write back
    for(int i = 0; i < PIXEL_PER_THREAD; i ++) {
        int PixelIndex = i * WAVE_SIZE + LocalID;
        int PixelX = PixelIndex % SSRC_TILE_SIZE;
        int PixelY = PixelIndex / SSRC_TILE_SIZE;
        // We assume WAVE_SIZE is a multiple of SSRC_TILE_SIZE, and SSRC_TILE_SIZE^2 is a multiple of WAVE_SIZE
        {
            int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
            float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
            if(Depth < 1.f) {
                float  SumWeight   = ThreadSumWeight  [i];
                float3 SumRadiance = ThreadSumRadiance[i];
                float3 Emission    = ThreadMaterialEmissive[i].emissive;
                g_RWGlobalIlluminationOutput[TexCoords] = 
                    float4(SumRadiance / SumWeight + Emission, 1.0f);
            } else {
                g_RWGlobalIlluminationOutput[TexCoords] = float4(0.f, 0.f, 0.f, 1.0f);
            }
        }
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AccumulateUpdateError (int DispatchID : SV_DispatchThreadID) {
    // >= 96 registers for each thread (meanwhile < 128)
    // anyway that's not big deal
    float ThreadErrorAccumulation[SSRC_TILE_SIZE][SSRC_TILE_SIZE];
    // Pack the weight in a half2 to save registers ( < 128 )
    uint ThreadErrorAccumulationWeightPacked[SSRC_TILE_SIZE][SSRC_TILE_SIZE / 2];
    for(int i = 0; i<SSRC_TILE_SIZE; i++) 
        for(int j = 0; j<SSRC_TILE_SIZE; j++) {
            ThreadErrorAccumulation[i][j] = 0;
        }
    for(int i = 0; i<SSRC_TILE_SIZE; i++) 
        for(int j = 0; j<SSRC_TILE_SIZE/2; j++) {
            ThreadErrorAccumulationWeightPacked[i][j] = packHalf2(float2(0.f, 0.f));
        }
    int2 TileCoords = int2(DispatchID % g_TileDimensions.x, DispatchID / g_TileDimensions.x);
    int2 TexOffset = TileCoords * SSRC_TILE_SIZE;
    int TileID = DispatchID;
    int TileRayCount = g_RWTileRayCountBuffer[TileID];
    int TileRayOffset = g_RWTileRayOffsetBuffer[TileID];
    for(int TileRayRank = 0; TileRayRank < TileRayCount; TileRayRank++) {
        int RayIndex = TileRayOffset + TileRayRank;
        int2 TexCoords  = UnpackUint16x2(g_RWUpdateRayOriginBuffer[RayIndex]);
        float3 Eval     = UnpackFp16x3(g_RWUpdateRayCacheBuffer[RayIndex]);
        float4 RadiancePdf = UnpackFp16x4(g_RWUpdateRayRadiancePdfBuffer[RayIndex]);
        if(RadiancePdf.w > 0) {
            float3 Error    = RadiancePdf.xyz - Eval;
            float  InvPdf   = 1.f / RadiancePdf.w;
            float  Contrib  = (dot(Error, Error) / max(dot(Eval, 1.f.xxx), 0.01f)) * InvPdf;
            // Accumulate the error
            int2  PixelCoords = TexCoords - TexOffset;
            ThreadErrorAccumulation[PixelCoords.y][PixelCoords.x] += Contrib;
            float2 Unpacked    = unpackHalf2(ThreadErrorAccumulationWeightPacked[PixelCoords.y][PixelCoords.x / 2]);
            if(PixelCoords.x % 2 == 0) {
                Unpacked.x += InvPdf;
            } else {
                Unpacked.y += InvPdf;
            }
            ThreadErrorAccumulationWeightPacked[PixelCoords.y][PixelCoords.x / 2] = packHalf2(Unpacked);
        }
    }
    for(int j = 0; j<SSRC_TILE_SIZE; j++) {
        for(int i = 0; i<SSRC_TILE_SIZE; i++) {
            int2 TexCoords = TexOffset + int2(i, j);
            float Error = ThreadErrorAccumulation[j][i];
            uint WeightPacked = ThreadErrorAccumulationWeightPacked[j][i / 2];
            float2 W2 = unpackHalf2(WeightPacked);
            float Weight = i % 2 == 0 ? W2.x : W2.y;
            float PrevError = g_RWUpdateErrorSplatTexture[TexCoords];
            if(Weight > 0 && !isnan(Error)) {
                g_RWUpdateErrorSplatTexture[TexCoords] = lerp(PrevError, Error / Weight, 0.1f);
            } else {
                g_RWUpdateErrorSplatTexture[TexCoords] = lerp(PrevError, 0.f,  0.1f);
            }
        }
    }
}

[numthreads(8, 8, 1)]
void DebugSSRC_VisualizeCoverage (uint2 DispatchID : SV_DispatchThreadID) {
    if(any(DispatchID >= g_OutputDimensions)) {
        return;
    }
    float Depth = g_DepthTexture.Load(int3(DispatchID, 0)).x;
    if(Depth < 1.f) {
        g_RWDebugOutput[DispatchID] = g_RWCacheCoverageTexture[DispatchID].x;
    } else {
        g_RWDebugOutput[DispatchID] = 0.f;
    }
}

[numthreads(SSRC_TILE_SIZE, SSRC_TILE_SIZE, 1)]
void DebugSSRC_VisualizeTileOccupancy (uint2 DispatchID : SV_DispatchThreadID, uint2 GroupID : SV_GroupID, uint2 LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * g_TileDimensions.x;
    [branch]
    if(g_DebugVisualizeMode == 0) {
        // Write the color heatmap
        int TileBasisCount = g_RWTileBasisCountBuffer[TileID];
        float h = float(TileBasisCount) / float(SSRC_MAX_BASIS_PER_TILE);
        float3 Color = ColorHeatMap(h);
        // Blinking effect for the overflowed tiles
        if(TileBasisCount >= 64) {
            Color = g_FrameIndex%10 < 5 ? 1.f.xxx : 0.f.xxx;
        }
        g_RWDebugOutput[DispatchID] = float4(Color, 1.f);
    } else if(g_DebugVisualizeMode == 1) {
        int TileBasisCount = g_RWTileBasisCountBuffer[TileID];
        int LocalRank = LocalID.x + LocalID.y * SSRC_TILE_SIZE;
        if(LocalRank < TileBasisCount) {
            int BasisIndex = g_RWTileBasisIndexBuffer[g_RWTileBaseSlotOffsetBuffer[TileID] + LocalRank];
            float3 BasisWorldPosition;
            FetchBasisLocation(BasisIndex, BasisWorldPosition);
            g_RWDebugOutput[DispatchID] = 1.f.xxxx;
        } else {
            g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 1.f);
        }
    } else if(g_DebugVisualizeMode == 2) {
                int TileBasisCount = g_RWTileBasisCountBuffer[TileID];
        int LocalRank = LocalID.x + LocalID.y * SSRC_TILE_SIZE;
        if(LocalRank < TileBasisCount) {
            int BasisIndex = g_RWTileBasisIndexBuffer[g_RWTileBaseSlotOffsetBuffer[TileID] + LocalRank];
            float3 BasisWorldPosition;
            FetchBasisLocation(BasisIndex, BasisWorldPosition);
            g_RWDebugOutput[DispatchID] = float4(BasisWorldPosition, 1.f);
        } else {
            g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 1.f);
        }
    }
}

[numthreads(8, 8, 1)]
void DebugSSRC_ShowDifference (uint2 DispatchID : SV_DispatchThreadID) {
    if(any(DispatchID >= g_OutputDimensions)) {
        return;
    }
    if(g_DebugVisualizeMode == 0) {
        float Depth = g_DepthTexture.Load(int3(DispatchID, 0)).x;
        if(Depth < 1.f) {
            float2 UV = (DispatchID + 0.5f.xx) / g_OutputDimensions;
            float Difference = g_UpdateErrorSplatTexture.SampleLevel(g_LinearSampler, UV, ERROR_BLUR_LOD).x;
            g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(Difference * g_DebugTonemapExposure), 1.f);
        } else {
            g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
        }
    } else if(g_DebugVisualizeMode == 1) {
        int2 TileCoords = DispatchID / SSRC_TILE_SIZE;
        int TileID = TileCoords.x + TileCoords.y * g_TileDimensions.x;
        int TileRayCount = g_RWTileRayCountBuffer[TileID];
        if(TileRayCount == 0) {
            g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
        } else {
            g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(TileRayCount / 128.f), 1.f);
        }
    } else if(g_DebugVisualizeMode == 2) {
        float Depth = g_DepthTexture.Load(int3(DispatchID, 0)).x;
        if(Depth < 1.f) {
            float Difference = g_UpdateErrorSplatTexture.Load(int3(DispatchID, 0)).x;
            g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(Difference * g_DebugTonemapExposure), 1.f);
        } else {
            g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
        }
    }
}

// ***********************************************
// *                 Misc                        *
// ***********************************************

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_Reset (uint DispatchID : SV_DispatchThreadID) {
    if(DispatchID == 0) {
        g_RWFreeBasisIndicesCountBuffer[0] = g_MaxBasisCount;
    }
    if(DispatchID < g_MaxBasisCount) {
        g_RWFreeBasisIndicesBuffer[DispatchID] = DispatchID;
        g_RWBasisFlagsBuffer[DispatchID] = g_FrameIndex - BASIS_RETIRE_FRAME_COUNT;
    }
}

[numthreads(1, 1, 1)]
void DebugSSRC_GenerateDrawIndexed (uint DispatchID : SV_DispatchThreadID) {
    DrawIndexedCommand draw_command;
    draw_command.index_count_per_instance = 3;
    draw_command.instance_count  = g_RWActiveBasisCountBuffer[0];
    draw_command.index_offset    = 0;
    draw_command.vertex_offset   = 0;
    draw_command.instance_offset = 0;
    g_RWDrawIndexedCommandBuffer[0] = draw_command;
}

[numthreads(1, 1, 1)]
void DebugSSRC_FetchCursorPos (uint DipspatchID : SV_DispatchThreadID) {
    float4 Visibility = g_VisibilityTexture.Load(int3(g_DebugCursorPixelCoords, 0));
    float2 Barycentrics = Visibility.xy;
    uint InstanceID = asuint(Visibility.z);
    uint PrimitiveID = asuint(Visibility.w);
    Instance InstanceData = g_InstanceBuffer[InstanceID];
    Mesh mesh = g_MeshBuffer[InstanceData.mesh_index];
    Triangle vertices = fetchVertices(mesh, PrimitiveID);
    float3x4 transform = g_TransformBuffer[InstanceData.transform_index];
    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);
    float3 WorldPosition = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);
    g_RWDebugCursorWorldPosBuffer[0] = WorldPosition;
}

[numthreads(WAVE_SIZE, 1, 1)]
void DebugSSRC_PrecomputeIncidentRadiance (uint DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= g_DebugVisualizeIncidentRadianceNumPoints) {
        return;
    }
    if(DispatchID == 0) {
        // 3 channel sum
        g_RWReduceCountBuffer[0] = g_DebugVisualizeIncidentRadianceNumPoints * 3;
    }
    float3 Direction      = FibonacciSphere(DispatchID, g_DebugVisualizeIncidentRadianceNumPoints);
    float3 DebugWorldPos  = g_RWDebugCursorWorldPosBuffer[0];
    float3 Homogeneous    = transformPointProjection(DebugWorldPos, g_CameraProjView);
    float2 UV             = NDC22UV(Homogeneous.xy);
    int2   TexCoords      = int2(UV * g_OutputDimensions);
    int2   TileCoords     = int2(TexCoords.x / SSRC_TILE_SIZE, TexCoords.y / SSRC_TILE_SIZE);
    int    TileID         = TileCoords.x + TileCoords.y * g_TileDimensions.x;
    int    TileBasisCount = g_RWTileBasisCountBuffer[TileID];
    int    TileBasisOffset= g_RWTileBaseSlotOffsetBuffer[TileID];
    float3 SumRadiance = 0.f.xxx;
    float  SumWeight   = 0.f;
    for(int i = 0; i < TileBasisCount; i++) {
        int BasisIndex = g_RWTileBasisIndexBuffer[TileBasisOffset + i];
        SGData SG;
        WData  W;
        FetchBasisData_W(BasisIndex, SG, W);
        float3 BasisWorldPosition;
        FetchBasisLocation(BasisIndex, BasisWorldPosition);
        float3 DeltaPosition = BasisWorldPosition - DebugWorldPos;
        float  EvaluatedW    = EvaluateW(W, DeltaPosition);
        float3 EvaluatedSG   = EvaluateSG(SG, Direction);
        SumRadiance += EvaluatedSG * EvaluatedW;
        SumWeight   += EvaluatedW;
    }
    if(SumWeight > 0) {
        g_RWDebugVisualizeIncidentRadianceBuffer[DispatchID] = SumRadiance / SumWeight;
    } else {
        g_RWDebugVisualizeIncidentRadianceBuffer[DispatchID] = 0.f.xxx;
    }
}

[numthreads(1, 1, 1)]
void DebugSSRC_PrepareUpdateRays () {
    int2   TexCoords      = g_DebugCursorPixelCoords;
    int2   TileCoords     = int2(TexCoords.x / SSRC_TILE_SIZE, TexCoords.y / SSRC_TILE_SIZE);
    int    TileID         = TileCoords.x + TileCoords.y * g_TileDimensions.x;
    DrawCommand draw_command = (DrawCommand)0;
    draw_command.vertex_count_per_instance = 2;
    draw_command.instance_count  = g_RWTileRayCountBuffer[TileID];
    draw_command.vertex_offset   = 0;
    draw_command.instance_offset = 0;
    g_RWDrawCommandBuffer[0] = draw_command;
}


// New line required for termination.
