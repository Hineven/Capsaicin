#ifndef USE_INLINE_RT
#define USE_INLINE_RT 1
#endif

#ifndef WAVE_SIZE
// NVIDIA's default warp size
#define WAVE_SIZE 32
#endif

#define MIN_COLOR 0.000001f

// Shared structs among CPU and GPU
#include "../../gpu_shared.h"

// Parameters & Globals & Helper functions
#include "migi_inc.hlsl"

// Library for MIGI
#include "migi_lib.hlsl"
#include "migi_probes.hlsl"
#include "migi_worldcache.hlsl"

#define MAX_HIT_DISTANCE 1e9f

struct MIGI_CacheUpdatePayload
{
    float3 sky_sample;
    float hit_dist;
};

struct PopulateCellsPayload
{
    uint      query_index;
    float3    world;
    float3    normal;
    float3    lighting;
    Reservoir reservoir;
};

struct TraceReflectionsPayload
{
    int2   full_pos;
    float3 radiance;
    float2 s;
    float  hit_distance;
};


// A naive kernel for generating dispatch commands
[numthreads(1, 1, 1)]
void GenerateDispatch()
{
    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = (g_CountBuffer[0] + g_GroupSize - 1) / g_GroupSize;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

[numthreads(1, 1, 1)]
void GenerateDispatchRays()
{
    DispatchRaysCommand dispatch_rays_command;
    dispatch_rays_command.ray_generation_shader_record = RayTracing.ray_generation_shader_record;
    dispatch_rays_command.miss_shader_table = RayTracing.miss_shader_table;
    dispatch_rays_command.hit_group_table = RayTracing.hit_group_table;
    dispatch_rays_command.callable_shader_table = RayTracing.callable_shader_table;
    dispatch_rays_command.width = g_CountBuffer[0];
    dispatch_rays_command.height = 1;
    dispatch_rays_command.depth = 1;
    dispatch_rays_command.padding[0] = 0;
    dispatch_rays_command.padding[1] = 0;
    dispatch_rays_command.padding[2] = 0;
    g_RWDispatchRaysCommandBuffer[0] = dispatch_rays_command;
}

[numthreads(WAVE_SIZE, 1, 1)]
void WorldCache_Reset (uint DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= WorldCache.NumProbes) return ;
    if(DispatchID == 0) {
        g_RWWorldCacheActiveProbeCountBuffer[0] = 0;
    }
    g_RWWorldCacheFreeProbeIndexBuffer[DispatchID] = WorldCache.NumProbes - DispatchID - 1;

    WorldCacheProbeHeader Header = WorldCache_GetProbeHeader(DispatchID);
    // Mark as recycled
    WorldCache_WriteProbeScore(DispatchID, 0);
}

[numthreads(1, 1, 1)]
void WorldCache_ResetCounters () {
    // No need to reset this (it controls the freelist)
    // g_RWWorldCacheActiveProbeCountBuffer[0] = 0;
}

[numthreads(1, 1, 1)]
void WorldCache_WriteSpawnDispatchParameters () {
    DispatchCommand Command = (DispatchCommand)0;
    Command.num_groups_x = g_RWWorldCacheProbeSpawnRequestCountBuffer[0];
    Command.num_groups_y = 1;
    Command.num_groups_z = 1;
    g_RWWCSDispatchCommandBuffer[0] = Command;

    Command.num_groups_x = (g_RWWorldCacheProbeSpawnRequestCountBuffer[0] + WAVE_SIZE - 1) / WAVE_SIZE;
    Command.num_groups_y = 1;
    Command.num_groups_z = 1;
    g_RWPerLaneWCSDispatchCommandBuffer[0] = Command;
}

// Spawn probes that are requested in the last frame.
// NOTE: doing delayed allocation may cause artifacts when shading directly with the world cache.
// We use the temporal denoising to mitigate the artifacts. Pixels with missing lighting will be 
// filled with the previous frame's data or quickly discarded.
[numthreads(WAVE_SIZE, 1, 1)]
void WorldCache_SpawnProbes (uint GroupID : SV_GroupID, uint LocalID : SV_GroupThreadID) {
    if(GroupID >= g_RWWorldCacheProbeSpawnRequestCountBuffer[0]) return ;
    int SpawnRequestIndex = GroupID;
    WorldCacheProbeSpawnRequest Request = WorldCache_GetProbeSpawnRequest(SpawnRequestIndex);
    int4 GridCoords = Request.GridCoords;

    int  CascadeIndex = GridCoords.w;
    uint ProbeIndex = 0xffffffffu;
    if(WaveIsFirstLane()) ProbeIndex = WorldCache_AllocateProbe();
    ProbeIndex = WaveReadLaneFirst(ProbeIndex);
    if(WorldCache_IsProbeIndexValid(ProbeIndex)) {
        // Successful allocation
        WorldCacheProbeHeader Header = (WorldCacheProbeHeader)0;
        Header.GridCoords = GridCoords;
        Header.Score = WorldCache.ProbeInitialScore;
        Header.bActive = true;
        Header.GridInternalNormalizedPosition = 0;
        if(WaveIsFirstLane()) {
            WorldCache_WriteProbeHeader(ProbeIndex, Header);
        }
        Header.WorldPosition = WorldCache_GetProbeWorldCenterFromGridCoords(GridCoords, true);

        // Cooperatively initialize the probe data using the previous frame's data
        WorldCacheSample Sample = WorldCache_SampleProbes(
            Header.WorldPosition, Header.WorldPosition, 0, 
            MI.CameraFar, true, true, false
        );
#define TEXEL_COUNT (WORLD_CACHE_PROBE_RESOLUTION * WORLD_CACHE_PROBE_RESOLUTION)
#define LOOP ((TEXEL_COUNT + WAVE_SIZE - 1) / WAVE_SIZE)

        float4 ThreadLocalDataSum0[LOOP];
        float2 ThreadLocalDataSum1[LOOP];
        for(int i = 0; i < LOOP; i++) {
            ThreadLocalDataSum0[i] = 0;
            ThreadLocalDataSum1[i] = 0;
        }
        for(int i = 0; i < 8; i++) {
            if(WorldCache_IsProbeIndexValid(Sample.ProbeIndex[i]) && Sample.Weights[i] > 0) {
                int2 Offset = WorldCache_GetProbeAtlasBase(Sample.ProbeIndex[i]);
                WorldCacheProbeHeader SrcHeader = WorldCache_GetProbeHeader(Sample.ProbeIndex[i]);
                float3 V = SrcHeader.WorldPosition - Header.WorldPosition;
                for(int BaseTexelIndex = 0; BaseTexelIndex < TEXEL_COUNT; BaseTexelIndex += WAVE_SIZE) {
                    int TexelIndex = BaseTexelIndex + LocalID;
                    int2 TexelCoords = int2(TexelIndex % WORLD_CACHE_PROBE_RESOLUTION, TexelIndex / WORLD_CACHE_PROBE_RESOLUTION);
                    float2 TexelUV   = (TexelCoords + 0.5f) / WORLD_CACHE_PROBE_RESOLUTION;
                    float3 Direction = OctahedronToUnitVector01(TexelUV);
                    float4 Data0 = g_RWWorldCacheIrradiance2PLuminanceTexture[TexelCoords + Offset];
                    float2 Data1 = g_RWWorldCacheMomentumTexture[TexelCoords + Offset];
                    float  DeltaDistance =  dot(V, Direction);
                    Data1.y += DeltaDistance * DeltaDistance + 2.f * Data1.x * DeltaDistance;
                    Data1.x += DeltaDistance;
                    Data1 = max(Data1, 0);
                    int Loop = BaseTexelIndex / WAVE_SIZE;
                    ThreadLocalDataSum0[Loop] += Data0 * Sample.Weights[i];
                    ThreadLocalDataSum1[Loop] += Data1 * Sample.Weights[i];
                }
            }
        }
        // Write back
        for(int BaseTexelIndex = 0; BaseTexelIndex < TEXEL_COUNT; BaseTexelIndex += WAVE_SIZE) {
            int TexelIndex = BaseTexelIndex + LocalID;
            int2 TexelCoords = int2(TexelIndex % WORLD_CACHE_PROBE_RESOLUTION, TexelIndex / WORLD_CACHE_PROBE_RESOLUTION);
            int2 Offset = WorldCache_GetProbeAtlasBase(ProbeIndex);
            g_RWWorldCacheIrradiance2PLuminanceTexture[TexelCoords + Offset]
                = ThreadLocalDataSum0[BaseTexelIndex / WAVE_SIZE];
            g_RWWorldCacheMomentumTexture[TexelCoords + Offset]
                = ThreadLocalDataSum1[BaseTexelIndex / WAVE_SIZE];
        }
#undef LOOP
#undef TEXEL_COUNT
    }
}

// Decay probe scores and recycle probes that are no longer useful.
// Also, relocate probes grid coords to their appropriate clipmap levels when rolling.
groupshared uint LocalNumProbesToRecycle_WorldCache;
groupshared uint LocalProbeToRecycleIndices_WorldCache[WAVE_SIZE];
[numthreads(WAVE_SIZE, 1, 1)]
void WorldCache_RecycleProbes (uint DispatchID : SV_DispatchThreadID, uint LocalID : SV_GroupThreadID) {
    if(DispatchID >= WorldCache.NumProbes) return ;
    if(WaveIsFirstLane()) {
        LocalNumProbesToRecycle_WorldCache = 0;
    }

    GroupMemoryBarrierWithGroupSync();
    uint ProbeIndex = DispatchID;
    WorldCacheProbeHeader Header = WorldCache_GetProbeHeader(ProbeIndex);
    if(Header.bActive) {
        bool IsProbeTouched = g_RWWorldCacheProbeTouchBuffer[ProbeIndex] != 0;
        if(IsProbeTouched) {
            Header.Score = min(Header.Score + WorldCache.ProbeScoreBonus, WorldCache.ProbeInitialScore);
        } else Header.Score -= WorldCache.ProbeScoreDecay;

        g_RWWorldCacheProbeTouchBuffer[ProbeIndex] = 0;

        // Recycle unused probes.
        bool bShouldRecycleProbe = Header.Score <= 0;
        int4 GridCoords = Header.GridCoords;
        // Roll cascades. Update the probe grid coords.
        // The rolled coords lies on the grid coordinate system of the previous frame.
        GridCoords.xyz -= WorldCache.CascadeRolling[GridCoords.w].xyz;
        

        if(WorldCache_IsProbeCoordsOutOfBounds(GridCoords)) {
            // Try to fade out the probe by rolling it to higher level clipmaps
            [unroll(MIGI_WORLDCACHE_MAX_CLIPMAP_CASCADES - 1)]
            while(GridCoords.w < WorldCache.MaxClipmapCascades - 1 && WorldCache_IsProbeCoordsOutOfBounds(GridCoords)) {
                int3 AbsLevelCoords = GridCoords.xyz + WorldCache.VolumeCascadeGridCoordOffsets[GridCoords.w].xyz;
                if(all((AbsLevelCoords & 1) == 0)) {
                    int4 HigherLevelGridCoords = int4(
                        (AbsLevelCoords >> 1) - WorldCache.VolumeCascadeGridCoordOffsets[GridCoords.w + 1].xyz,
                        GridCoords.w + 1
                    );
                    GridCoords = HigherLevelGridCoords;
                } else break; // Failed
            } ;
            if(WorldCache_IsProbeCoordsOutOfBounds(GridCoords)) {
                // Failed, recycle it.
                bShouldRecycleProbe = true;
            }
        } else if(WorldCache_IsProbeCoordsOverlapped(GridCoords)) {
            // Try to descend the probe to lower level clipmaps
            [unroll(MIGI_WORLDCACHE_MAX_CLIPMAP_CASCADES - 1)]
            do {
                int3 AbsLevelCoords = GridCoords.xyz + WorldCache.VolumeCascadeGridCoordOffsets[GridCoords.w].xyz;
                int4 LowerLevelGridCoords = int4(
                    (AbsLevelCoords << 1) - WorldCache.VolumeCascadeGridCoordOffsets[GridCoords.w - 1].xyz,
                    GridCoords.w - 1
                );
                GridCoords = LowerLevelGridCoords;
            } while(GridCoords.w > 0 && WorldCache_IsProbeCoordsOverlapped(GridCoords));
            if(WorldCache_IsProbeCoordsOutOfBounds(GridCoords)) {
                // Failed, recycle it.
                bShouldRecycleProbe = true;
            }
        }
        if(bShouldRecycleProbe) {
            WorldCache_RecycleProbe(ProbeIndex);
        }
        // Update the probe header
        int Multiplier = 1u << (WorldCache.MaxClipmapCascades - GridCoords.w - 1);
        Header.GridCoords = GridCoords;
        // Sometimes we want to retract the recycling of a probe though it's score is 0 already.
        Header.Score = bShouldRecycleProbe ? 0 : max(Header.Score, 1);

        // Write back
        WorldCache_WriteProbeHeader(ProbeIndex, Header);

        // Record the probe index to recycle
        if(bShouldRecycleProbe) {
            int LocalIndex;
            InterlockedAdd(LocalNumProbesToRecycle_WorldCache, 1, LocalIndex);
            LocalProbeToRecycleIndices_WorldCache[LocalIndex] = ProbeIndex;
        }
    }
    
    // Clear probe atlas data
    GroupMemoryBarrierWithGroupSync();
    int NumProbesToRecycle = LocalNumProbesToRecycle_WorldCache;
    [unroll(WAVE_SIZE)]
    for(int i = 0; i < NumProbesToRecycle; i++) {
        int2 Offset = WorldCache_GetProbeAtlasBase(LocalProbeToRecycleIndices_WorldCache[i]);
        for(int BaseTexelIndex = 0; 
            BaseTexelIndex < WORLD_CACHE_PROBE_RESOLUTION * WORLD_CACHE_PROBE_RESOLUTION;
            BaseTexelIndex += WAVE_SIZE) {
            int TexelIndex = BaseTexelIndex + LocalID;
            int2 TexCoords = int2(TexelIndex % WORLD_CACHE_PROBE_RESOLUTION, TexelIndex / WORLD_CACHE_PROBE_RESOLUTION);
            g_RWWorldCacheIrradiance2PLuminanceTexture[TexCoords + Offset] = 0;
            g_RWWorldCacheMomentumTexture[TexCoords + Offset] = 0;
        }
    }
}

[numthreads(8, 8, 1)]
void WorldCache_ClearClipmaps (int2 DispatchID : SV_DispatchThreadID, int3 GroupID : SV_GroupID) {
    if(all(DispatchID == 0) && GroupID.z == 0) {
        // Clear the active probe count for next pass's recreation of the active list
        g_RWWorldCacheActiveProbeCountBuffer[0] = 0;
    }
    if(any(DispatchID.xy >= WorldCache.GridCoordsBound)) return ;
    int Layer = GroupID.z;
    [unroll(MIGI_WORLDCACHE_MAX_CLIPMAP_CASCADES)]
    for(int Cascade = 0; Cascade < WorldCache.MaxClipmapCascades; Cascade++) {
        g_RWWorldCacheProbeIndexTexture[Cascade][int3(Layer, DispatchID)] = 0xffffffffu;
    }
}

groupshared int LocalProbeIndex_WorldCache[WAVE_SIZE];
groupshared int LocalProbeIndexCount_WorldCache;
// Enumerate probes , respawn the active list & clipmap index
[numthreads(WAVE_SIZE, 1, 1)]
void WorldCache_UpdateActiveListAndIndex (uint DispatchID : SV_DispatchThreadID, uint LocalID : SV_GroupThreadID) {
    if(DispatchID >= WorldCache.NumProbes) return ;
    if(WaveIsFirstLane()) {
        LocalProbeIndexCount_WorldCache = 0;
    }

    GroupMemoryBarrierWithGroupSync();
    uint ProbeIndex = DispatchID;
    WorldCacheProbeHeader Header = WorldCache_GetProbeHeader(ProbeIndex);
    if(Header.bActive) {
        int LocalIndex;
        InterlockedAdd(LocalProbeIndexCount_WorldCache, 1, LocalIndex);
        LocalProbeIndex_WorldCache[LocalIndex] = ProbeIndex;

        // Inject to clipmaps
        int4 GridCoords = Header.GridCoords;
        WorldCache_WriteProbeIndexToGrid(GridCoords, ProbeIndex);

        int3 AbsCoords = GridCoords.xyz + WorldCache.VolumeCascadeGridCoordOffsets[GridCoords.w].xyz;
        if(GridCoords.w < WorldCache.MaxClipmapCascades - 1) {
            if(all((AbsCoords & 1) == 0)) {
                int4 HigherLevelGridCoords = int4(
                    (AbsCoords >> 1) - WorldCache.VolumeCascadeGridCoordOffsets[GridCoords.w + 1].xyz,
                    GridCoords.w + 1
                );
                // Also inject the probe to higher level clipmaps if it's just in the right location.
                if(!WorldCache_IsProbeCoordsOutOfBounds(HigherLevelGridCoords)) {
                    WorldCache_WriteProbeIndexToGrid(HigherLevelGridCoords, ProbeIndex);
                }
                // It's impossible for a probe to exist in more than 2 clipmap layers.
                // So we don't need to check 2 level higher clipmaps.
            }
        } 
    }

    GroupMemoryBarrierWithGroupSync();
    int ActiveListBaseOffset = 0;
    if(WaveIsFirstLane()) {
        // Update the active list
        InterlockedAdd(g_RWWorldCacheActiveProbeCountBuffer[0], LocalProbeIndexCount_WorldCache, ActiveListBaseOffset);
    }
    ActiveListBaseOffset = WaveReadLaneFirst(ActiveListBaseOffset);

    GroupMemoryBarrierWithGroupSync();
    if(LocalID < LocalProbeIndexCount_WorldCache) {
        g_RWWorldCacheActiveProbeIndexBuffer[ActiveListBaseOffset + LocalID] = LocalProbeIndex_WorldCache[LocalID];
    }
}

// Clear counters
[numthreads(1, 1, 1)] 
void WorldCache_ClipCounters () {    
    // Calling AllocateProbe too many times may overflow the counter.
    g_RWWorldCacheActiveProbeCountBuffer[0] = min(g_RWWorldCacheActiveProbeCountBuffer[0], WorldCache.NumProbes);
    // Clear spawn requests (from last frame)
    g_RWWorldCacheProbeSpawnRequestCountBuffer[0] = 0;
}

// Clear the counters at the beginging of the frame
[numthreads(1, 1, 1)]
void SSRC_ClearCounters() {
    g_RWAdaptiveProbeCountBuffer[0]    = 0;
    g_RWAllocatedProbeSGCountBuffer[0] = 0;
}

float3 GetProbeOffsetAdaptiveNormal (int2 ScreenCoords, float3 GeometryNormal, float3 ViewDirection) {
    float3 AdaptiveNormal = GeometryNormal;//normalize(ViewDirection + GeometryNormal);
#if true
    // Fine-tune the normal to bent normal when close to occluded regions
    float4 BentNormalOcc  = g_BentNormalAndOcclusionTexture.Load(int3(ScreenCoords, 0));
    float  Occlusion      = BentNormalOcc.w;
    float3 BentNormal     = BentNormalOcc.xyz * 2 - 1;
    AdaptiveNormal = normalize(lerp(BentNormal, AdaptiveNormal, saturate(1.5 * Occlusion * Occlusion)));
#endif
    return AdaptiveNormal;
}

float3 RecoverWorldPosition (float2 UV, float LinearDepth) {
    float2 NDC2 = UV2NDC2(UV);
    return LinearDepth * (NDC2.x * MI.CameraRight + NDC2.y * MI.CameraUp + MI.CameraDirection) + MI.CameraPosition;
}

float3 RecoverScreenProbePosition (int2 TileCoords, float LinearDepth, bool bPrevious) {
    // We are using the camera coordinate system to recover probe position, which is placed with G-Buffer samples
    // We need to take care of the jittering as the camera coordinate system is not affected by TAA (but the G-Buffer is). 
    // TODO The way using TAA jitter here may be incorrect (subtraction / addition ?)
    float2 UV = GetUniformScreenProbeScreenUV(TileCoords, bPrevious) + (bPrevious ? MI.PreviousTAAJitterUV : MI.TAAJitterUV);
    float2 NDC2 = UV2NDC2(UV);
    if(!bPrevious) {
        return LinearDepth * (NDC2.x * MI.CameraRight + NDC2.y * MI.CameraUp + MI.CameraDirection) + MI.CameraPosition;
    } else {
        return LinearDepth * (NDC2.x * MI.PreviousCameraRight + NDC2.y * MI.PreviousCameraUp + MI.PreviousCameraDirection) + MI.PreviousCameraPosition;
    }
}

// Allocate fixed uniform probes for current frame
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateUniformProbes (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID > MI.UniformScreenProbeCount) {
        return;
    }
    int2 ProbeIndex = int2(DispatchID % MI.TileDimensions.x, DispatchID / MI.TileDimensions.x);
    ProbeHeader Header;
    Header.ScreenCoords = GetUniformScreenProbeScreenCoords(ProbeIndex);
    float Depth             = g_DepthTexture.Load(int3(Header.ScreenCoords, 0)).x;
    bool  bValid            = Depth < 1.f;
    if(bValid) Header.Class  = ComputeProbeRankFromSplattedError(Header.ScreenCoords);
    int BasisCount      = bValid ? GetProbeBasisCountFromClass(Header.Class) : 0;
    int BasisOffset     = WavePrefixSum(BasisCount);
    int BasisCountSum   = WaveActiveSum(BasisCount);
    int BasisGroupOffset;
    if(WaveIsFirstLane()) {
        InterlockedAdd(g_RWAllocatedProbeSGCountBuffer[0], BasisCountSum, BasisGroupOffset);
    }
    BasisGroupOffset = WaveReadLaneFirst(BasisGroupOffset);
    Header.BasisOffset   = BasisGroupOffset + BasisOffset;
    // Clip over the maximum basis count
    if(Header.BasisOffset + BasisCount > MI.MaxBasisCount) {
        Header.Class = 0;
    }

    // Negative depths stands for invalid probes
    Header.LinearDepth   = (bValid ? 1 : -1) * GetLinearDepth(Depth);
    // High resolution recovery for accurate probe placement (otherwise may cause artifacts because of inaccurate occlusions)
    float3 WorldPosition  = RecoverWorldPositionHiRes(Header.ScreenCoords);
    // Offset the probe along adaptive "normal".
    float3 GeometryNormal = normalize(g_GeometryNormalTexture.Load(int3(Header.ScreenCoords, 0)).xyz * 2.f - 1.f);
    float3 ViewDirection  = normalize(MI.CameraPosition - WorldPosition);
    float3 AdaptiveNormal = GetProbeOffsetAdaptiveNormal(Header.ScreenCoords, GeometryNormal, ViewDirection);
    float3 ProbePositionOffset = AdaptiveNormal * Header.LinearDepth * SSRC_PROBE_NORMAL_OFFSET;
    Header.Position      = WorldPosition + ProbePositionOffset;
    Header.Normal        = GeometryNormal;
    WriteScreenProbeHeader(ProbeIndex, Header);

    // Also, clear the tile adaptive probe count for later adaptive allocation
    g_RWTileAdaptiveProbeCountTexture[ProbeIndex] = 0;
}

void CalculateSSRCSampleWeightsForUniformScreenProbes (
    float2 ScreenPosition,
    float3 Position,
    float  LinearDepth,
    float3 Normal,
    bool bScreenSpaceWeight,
    out int2 TileCoordsX00,
    out float4 Weights,
    bool bPrevious = false
) {
    int2 ScreenCoordsProbeGrid = clamp(ScreenPosition - 0.5f - GetTileJitter(bPrevious), 0, MI.ScreenDimensions - SSRC_TILE_SIZE - 1);
    TileCoordsX00         = min(ScreenCoordsProbeGrid / SSRC_TILE_SIZE, MI.TileDimensions - 2);
    // Pad the bilinear filtering weights
#ifdef DEBUG_FIX_PROBES
    int BilinearExpand = 0;
#else
    // Values larger than 1 causes SG to leak into neighboring probes
    // 0903: However we just need this to fix darkening around sharp edges of geometries.
    int BilinearExpand = 1;
#endif
    float2 Bilinear    = 
        (ScreenCoordsProbeGrid + 0.5f - TileCoordsX00 * SSRC_TILE_SIZE + BilinearExpand) 
        / (float)(SSRC_TILE_SIZE + 2 * BilinearExpand);
    float4 CornerLinearDepths;
    CornerLinearDepths.x = GetScreenProbeLinearDepth(TileCoordsX00 + int2(0, 0), bPrevious);
    CornerLinearDepths.y = GetScreenProbeLinearDepth(TileCoordsX00 + int2(1, 0), bPrevious);
    CornerLinearDepths.z = GetScreenProbeLinearDepth(TileCoordsX00 + int2(0, 1), bPrevious);
    CornerLinearDepths.w = GetScreenProbeLinearDepth(TileCoordsX00 + int2(1, 1), bPrevious);
    if(bScreenSpaceWeight) Weights = float4(
        (1.f - Bilinear.x) * (1.f - Bilinear.y),
        Bilinear.x * (1.f - Bilinear.y),
        (1.f - Bilinear.x) * Bilinear.y,
        Bilinear.x * Bilinear.y
    );
    else Weights = 1.f.xxxx;
    float4 DepthWeights;
    float4 PixelPlane  = float4(Normal, dot(Position, Normal));
    float3 PositionX00 = RecoverScreenProbePosition(TileCoordsX00 + int2(0, 0), CornerLinearDepths.x, bPrevious);
    float3 PositionX10 = RecoverScreenProbePosition(TileCoordsX00 + int2(1, 0), CornerLinearDepths.y, bPrevious);
    float3 PositionX01 = RecoverScreenProbePosition(TileCoordsX00 + int2(0, 1), CornerLinearDepths.z, bPrevious);
    float3 PositionX11 = RecoverScreenProbePosition(TileCoordsX00 + int2(1, 1), CornerLinearDepths.w, bPrevious);
    float4 PlaneDistances;
    PlaneDistances.x = abs(dot(PixelPlane, float4(PositionX00, -1.f)));
    PlaneDistances.y = abs(dot(PixelPlane, float4(PositionX10, -1.f)));
    PlaneDistances.z = abs(dot(PixelPlane, float4(PositionX01, -1.f)));
    PlaneDistances.w = abs(dot(PixelPlane, float4(PositionX11, -1.f)));
    float4 RelativeDepthDifference = PlaneDistances / LinearDepth;
    // Negative depths stands for invalid probes
    DepthWeights = select(
        CornerLinearDepths > 0, 
        exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference)),
        0.0
    );
    Weights *= DepthWeights;
}

void CalculateSSRCSampleWeights (
    float2 ScreenPosition,
    float3 Position,
    float  LinearDepth,
    float3 Normal,
    bool   bScreenSpaceWeight,
    out SSRC_SampleData Sample,
    bool bPrevious = false
) {
    int2 TileCoordsX00;
    CalculateSSRCSampleWeightsForUniformScreenProbes(
        ScreenPosition,
        Position,
        LinearDepth,
        Normal,
        bScreenSpaceWeight,
        TileCoordsX00,
        Sample.Weights,
        bPrevious
    );
    Sample.Index[0] = TileCoordsX00 + int2(0, 0);
    Sample.Index[1] = TileCoordsX00 + int2(1, 0);
    Sample.Index[2] = TileCoordsX00 + int2(0, 1);
    Sample.Index[3] = TileCoordsX00 + int2(1, 1);
    
    // Weight the adaptive probes and search within the nearest tiles
    {
        float Epsilon = .01f;
		float4 PixelPlane = float4(Normal, dot(Position, Normal));
        for (uint CornerIndex = 0; CornerIndex < 4; CornerIndex++)
		{
			if (Sample.Weights[CornerIndex] <= Epsilon)
			{
				int2 TileCoords = TileCoordsX00 + uint2(CornerIndex % 2, CornerIndex / 2);
				int NumAdaptiveProbes = 
                    bPrevious ? g_RWPreviousTileAdaptiveProbeCountTexture[TileCoords] 
                    : g_RWTileAdaptiveProbeCountTexture[TileCoords];
                [unroll(1 << (SSRC_MAX_ADAPTIVE_PROBE_LAYERS * 2))]
				for (uint AdaptiveProbeListIndex = 0; AdaptiveProbeListIndex < NumAdaptiveProbes; AdaptiveProbeListIndex++)
				{
                    // TODO reconstruct probe data from G-Buffer to reduce VRAM bandwidth when shading
					int  AdaptiveProbeIndex1 = GetAdaptiveProbeIndex(TileCoords, AdaptiveProbeListIndex, bPrevious);
					int  ScreenProbeIndex1   = AdaptiveProbeIndex1 + MI.UniformScreenProbeCount;
                    int2 ScreenProbeIndex    = int2(ScreenProbeIndex1 % MI.TileDimensions.x, ScreenProbeIndex1 / MI.TileDimensions.x);

                    ProbeHeader Header         = GetScreenProbeHeader(ScreenProbeIndex, bPrevious);
					float2 ProbeScreenPosition = Header.ScreenCoords + 0.5f;
					float ProbeLinearDepth     = Header.LinearDepth;
					
					float NewDepthWeight = 0;

                    float3 ProbePosition = Header.Position;
                    float  PlaneDistance = abs(dot(float4(ProbePosition, -1), PixelPlane));
                    float RelativeDepthDifference = PlaneDistance / ProbeLinearDepth;
                    NewDepthWeight = exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference));

					float2 DistanceToScreenProbe = abs(ProbeScreenPosition - ScreenPosition);
					float NewCornerWeight = 1.0f - saturate(min(DistanceToScreenProbe.x, DistanceToScreenProbe.y) / (float)(SSRC_TILE_SIZE));
					float NewInterpolationWeight = NewDepthWeight * (bScreenSpaceWeight ? NewCornerWeight : 1.f);

					if (NewInterpolationWeight > Sample.Weights[CornerIndex])
					{
						Sample.Weights[CornerIndex] = NewInterpolationWeight;
						Sample.Index[CornerIndex] = ScreenProbeIndex;
					}
				}
			}
		}
    }
}


groupshared int  LocalNumProbesToAllocate;
groupshared int  LocalAdaptiveProbeOffset;
groupshared int2 LocalProbeScreenCoordsToAllocate[WAVE_SIZE];
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateAdaptiveProbes (int DispatchID : SV_DispatchThreadID, int LocalID : SV_GroupThreadID) {
    if(MI.NoAdaptiveProbes) return ;
// This macro is passed in by compiler arguments
#ifndef SSRC_ADAPTIVE_PROBE_LAYER
#define SSRC_ADAPTIVE_PROBE_LAYER 0
#endif
    const int AdaptiveProbeDownsampleFactor = SSRC_TILE_SIZE / (2 << SSRC_ADAPTIVE_PROBE_LAYER);
    int2 DownsampledTileDimensions = MI.ScreenDimensions / AdaptiveProbeDownsampleFactor;
    int2 AdaptiveTileCoords = int2(
        DispatchID % DownsampledTileDimensions.x,
        DispatchID / DownsampledTileDimensions.x
    );
    if(WaveIsFirstLane()) {
        LocalNumProbesToAllocate = 0;
    }
    GroupMemoryBarrierWithGroupSync();

    {
        // Omit the adaptive probe that overlaps with the previous layer
        if(any((AdaptiveTileCoords&1) != 0)) {
            // Compute the screen coords for current adaptive probe
            int2 AdaptiveProbeScreenCoords = AdaptiveTileCoords * AdaptiveProbeDownsampleFactor + GetTileJitter();
            if(all(AdaptiveProbeScreenCoords < MI.ScreenDimensions)) {
                float Depth = g_DepthTexture.Load(int3(AdaptiveProbeScreenCoords, 0)).x;
                bool  bValid = Depth < 1.f;
                if(bValid) {
                    float3 WorldPosition  = RecoverWorldPositionHiRes(AdaptiveProbeScreenCoords);
                    float  LinearDepth    = GetLinearDepth(Depth);
                    float3 GeometryNormal = normalize(g_GeometryNormalTexture.Load(int3(AdaptiveProbeScreenCoords, 0)).xyz * 2.f - 1.f);
                    SSRC_SampleData Sample;

                    CalculateSSRCSampleWeights(
                        AdaptiveProbeScreenCoords + 0.5f,
                        WorldPosition,
                        LinearDepth,
                        GeometryNormal,
                        true,
                        Sample
                    );

                    float Epsilon = .01f;
                    Sample.Weights /= max(dot(Sample.Weights, 1), Epsilon);

                    float LightingIsValid = (dot(Sample.Weights, 1) < 1.0f - Epsilon) ? 0.0f : 1.0f;

                    if (!LightingIsValid)
                    {
                        int ListIndex;
                        InterlockedAdd(LocalNumProbesToAllocate, 1, ListIndex);
                        LocalProbeScreenCoordsToAllocate[ListIndex] = AdaptiveProbeScreenCoords;
                    }
                }
            }
        }
    }
    
    GroupMemoryBarrierWithGroupSync();

    // Allocate probes
    if(WaveIsFirstLane()) {
        InterlockedAdd(g_RWAdaptiveProbeCountBuffer[0], LocalNumProbesToAllocate, LocalAdaptiveProbeOffset);
    }

    GroupMemoryBarrierWithGroupSync();
    
    int NumProbeToAllocateClipped = min(max(MI.MaxAdaptiveProbeCount - LocalAdaptiveProbeOffset, 0), LocalNumProbesToAllocate);

    int AdaptiveProbeIndex = LocalAdaptiveProbeOffset + LocalID;

    if(LocalID < NumProbeToAllocateClipped) {
        // Allocate the index slot and record the index of the adaptive probe
        int TileAdaptiveProbeRank;
        // Set the tile coords to the tile that the LocalID th probe belongs to
        int2 TileCoords = (LocalProbeScreenCoordsToAllocate[LocalID] - GetTileJitter()) / SSRC_TILE_SIZE;
        // Make a copy of the tile probe count texture to RW at the same time
        InterlockedAdd(g_RWNextTileAdaptiveProbeCountTexture[TileCoords], 1, TileAdaptiveProbeRank);
        g_RWTileAdaptiveProbeIndexTexture[GetAdaptiveProbeIndexCoords(TileCoords, TileAdaptiveProbeRank)] = AdaptiveProbeIndex;
        // The probe here is guaranteed to be valid upon allocation.
        int ScreenProbeIndex1   = AdaptiveProbeIndex + MI.UniformScreenProbeCount;
        ProbeHeader Header;
        Header.ScreenCoords     = LocalProbeScreenCoordsToAllocate[LocalID];
        Header.Class        = ComputeProbeRankFromSplattedError(Header.ScreenCoords);
        int BasisCount      = GetProbeBasisCountFromClass(Header.Class);
        int BasisOffset     = WavePrefixSum(BasisCount);
        int BasisCountSum   = WaveActiveSum(BasisCount);
        int BasisGroupOffset;
        if(WaveIsFirstLane()) {
            // Allocate basis for the newly allocated tile probes
            InterlockedAdd(g_RWAllocatedProbeSGCountBuffer[0], BasisCountSum, BasisGroupOffset);
        }
        BasisGroupOffset = WaveReadLaneFirst(BasisGroupOffset);
        Header.BasisOffset   = BasisGroupOffset + BasisOffset;
        // Clip over the maximum basis count
        if(Header.BasisOffset + BasisCount > MI.MaxBasisCount) {
            Header.Class = 0;
        }
        float3 GeometryNormal = normalize(g_GeometryNormalTexture.Load(int3(Header.ScreenCoords, 0)).xyz * 2.f - 1.f);
        float Depth          = g_DepthTexture.Load(int3(Header.ScreenCoords, 0)).x;
        Header.LinearDepth   = GetLinearDepth(Depth);
        float2 UV = (Header.ScreenCoords + 0.5f) * MI.ScreenDimensionsInv;
        // High resolution recovery for accurate probe placement (otherwise may cause artifacts because of inaccurate occlusions)
        float3 WorldPosition = RecoverWorldPositionHiRes(Header.ScreenCoords);
        float3 ViewDirection = normalize(MI.CameraPosition - WorldPosition);
        float3 AdaptiveNormal = GetProbeOffsetAdaptiveNormal(Header.ScreenCoords, GeometryNormal, ViewDirection);
        Header.Position      = WorldPosition + AdaptiveNormal * Header.LinearDepth * SSRC_PROBE_NORMAL_OFFSET;
        
        Header.Normal        = GeometryNormal;
        int2 ScreenProbeIndex = int2(ScreenProbeIndex1 % MI.TileDimensions.x, ScreenProbeIndex1 / MI.TileDimensions.x);
        WriteScreenProbeHeader(ScreenProbeIndex, Header);
    }
}

// Write dispatch parameters for SSRC computations
[numthreads(1, 1, 1)]
void SSRC_WriteProbeDispatchParameters () {
    // Clip the number of allocated adaptive probes
    g_RWAdaptiveProbeCountBuffer[0] = min(g_RWAdaptiveProbeCountBuffer[0], MI.MaxAdaptiveProbeCount);

    DispatchCommand Command = (DispatchCommand)0;
    Command.num_groups_x = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0];
    Command.num_groups_y = 1;
    Command.num_groups_z = 1;
    g_RWDispatchCommandBuffer[0] = Command;

    Command.num_groups_x = (MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0] + WAVE_SIZE - 1) / WAVE_SIZE;
    Command.num_groups_y = 1;
    Command.num_groups_z = 1;
    g_RWPerLaneDispatchCommandBuffer[0] = Command;

    // Also, set the reduce count for scan sum update rays
    // Pad 1 for the last element
    g_RWReduceCountBuffer[0] = 
        MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0]
         + g_RWWorldCacheActiveProbeCountBuffer[0] + 1;
}

[numthreads(1, 1, 1)]
void WorldCache_WriteProbeDispatchParameters () {
    // Generate commands for active probe dispatch
    DispatchCommand Command = (DispatchCommand)0;
    Command.num_groups_x = g_RWWorldCacheActiveProbeCountBuffer[0];
    Command.num_groups_y = 1;
    Command.num_groups_z = 1;
    g_RWWCAPDispatchCommandBuffer[0] = Command;

    Command.num_groups_x = (g_RWWorldCacheActiveProbeCountBuffer[0] + WAVE_SIZE - 1) / WAVE_SIZE;
    Command.num_groups_y = 1;
    Command.num_groups_z = 1;
    g_RWPerLaneWCAPDispatchCommandBuffer[0] = Command;
}

void ResetProbe (int GroupID, int LocalID, int2 ProbeIndex, int BasisCount, int BasisOffset, float3 ProbeNormal) {
    for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
        int ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
        int2 ProbeTexelCoords = int2(ProbeTexelIndex % SSRC_PROBE_TEXTURE_SIZE, ProbeTexelIndex / SSRC_PROBE_TEXTURE_SIZE);
        WriteScreenProbeOctahedronRadianceDepth(ProbeIndex, ProbeTexelCoords, float4(0, 0, 0, MI.CameraFar));
    }
    if(LocalID < BasisCount) {
        SGData SG;
        SG.Color     = 0.001f.xxx;
        // TODO better initialization
        SG.Lambda    = InitSGLambda(BasisCount);

        float3 Direction = InitHemiDirections(LocalID, BasisCount);
        float3 Normal    = ProbeNormal;
        float3 Tangent, Bitangent;
        GetOrthoVectors(Normal, Tangent, Bitangent);
        float  Phi       = BlueNoise_Sample1D(int2(GroupID, LocalID), MI.FrameSeed, 2);
        SG.Direction = normalize(Direction.x * Tangent + Direction.y * Bitangent + Direction.z * Normal);

        SG.Depth     = MI.CameraFar;
        WriteBasisData(BasisOffset + LocalID, SG);
    }
    GroupMemoryBarrierWithGroupSync();
}

groupshared float  LocalSGSize4[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
groupshared SGData LocalSGData4[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
groupshared SGData LocalSGData4New[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
groupshared int    LocalSGMaxMatchIndex[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
groupshared int    LocalSGNewIndex[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
// Radiance + Weight (sample count)
groupshared int4   LocalProbeTexelsQuantilized[SSRC_PROBE_TEXTURE_SIZE * SSRC_PROBE_TEXTURE_SIZE];
groupshared int    LocalProbeTexelSampleWeightQuantilized[SSRC_PROBE_TEXTURE_SIZE * SSRC_PROBE_TEXTURE_SIZE];
// Initialize probe cache from the previous frame, one group per probe
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_ReprojectProbeHistory (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {
    int2 ProbeIndex = int2(GroupID % MI.TileDimensions.x, GroupID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    if(MI.ResetCache) {
        if(WaveIsFirstLane()) {
            // Clear probe history
            g_RWProbeHistoryTrustTexture[ProbeIndex] = 0;
        }
        ResetProbe(
            GroupID, LocalID, 
            ProbeIndex, GetProbeBasisCountFromClass(Header.Class),
            Header.BasisOffset, Header.Normal
        );
        return ;
    }
    float3 ProbeTangent, ProbeBitangent;
    GetOrthoVectors(Header.Normal, ProbeTangent, ProbeBitangent);
    float4 PrevHomogeneousW = mul(MI.PrevCameraProjView, float4(Header.Position, 1));
    // The probe is totally out of the screen on the last frame, so we should reset the probe
    if(PrevHomogeneousW.w <= 0) {
        if(WaveIsFirstLane()) {
            // Clear probe history
            g_RWProbeHistoryTrustTexture[ProbeIndex] = 0;
        }
        ResetProbe(
            GroupID, LocalID, 
            ProbeIndex, GetProbeBasisCountFromClass(Header.Class),
            Header.BasisOffset, Header.Normal
        );        
        return ;
    }
    float3 PrevHomogeneous = PrevHomogeneousW.xyz / PrevHomogeneousW.w;
    // TODO TAA should be in place of the noise effect, but it malfunctions
    // (consistent directional biased blur during reprojection).
    float2 NoiseOffset = (BlueNoise_Sample2D(ProbeIndex, MI.FrameSeed) * 2 - 1) * 0.5f;
    float2 PrevScreenPosition = MI.ScreenDimensions * NDC22UV(PrevHomogeneous.xy) + NoiseOffset;
    float2 PrevProbeHistoryDimensionsMin = GetTileJitter(true) + 0.5f;
    float2 PrevProbeHistoryDimensionsMax = MI.ScreenDimensions - SSRC_TILE_SIZE + GetTileJitter(true) + 0.5f;
    float2 PrevScreenPositionClamped = clamp(PrevScreenPosition, PrevProbeHistoryDimensionsMin, PrevProbeHistoryDimensionsMax);
    SSRC_SampleData Sample;
    // ~~~Exclude screen space weight when doing reprojection (which UE told me to do so...)~~~
    // That will introduce too many bias (colors flowing in a fixed direction in screen space)
    // TODO is it okay to use the clamped screen position? 
    CalculateSSRCSampleWeights(
        PrevScreenPositionClamped,
        Header.Position,
        Header.LinearDepth,
        Header.Normal,
        true, // false,
        Sample,
        true
    );
    float2 OutOfRangeDecay2 = max(
        PrevScreenPosition - PrevProbeHistoryDimensionsMax,
        PrevProbeHistoryDimensionsMin - PrevScreenPosition
    );
    OutOfRangeDecay2 = max(OutOfRangeDecay2, 0.f);
    float OutOfRangeDecay  = max(1.f - 2.f * length(OutOfRangeDecay2) / SSRC_TILE_SIZE, 0.f);
    // Stochastic noise for the history trust
    float Noise = BlueNoise_Sample1D(ProbeIndex, MI.FrameSeed, 3);
    // 1.5 ~ 3 probes
    // Noise should not be affecting the trust value... it'll make the cache unstable
    float HistoryTrust = min(dot(Sample.Weights, 1)/* * lerp(0.8f, 1.2f, Noise)*/, 1.f) * OutOfRangeDecay;
    if(WaveIsFirstLane()) {
        g_RWProbeHistoryTrustTexture[ProbeIndex] = HistoryTrust;
    }
    float Epsilon = .01f;
    Sample.Weights /= max(dot(Sample.Weights, 1), Epsilon);

    // Reproject Octahedron
    {
        float Q_Noise = BlueNoise_Sample1D(ProbeIndex, MI.FrameSeed, 4);

#if SSRC_PROBE_TEXTURE_SIZE * SSRC_PROBE_TEXTURE_SIZE % WAVE_SIZE != 0
#error "SSRC_PROBE_TEXTURE_SIZE * SSRC_PROBE_TEXTURE_SIZE must be a multiple of WAVE_SIZE"
#endif
        for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
            int ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
            LocalProbeTexelsQuantilized[ProbeTexelIndex] = 0;
            LocalProbeTexelSampleWeightQuantilized[ProbeTexelIndex] = 0;
        }
        GroupMemoryBarrierWithGroupSync();
        for(int CornerIndex = 0; CornerIndex < 4; CornerIndex++) {
            // A probe with a weight greater than 0 must be valid
            [branch]
            if(Sample.Weights[CornerIndex] > 0) {
                int2 SrcProbeIndex = Sample.Index[CornerIndex];
                ProbeHeader SrcProbeHeader = GetScreenProbeHeader(SrcProbeIndex, true);
                for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
                    int SrcTexelIndex = BaseProbeTexelIndex + LocalID;
                    int2 ProbeTexelCoords = int2(SrcTexelIndex % SSRC_PROBE_TEXTURE_SIZE, SrcTexelIndex / SSRC_PROBE_TEXTURE_SIZE); 
                    float4 RadianceDepth = GetScreenProbeOctahedronRadianceDepth(SrcProbeIndex, ProbeTexelCoords, true);
                    float3 RayRadiance = RadianceDepth.xyz;
                    float RayDepth = RadianceDepth.w;
                    float3 Tangent, Bitangent;
                    GetOrthoVectors(SrcProbeHeader.Normal, Tangent, Bitangent);
                    float3 RayDirection = HemiOctahedron01ToUnitVector((ProbeTexelCoords + 0.5f) / SSRC_PROBE_TEXTURE_SIZE);
                    RayDirection = RayDirection.x * Tangent + RayDirection.y * Bitangent + RayDirection.z * SrcProbeHeader.Normal;
                    float3 RayHitPosition = SrcProbeHeader.Position + RayDirection * RayDepth;
                    float3 ReprojectedRayDirection = normalize(RayHitPosition - Header.Position);
                    float  ReprojectedRayDepth     = length(RayHitPosition - Header.Position);
                    if(dot(ReprojectedRayDirection, Header.Normal) > 0) {
                        // Successful reprojection
                        float3 LocalReprojectedRayDirection = float3(
                            dot(ReprojectedRayDirection, ProbeTangent),
                            dot(ReprojectedRayDirection, ProbeBitangent),
                            dot(ReprojectedRayDirection, Header.Normal)
                        );
                        float2 ReprojectedProbeTexelUV = UnitVectorToHemiOctahedron01(LocalReprojectedRayDirection);
                        int2 ReprojectedProbeTexelCoords = clamp(int2(
                            ReprojectedProbeTexelUV * SSRC_PROBE_TEXTURE_SIZE
                        ), 0, SSRC_PROBE_TEXTURE_SIZE - 1);
                        int  ReprojectedProbeTexelIndex = ReprojectedProbeTexelCoords.y * SSRC_PROBE_TEXTURE_SIZE + ReprojectedProbeTexelCoords.x;
                        float  Weight = Sample.Weights[CornerIndex];
                        float3 WeightedRayRadiance = Weight * RayRadiance;
                        InterlockedAdd(LocalProbeTexelsQuantilized[ReprojectedProbeTexelIndex].x, QuantilizeRadiance(WeightedRayRadiance.x, Q_Noise));
                        InterlockedAdd(LocalProbeTexelsQuantilized[ReprojectedProbeTexelIndex].y, QuantilizeRadiance(WeightedRayRadiance.y, Q_Noise));
                        InterlockedAdd(LocalProbeTexelsQuantilized[ReprojectedProbeTexelIndex].z, QuantilizeRadiance(WeightedRayRadiance.z, Q_Noise));
                        InterlockedAdd(LocalProbeTexelsQuantilized[ReprojectedProbeTexelIndex].w, QuantilizeRadiance(ReprojectedRayDepth * Weight, Q_Noise));
                        InterlockedAdd(LocalProbeTexelSampleWeightQuantilized[ReprojectedProbeTexelIndex], QuantilizeWeight(Weight, Q_Noise));
                    }
                }
            }
        }
        GroupMemoryBarrierWithGroupSync();

        // GI10: Calculate the radiance backup value to be used for unvisited cells
        // Simply average the radiance values among probe samples.
        float4 BackupRadianceSum = 0;
        for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
            int ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
            float Weight = RecoverWeight(LocalProbeTexelSampleWeightQuantilized[ProbeTexelIndex]);
            float V = Weight > 0 ? 1.0f : 0.0f;
            float3 Radiance = RecoverRadiance(LocalProbeTexelsQuantilized[ProbeTexelIndex].xyz) / max(Weight, 1e-4f);
            BackupRadianceSum += float4(Radiance, V);
        }
        BackupRadianceSum = WaveActiveSum(BackupRadianceSum);

        float4 BackupRadianceDepth = 0;
        {
            float3 Radiance      = BackupRadianceSum.xyz / max(BackupRadianceSum.w, 1.0f);
            float  NumEmptyCells = (SSRC_PROBE_TEXTURE_SIZE * SSRC_PROBE_TEXTURE_SIZE - BackupRadianceSum.w);
            // Fill holes if there're only a tiny amount of empty cells
            // Otherwise decay the radiance they received
            BackupRadianceDepth = float4(Radiance / max(NumEmptyCells, 1.0f), MI.CameraFar);
        }
        
        // Write the reprojected probe texel
        for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
            int ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
            int2 ProbeTexelCoords = int2(ProbeTexelIndex % SSRC_PROBE_TEXTURE_SIZE, ProbeTexelIndex / SSRC_PROBE_TEXTURE_SIZE);
            float Weight = RecoverWeight(LocalProbeTexelSampleWeightQuantilized[ProbeTexelIndex]);
            float4 RadianceDepth = RecoverRadiance(LocalProbeTexelsQuantilized[ProbeTexelIndex]);
            if(Weight < 0.01f) RadianceDepth = BackupRadianceDepth;
            else RadianceDepth = RadianceDepth / Weight;
            WriteScreenProbeOctahedronRadianceDepth(ProbeIndex, ProbeTexelCoords, RadianceDepth);
        }
    }

// We may delay the SG reprojection to later shaders for better reprojection quality
#ifndef DELAYED_SG_REPROJECTION
    // Reproject SG
    int BasisOffsets[4];
    BasisOffsets[0] = GetScreenProbeBasisOffset(Sample.Index[0], true);
    BasisOffsets[1] = GetScreenProbeBasisOffset(Sample.Index[1], true);
    BasisOffsets[2] = GetScreenProbeBasisOffset(Sample.Index[2], true);
    BasisOffsets[3] = GetScreenProbeBasisOffset(Sample.Index[3], true);
    
    int BasisCount[4];
    BasisCount[0] = Sample.Weights[0] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[0], true).Class) : 0;
    BasisCount[1] = Sample.Weights[1] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[1], true).Class) : 0;
    BasisCount[2] = Sample.Weights[2] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[2], true).Class) : 0;
    BasisCount[3] = Sample.Weights[3] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[3], true).Class) : 0;
    int NumBasis0 = BasisCount[0] + BasisCount[1];
    int NumBasis1 = BasisCount[2] + BasisCount[3];
    int NumBasis  = NumBasis0 + NumBasis1;

#if SSRC_MAX_NUM_BASIS_PER_PROBE > 8
#error "SSRC_MAX_NUM_BASIS_PER_PROBE must be less than or equal to 8"
#endif
    // Fetch the basis data from the previous frame
    {
        int BasisRank = LocalID;
        if(BasisRank < NumBasis) {
            int Location, PrevCount;
            if(BasisRank < NumBasis0) {
                Location = BasisRank < BasisCount[0] ? 0 : 1;
                PrevCount = BasisRank < BasisCount[0] ? 0 : BasisCount[0];
            } else {
                Location = (BasisRank - NumBasis0) < BasisCount[2] ? 2 : 3;
                PrevCount = (BasisRank - NumBasis0) < BasisCount[2] ? NumBasis0 : (NumBasis0 + BasisCount[2]);
            }
            SGData SG = FetchBasisData(BasisOffsets[Location] + BasisRank - PrevCount, true);
            float Weight = Sample.Weights[Location];
            // FIXME directional reprojection is missing

            // Manually reduce the SG weight if it is mostly zero on the new probe's hemisphere
            float NormalProjection = dot(SG.Direction, Header.Normal);
            // TODO correct the SG's direction with heuristic
            float3 HemiDirection = SG.Direction - min(NormalProjection, 0.f) * Header.Normal;
            float HemiDirectionLength = length(HemiDirection);
            if(HemiDirectionLength < 1e-3f) {
                float3 Tangent, Bitangent;
                GetOrthoVectors(Header.Normal, Tangent, Bitangent);
                HemiDirection = Tangent;
                HemiDirectionLength = 1.f;
            } else {
                HemiDirection /= HemiDirectionLength;
            }
            float WeightDecay = saturate(lerp(0.f, 1.f, EvaluateSGRaw(SG, HemiDirection)));
            Weight *= WeightDecay;

            // Scale the color by the weight
            // Clamp to epsilon to always rank the closest SGs first if all SGs have zero weight
            LocalSGSize4[BasisRank] = Weight * (1e-7f + SGIntegrate(SG.Lambda) * dot(SG.Color, 1.f.xxx));
            SG.Color = SG.Color * Weight;
            LocalSGData4[BasisRank] = SG;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    // Simple N^2 Sort
    {
        SGData ThreadSG;
        int    ThreadSGRank;
        int BasisRank = LocalID;
        if(BasisRank < NumBasis) {
            float Weight = LocalSGSize4[BasisRank];
            int SortedRank = 0;
            [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
            for(int i = 0; i < NumBasis; i++) {
                float Opponent = LocalSGSize4[i];
                if(Opponent > Weight || (Opponent == Weight && i < BasisRank)) {
                    SortedRank ++;
                }
            }
            ThreadSGRank = SortedRank;
            ThreadSG = LocalSGData4[BasisRank];
        }
        
        GroupMemoryBarrierWithGroupSync();

        if(BasisRank < NumBasis) {
            LocalSGData4[ThreadSGRank] = ThreadSG;
        }
    }
    GroupMemoryBarrierWithGroupSync();

    int CurrentProbeBasisCount = GetProbeBasisCountFromClass(Header.Class);
    // The number of merges required to reduce the number of SGs
    int MergeCount = max(NumBasis - CurrentProbeBasisCount, 0);
#ifdef  DEBUG_FIX_PROBES
#define MERGE_BASIS_FLAG 0
#else 
#define MERGE_BASIS_FLAG 1
#endif
    // Progressively merges the candidate SGs.
    if(MERGE_BASIS_FLAG && CurrentProbeBasisCount > 0) {
        const int REPEAT = (SSRC_MAX_NUM_BASIS_PER_PROBE * 4 + WAVE_SIZE-1) / WAVE_SIZE;   
        [unroll(4)]
        for(int Iteration = 0; MergeCount > 0 && Iteration < 4; Iteration ++) {
            // Compute the distances between each pair of SGs
            {
                int BasisRank = LocalID;
                if(BasisRank < NumBasis) {
                    int MaxIndex  = -1;
                    float MaxSimilarity = -1.f;
                    SGData CurrentSG = LocalSGData4[BasisRank];
                    [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
                    for (int i = 0; i<NumBasis; i++) {
                        float Similarity = SGSimilarity(CurentSG, LocalSGData4[i]);
                        if(i != BasisRank && Similarity > MaxSimilarity) {
                            MaxSimilarity = Similarity;
                            MaxIndex = i;
                        }
                    }
                    LocalSGMaxMatchIndex[BasisRank] = MaxIndex;
                }
            }
            GroupMemoryBarrierWithGroupSync();
            int NumNewBasis = 0;
            // Pairing the SGs for merging, single threaded algorithm
            if(WaveIsFirstLane()) {
                // Simple greedy algorithm instead of dfs alike precise algirithm
                [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
                for(int i = 0; i<NumBasis; i++) {
                    int MaxIndex = LocalSGMaxMatchIndex[i];
                    if(MaxIndex >= 0) {
                        // Meet a not matched basis
                        bool AllocateNewSlot = false;
                        // A not matched basis
                        if(MergeCount > 0) {
                            if(MaxIndex > i) {
                                // Try to match the opponent
                                int OpponentMatchIndex = LocalSGMaxMatchIndex[MaxIndex];
                                // Try to match MaxIndex
                                if(OpponentMatchIndex != -1) {
                                    // Matched, so cancel the matching for MaxIndex
                                    LocalSGMaxMatchIndex[MaxIndex] = -1;
                                    MergeCount --;
                                    AllocateNewSlot = true;
                                } else {
                                    // The opponent is already matched by someone else
                                    // Failed, match with myself.
                                    LocalSGMaxMatchIndex[i] = i;
                                    AllocateNewSlot = true;
                                }
                            } else {
                                int OpponentMatchIndex = LocalSGMaxMatchIndex[MaxIndex];
                                // MaxIndex have no match for now, so we match it
                                if(MaxIndex == OpponentMatchIndex) {
                                    // Matched.
                                    LocalSGMaxMatchIndex[MaxIndex] = i;
                                    LocalSGMaxMatchIndex[i] = -1;
                                    MergeCount --;
                                } else {
                                    // Failed, the opponent has already matched.
                                    // Match with myself.
                                    LocalSGMaxMatchIndex[i] = i;
                                    AllocateNewSlot = true;
                                }
                            }
                        } else {
                            // No need for further merging. Match with itself
                            LocalSGMaxMatchIndex[i] = i;
                            AllocateNewSlot = true;
                        }
                        if(AllocateNewSlot) LocalSGNewIndex[i] = NumNewBasis++;
                    }
                }
            }
            GroupMemoryBarrierWithGroupSync();
            NumNewBasis = WaveReadLaneFirst(NumNewBasis);
            MergeCount  = WaveReadLaneFirst(MergeCount);
            // Merge the SGs
            {
                int BasisRank = LocalID;
                if(BasisRank < NumBasis) {
                    int MaxIndex  = LocalSGMaxMatchIndex[BasisRank];
                    if(MaxIndex >= 0) {
                        SGData NewSG;
                        if(MaxIndex != BasisRank) {
                            SGData X = LocalSGData4[BasisRank];
                            SGData Y = LocalSGData4[MaxIndex];
                            // Here we determine if we're actually merging the SGs
                            // SGs with too large difference in sharpness (lambda) and direction
                            // should not be forcefully merged as they can cause darkening artifacts
                            // in the final result.
                            // TODO
                            NewSG = CombineSG(X, Y);
                        } else NewSG = LocalSGData4[BasisRank];
                        LocalSGData4New[LocalSGNewIndex[BasisRank]] = NewSG;
                    }
                }
            }
            GroupMemoryBarrierWithGroupSync();
            // Swap the data
            {
                int BasisRank = LocalID;
                if(BasisRank < NumNewBasis) {
                    LocalSGData4[BasisRank] = LocalSGData4New[BasisRank];
                }
            }
            NumBasis = NumNewBasis;
            // Barrier the next iteration
            GroupMemoryBarrierWithGroupSync();
        }
    }
    // Write the new SGs to the buffer
    {
#if SSRC_MAX_NUM_BASIS_PER_PROBE > WAVE_SIZE
#error "SSRC_MAX_NUM_BASIS_PER_PROBE must be less than or equal to WAVE_SIZE"
#endif
        int BasisOffset = Header.BasisOffset;
        // TODO: Accumulate SG radiance into irradiance when dropping overflowing SGs 
        if(LocalID < CurrentProbeBasisCount) {
            SGData SG;
            if(LocalID < NumBasis) SG = LocalSGData4[LocalID];
            else {
                // Initialize the basis
                SG.Color = 0.001f;
                SG.Lambda = InitSGLambda(NumBasis);
                SG.Depth  = MI.CameraFar;
                float3 Direction = InitHemiDirections(LocalID, CurrentProbeBasisCount);
                SG.Direction = normalize(Direction.x * ProbeTangent + Direction.y * ProbeBitangent + Direction.z * Header.Normal);
            }
            WriteBasisData(BasisOffset + LocalID, SG);
        }
    }
#endif // DELAYED_SG_REPROJECTION
}

#define SCREEN_PROBE_TRUST_THRESHOLD 0.2f
// Initialize screen probes that failed in reprojection with world cache.
// Trust < SCREEN_PROBE_TRUST_THRESHOLD, we blend in more secondary cache if the trust is smaller than that.
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_InitializeFailedProbes (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {
    int2 ProbeIndex = int2(GroupID % MI.TileDimensions.x, GroupID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    float ProbeTrust = g_RWProbeHistoryTrustTexture[ProbeIndex];
    bool IsProbeTrusted = ProbeTrust >= SCREEN_PROBE_TRUST_THRESHOLD;
    if(MI.ResetCache || IsProbeTrusted) {
        // Do nothing when resetting the cache or the probe is semi-trusted
        return ;
    }
    float3 ProbeTangent, ProbeBitangent;
    GetOrthoVectors(Header.Normal, ProbeTangent, ProbeBitangent);
    float3 BiasedPosition = Header.Position + Header.Normal * WorldCache_GetSampleOffsetAmount(Header.Position);
    WorldCacheSample Sample = WorldCache_SampleProbes(
        Header.Position, BiasedPosition, Header.Normal, Header.LinearDepth,
        false, false, false
    );
    // Sample the world cache
#define LOOP_COUNT ((SSRC_PROBE_TEXTURE_TEXEL_COUNT + WAVE_SIZE - 1) / WAVE_SIZE)
    float4 ThreadLocalSumRadianceDepth[LOOP_COUNT];
    for(int i = 0; i < LOOP_COUNT; i ++) {
        ThreadLocalSumRadianceDepth[i] = 0.f;
    }
    for(int i = 0; i < 8; i++) {
        if(Sample.Weights[i] > 0 && WorldCache_IsProbeIndexValid(Sample.ProbeIndex[i])) {
            for(int PixelIndexBase = 0; PixelIndexBase < SSRC_PROBE_TEXTURE_TEXEL_COUNT; PixelIndexBase += WAVE_SIZE) {
                int PixelIndex = PixelIndexBase + LocalID;
                int2 PixelCoords = int2(PixelIndex % SSRC_PROBE_TEXTURE_SIZE, PixelIndex / SSRC_PROBE_TEXTURE_SIZE);
                float2 SSRC_HemiOct01 = (PixelCoords + 0.5f) / SSRC_PROBE_TEXTURE_SIZE;
                float3 LocalRayDirection = HemiOctahedron01ToUnitVector(SSRC_HemiOct01);
                float3 WorldRayDirection = LocalRayDirection.x * ProbeTangent + LocalRayDirection.y * ProbeBitangent + LocalRayDirection.z * Header.Normal;
                float2 WorldCache_Oct01 = UnitVectorToOctahedron01(WorldRayDirection);
                float2 WorldCache_TexBase = WorldCache_GetProbeAtlasBase(Sample.ProbeIndex[i]);
                float2 WorldCache_TexPosition = WorldCache_TexBase + (1 + WorldCache_Oct01 * WORLD_CACHE_PROBE_RESOLUTION_INTERNAL);
                float2 WorldCache_AtlasUV = WorldCache_TexPosition * WorldCache.InvAtlasDimensions;
                float3 Radiance = g_WorldCacheIrradiance2PLuminanceTexture.SampleLevel(g_LinearSampler, WorldCache_AtlasUV, 0).xyz;
                float  Depth    = g_WorldCacheMomentumTexture.SampleLevel(g_LinearSampler, WorldCache_AtlasUV, 0).x;
                ThreadLocalSumRadianceDepth[PixelIndexBase / WAVE_SIZE] += float4(Radiance, Depth) * Sample.Weights[i];
            }
        }
    }
    float BlendWeight = 1.f - ProbeTrust / SCREEN_PROBE_TRUST_THRESHOLD;
    // Write the radiance to the probe
    for(int i = 0; i < LOOP_COUNT; i ++) {
        int PixelIndexBase = i * WAVE_SIZE;
        int PixelIndex = PixelIndexBase + LocalID;
        int2 PixelCoords = int2(PixelIndex % SSRC_PROBE_TEXTURE_SIZE, PixelIndex / SSRC_PROBE_TEXTURE_SIZE);
        float4 RadianceDepth = ThreadLocalSumRadianceDepth[i];
        float4 OldRadianceDepth = GetScreenProbeOctahedronRadianceDepth(ProbeIndex, PixelCoords);
        float4 NewRadianceDepth = lerp(OldRadianceDepth, RadianceDepth, BlendWeight);
        WriteScreenProbeOctahedronRadianceDepth(ProbeIndex, PixelCoords, NewRadianceDepth);
    }
#undef LOOP_COUNT
}

// Allocate update rays for each probe
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateUpdateRays (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0]) {
        return;
    }
    // NOTE: the allocation number must be a multiple of WAVE_SIZE
    // NOTE: and no greater than SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE
    int2 ProbeIndex = int2(DispatchID % MI.TileDimensions.x, DispatchID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    // Invalid probe
    if(Header.LinearDepth <= 0) {
        g_RWProbeUpdateRayCountBuffer[DispatchID] = 0;
        return ;
    }
    // Naive strategy: allocate more rays for probes that failed in reprojection
    float Trust = g_RWProbeHistoryTrustTexture[ProbeIndex];
    int   Bonus = MI.BaseUpdateRayWaves + (1.f - Trust) * (SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE - MI.BaseUpdateRayWaves);
    g_RWProbeUpdateRayCountBuffer[DispatchID] = min(WAVE_SIZE * max(1, Bonus), SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE);
}

// Allocate rays for world cache update
[numthreads(WAVE_SIZE, 1, 1)]
void WorldCache_AllocateUpdateRays (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= WorldCache_GetActiveProbeCount()) return ;
    int ProbeActiveListIndex = DispatchID;
    // Simple uniform allocation
    // TODO better allocation strategy
    int RayCount = WorldCache.NumUpdateRayPerProbe;
    g_RWProbeUpdateRayCountBuffer[MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0] + ProbeActiveListIndex] = RayCount;
}

// A scan sum is performed to accumulate allocated raycount for each probe

[numthreads(1, 1, 1)]
void MIGI_SetUpdateRayCount () {
    int ProbeCount = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0] + g_RWWorldCacheActiveProbeCountBuffer[0];
    g_RWUpdateRayCountBuffer[0] = g_RWProbeUpdateRayOffsetBuffer[ProbeCount];
}

#ifndef DELAYED_SG_REPROJECTION
#define SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE SSRC_MAX_NUM_BASIS_PER_PROBE
#else
// We sample from 4 adjacent probes if reprojection is delayed, so 4 times the basis count
// when unrolling loops.
#define SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE (SSRC_MAX_NUM_BASIS_PER_PROBE * 4)
#endif

// TODO: Should we study from Lumen to use a large number? (Lumen: 0.1)
#define MIN_PDF_TO_TRACE 2e-2f

groupshared float  LocalOctahedronSampleWeight[SSRC_PROBE_TEXTURE_TEXEL_COUNT];
groupshared float  LocalOctahedronSampleWeightPrefixSum[SSRC_PROBE_TEXTURE_TEXEL_COUNT];
#ifndef DELAYED_SG_REPROJECTION
groupshared SGData LocalSGData[SSRC_MAX_NUM_BASIS_PER_PROBE];
groupshared float  LocalSGSize[SSRC_MAX_NUM_BASIS_PER_PROBE];
#else 
// Sample from 4 adjacent probes if reprojection is delayed
groupshared SGData LocalSGData[SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE];
groupshared float  LocalSGSize[SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE];
#endif
float RadianceToSampleWeight (float3 Radiance) {
    return dot(Radiance, 1.f.xxx) + 1e-4f;
}

// Retrieve the sample probes and weights used for reprojecting a probe
bool GetProbeReprojectionSample (float3 ProbeNormal, float3 ProbeTangent, float3 ProbeBitangent, float3 ProbePosition, float ProbeLinearDepth, int2 ProbeIndex, bool WriteProbeTrust, out SSRC_SampleData Sample) {
    // Reproject probe to find adjacent 4 probes from the last frame
    float4 PrevHomogeneousW = mul(MI.PrevCameraProjView, float4(ProbePosition, 1));
    // The probe is totally out of the screen on the last frame, so we should reset the probe
    if(PrevHomogeneousW.w > 0) {
        float3 PrevHomogeneous = PrevHomogeneousW.xyz / PrevHomogeneousW.w;
        // TODO TAA should be in place of the noise effect, but it malfunctions
        // (consistent directional biased blur during reprojection).
        float2 NoiseOffset = (BlueNoise_Sample2D(ProbeIndex, MI.FrameSeed) * 2 - 1) * 0.5f;
        float2 PrevScreenPosition = MI.ScreenDimensions * NDC22UV(PrevHomogeneous.xy) + NoiseOffset;
        float2 PrevProbeHistoryDimensionsMin = GetTileJitter(true) + 0.5f;
        float2 PrevProbeHistoryDimensionsMax = MI.ScreenDimensions - SSRC_TILE_SIZE + GetTileJitter(true) + 0.5f;
        float2 PrevScreenPositionClamped = clamp(PrevScreenPosition, PrevProbeHistoryDimensionsMin, PrevProbeHistoryDimensionsMax);
        // ~~~Exclude screen space weight when doing reprojection (which UE told me to do so...)~~~
        // That will introduce too many bias (colors flowing in a fixed direction in screen space)
        // TODO is it okay to use the clamped screen position? 
        CalculateSSRCSampleWeights(
            PrevScreenPositionClamped,
            ProbePosition,
            ProbeLinearDepth,
            ProbeNormal,
            true, // false,
            Sample,
            true
        );
        float2 OutOfRangeDecay2 = max(
            PrevScreenPosition - PrevProbeHistoryDimensionsMax,
            PrevProbeHistoryDimensionsMin - PrevScreenPosition
        );
        OutOfRangeDecay2 = max(OutOfRangeDecay2, 0.f);
        float OutOfRangeDecay  = max(1.f - 2.f * length(OutOfRangeDecay2) / SSRC_TILE_SIZE, 0.f);
        // Stochastic noise for the history trust
        float Noise = BlueNoise_Sample1D(ProbeIndex, MI.FrameSeed, 5);
        // 1.5 ~ 3 probes
        // Noise should not be affecting the trust value... it'll make the cache unstable
        float HistoryTrust = min(dot(Sample.Weights, 1)/* * lerp(0.8f, 1.2f, Noise)*/, 1.f) * OutOfRangeDecay;
        if(WriteProbeTrust && WaveIsFirstLane()) {
            g_RWProbeHistoryTrustTexture[ProbeIndex] = HistoryTrust;
        }
        float Epsilon = .01f;
        Sample.Weights /= max(dot(Sample.Weights, 1), Epsilon);
        // Successful reprojection
        return true;
    }
    return false;
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_SampleUpdateRays (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {
    const float Epsilon = 1e-7f;
    // We assume that ray count is always a multiple of WAVE_SIZE
    int  ProbeIndex1 = GroupID;
    int2 ProbeIndex  = int2(ProbeIndex1 % MI.TileDimensions.x, ProbeIndex1 / MI.TileDimensions.x);
    int  RayCount    = g_RWProbeUpdateRayCountBuffer[ProbeIndex1];
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    int  BasisCount  = GetProbeBasisCountFromClass(Header.Class);
    // The number of basis to sample from. Initialized to the basis count of the probe.
    int  SampleBasisCount = BasisCount;
#if SSRC_MAX_NUM_BASIS_PER_PROBE > WAVE_SIZE
#error "SSRC_MAX_NUM_BASIS_PER_PROBE must be less than or equal to WAVE_SIZE"
#endif
    // Prepare probe local coordinate system
    float3 ProbeTangent, ProbeBitangent;
    GetOrthoVectors(Header.Normal, ProbeTangent, ProbeBitangent);
    // Load SG to shared memory
#ifndef DELAYED_SG_REPROJECTION
    {
        int BasisRank = LocalID;
        if(BasisRank < SampleBasisCount) {
            SGData SG = FetchBasisData(Header.BasisOffset + BasisRank);
            LocalSGData[BasisRank] = SG;
            float SGSize = SGIntegrate(SG.Lambda) * dot(SG.Color, 1.f.xxx);
            LocalSGSize[BasisRank] = SGSize + Epsilon;
        } else if(BasisRank < SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE) {
            LocalSGSize[BasisRank] = 0;
        }
    }
#else // Otherwise load sampled SGs from history reprojection
#if SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE > WAVE_SIZE
#error "SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE must be less than or equal to WAVE_SIZE"
#endif
    {
        // Reproject probe to find adjacent 4 probes from the last frame
        SSRC_SampleData Sample;
        if(GetProbeReprojectionSample(Header.Normal, ProbeTangent, ProbeBitangent, Header.Position, Header.LinearDepth, ProbeIndex, true, Sample)) {
            // Load SGs from the last frame
            int BasisOffsets[4];
            BasisOffsets[0] = GetScreenProbeBasisOffset(Sample.Index[0], true);
            BasisOffsets[1] = GetScreenProbeBasisOffset(Sample.Index[1], true);
            BasisOffsets[2] = GetScreenProbeBasisOffset(Sample.Index[2], true);
            BasisOffsets[3] = GetScreenProbeBasisOffset(Sample.Index[3], true);
            
            int PrevBasisCount[4];
            PrevBasisCount[0] = Sample.Weights[0] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[0], true).Class) : 0;
            PrevBasisCount[1] = Sample.Weights[1] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[1], true).Class) : 0;
            PrevBasisCount[2] = Sample.Weights[2] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[2], true).Class) : 0;
            PrevBasisCount[3] = Sample.Weights[3] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[3], true).Class) : 0;
            int NumBasis0 = PrevBasisCount[0] + PrevBasisCount[1];
            int NumBasis1 = PrevBasisCount[2] + PrevBasisCount[3];
            int NumBasis  = NumBasis0 + NumBasis1;
            // Rewrite SampleBasisCount
            SampleBasisCount = NumBasis;
            // Fetch the basis data from the previous frame
            {
                int BasisRank = LocalID;
                if(BasisRank < NumBasis) {
                    int Location, PrevCount;
                    if(BasisRank < NumBasis0) {
                        Location  = (BasisRank < PrevBasisCount[0]) ? 0 : 1;
                        PrevCount = (BasisRank < PrevBasisCount[0]) ? 0 : PrevBasisCount[0];
                    } else {
                        Location = (BasisRank < NumBasis0 + PrevBasisCount[2]) ? 2 : 3;
                        PrevCount = (BasisRank < NumBasis0 + PrevBasisCount[2]) ? NumBasis0 : (NumBasis0 + PrevBasisCount[2]);
                    }
                    int BasisOffset = BasisOffsets[Location] + BasisRank - PrevCount;
                    float Weight = Sample.Weights[Location];
                    SGData SG = FetchBasisData(BasisOffset, true);
                    // FIXME directional reprojection is missing
                    // Manually reduce the SG weight if it is mostly zero on the new probe's hemisphere
                    float NormalProjection = dot(SG.Direction, Header.Normal);
                    // TODO correct the SG's direction with heuristic
                    float3 HemiDirection = SG.Direction - min(NormalProjection, 0.f) * Header.Normal;
                    float HemiDirectionLength = length(HemiDirection);
                    if(HemiDirectionLength < 1e-3f) {
                        float3 Tangent, Bitangent;
                        GetOrthoVectors(Header.Normal, Tangent, Bitangent);
                        HemiDirection = Tangent;
                        HemiDirectionLength = 1.f;
                    } else {
                        HemiDirection /= HemiDirectionLength;
                    }
                    float WeightDecay = saturate(lerp(0.f, 1.f, EvaluateSGRaw(SG, HemiDirection)));
                    Weight *= WeightDecay;

                    // Scale the color by the weight
                    // Clamp to epsilon to always rank the closest SGs first if all SGs have zero weight
                    LocalSGSize[BasisRank] = Weight * (1e-7f + SGIntegrate(SG.Lambda) * dot(SG.Color, 1.f.xxx));
                    SG.Color = SG.Color * Weight;
                    LocalSGData[BasisRank] = SG;
                } else if(BasisRank < SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE) {
                    LocalSGSize[BasisRank] = 0;
                }
            }
        } else {
            // Otherwise the probe has been reset. Simply loads them.
            // Here SampleBasisCount equals to BasisCount
            int BasisRank = LocalID;
            if(BasisRank < BasisCount) {
                SGData SG = FetchBasisData(Header.BasisOffset + BasisRank);
                LocalSGData[BasisRank] = SG;
                float SGSize = SGIntegrate(SG.Lambda) * dot(SG.Color, 1.f.xxx);
                LocalSGSize[BasisRank] = SGSize + Epsilon;
            } else if(BasisRank < SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE) {
                LocalSGSize[BasisRank] = 0;
            }
        }
    }
#endif // DELAYED_SG_REPROJECTION

    GroupMemoryBarrierWithGroupSync();
    float SumSizeOctahedronOriginal = 0.f;
    // Load octahedron sample weights
    {
        float SavedPrefixSum = 0.f;
        for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
            int  ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
            int2 ProbeTexelCoords = int2(ProbeTexelIndex % SSRC_PROBE_TEXTURE_SIZE, ProbeTexelIndex / SSRC_PROBE_TEXTURE_SIZE);
            float4 RadianceDepth = GetScreenProbeOctahedronRadianceDepth(ProbeIndex, ProbeTexelCoords);
            float3 Radiance = RadianceDepth.xyz;
            float AreaCorrectionFactor = 1.f;
#ifdef UE_STYLE_HEMISPHERICAL_OCT_MAPPING
            AreaCorrectionFactor = SSRC_PROBE_TEXTURE_TEXEL_COUNT * g_UEHemiOctahedronCorrectionLutTexture.Load(int3(ProbeTexelCoords, 0)).x;
#endif
            float  SampleWeight = RadianceToSampleWeight(Radiance) * AreaCorrectionFactor;
            LocalOctahedronSampleWeight[ProbeTexelIndex] = SampleWeight;
            float PrefixSum = WavePrefixSum(SampleWeight) + SavedPrefixSum;
            LocalOctahedronSampleWeightPrefixSum[ProbeTexelIndex] = PrefixSum;
#if SSRC_PROBE_TEXTURE_TEXEL_COUNT % WAVE_SIZE != 0
#error "SSRC_PROBE_TEXTURE_TEXEL_COUNT must be a multiple of WAVE_SIZE"
#endif
            SavedPrefixSum = WaveReadLaneAt(PrefixSum + RadianceToSampleWeight(Radiance), WAVE_SIZE - 1); 
        }
        SumSizeOctahedronOriginal = SavedPrefixSum;
    }
    GroupMemoryBarrierWithGroupSync();
    // Compute the sum of SG sizes
    float ThreadSizeSums[SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE];
    ThreadSizeSums[0] = 0;
    if(SampleBasisCount > 0) ThreadSizeSums[0] = LocalSGSize[0];
    [unroll(SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE - 1)]
    for(int i = 1; i < SampleBasisCount; i++) {
        ThreadSizeSums[i] = ThreadSizeSums[i-1] + LocalSGSize[i];
    }
    float SumSizeBasis = SampleBasisCount > 0 ? ThreadSizeSums[SampleBasisCount - 1] : 0;

    // Assume that octahedron mapping to sphere is area preserving (ignoring the distortion)
    float SumSizeOctahedron = SumSizeOctahedronOriginal * (TWO_PI / SSRC_PROBE_TEXTURE_TEXEL_COUNT) + Epsilon;

    float SumSize = SumSizeBasis + SumSizeOctahedron;
    
    Random rng = MakeRandom(GroupID * WAVE_SIZE + LocalID, MI.FrameSeed);
#if SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE % WAVE_SIZE != 0
#error "SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE must be a multiple of WAVE_SIZE"
#endif
    // Allocate a number of rays to sample the probe octahedron
    // Round to a multiple of WAVE_SIZE with russian roulette for maximum wave coherence & occupancy
    int NumProbeOctahedronSamples = RayCount * SumSizeOctahedron / SumSize;
    if(WaveIsFirstLane()) {
        int Remainder = NumProbeOctahedronSamples % WAVE_SIZE;
        float P = float(Remainder) / WAVE_SIZE;
        // Lane 0 decides the remainder
        float x = rng.rand();
        bool  b = x < P;
        if(b) NumProbeOctahedronSamples += WAVE_SIZE - Remainder;
        else NumProbeOctahedronSamples -= Remainder;
    }
    // Broadcast to all lanes
    NumProbeOctahedronSamples = WaveReadLaneFirst(NumProbeOctahedronSamples);
    // If there's no basis, we sample the octahedron directly
    if(SampleBasisCount == 0) NumProbeOctahedronSamples = RayCount;
    // Calculate the probability for using octahedron sampling (use RR result)
    float P_SampleOctahedron = NumProbeOctahedronSamples / float(RayCount);
    // Sample probe octahedron
    [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
    for(int RayRankBase = 0; RayRankBase < NumProbeOctahedronSamples; RayRankBase += WAVE_SIZE) {
        // We assume that ray count is always a multiple of WAVE_SIZE
        int RayRank = RayRankBase + LocalID;
        float  u    = rng.rand();
        float2 u2   = rng.rand2();
        float  U    = u * SumSizeOctahedronOriginal;
        int L = 0, R = SSRC_PROBE_TEXTURE_TEXEL_COUNT;
        for(int i = 0; i<SSRC_PROBE_TEXTURE_TEXEL_COUNT_L2; i++) {
            int Mid = (L + R) / 2;
            if(LocalOctahedronSampleWeightPrefixSum[Mid] < U) L = Mid;
            else R = Mid;
        }
        float OctPdf = LocalOctahedronSampleWeight[L] / max(SumSizeOctahedronOriginal, Epsilon) * SSRC_PROBE_TEXTURE_TEXEL_COUNT;
        float2 TexelUV = u2;
        int2   TexelCoords = int2(L % SSRC_PROBE_TEXTURE_SIZE, L / SSRC_PROBE_TEXTURE_SIZE);
        float2 OctahedronUV = (TexelUV + TexelCoords) * (1.f / SSRC_PROBE_TEXTURE_SIZE);
        float3 RayDirection = HemiOctahedron01ToUnitVector(OctahedronUV);
        RayDirection = RayDirection.x * ProbeTangent + RayDirection.y * ProbeBitangent + RayDirection.z * Header.Normal;
        // Convert from [0, 1]^2 to S^2
        float AreaCorrectionFactor = 1.f;
#ifdef UE_STYLE_HEMISPHERICAL_OCT_MAPPING
        AreaCorrectionFactor = 1.f / (SSRC_PROBE_TEXTURE_TEXEL_COUNT * g_UEHemiOctahedronCorrectionLutTexture.Load(int3(TexelCoords, 0)).x);
#endif
        OctPdf = OctPdf * AreaCorrectionFactor * (1.f / TWO_PI);
        // Accumulate pdf from SGs
        float SGPdfSum = 0.f;
        [unroll(SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE)]
        for(int i = 0; i < SampleBasisCount; i++) {
            SGData SG = LocalSGData[i];
            SGPdfSum += LocalSGSize[i] * SampleSGPDF(SG.Lambda, dot(RayDirection, SG.Direction));
        }
        float RayPdf = OctPdf * P_SampleOctahedron + SGPdfSum / max(SumSizeBasis, Epsilon) * (1.f - P_SampleOctahedron);
        if(MI.NoImportanceSampling) {
            RayPdf = UniformSampleHemispherePdf();
            RayDirection = UniformSampleHemisphere(u2);
            RayDirection = normalize(ProbeTangent * RayDirection.x + ProbeBitangent * RayDirection.y + Header.Normal * RayDirection.z);
        }
        // 0623: This must be checked otherwise there're precision issues
        float bValid = dot(RayDirection, Header.Normal) > 0;
        int ProbeIndex1 = ProbeIndex.x + ProbeIndex.y * MI.TileDimensions.x;
        if(RayPdf >= MIN_PDF_TO_TRACE && bValid) {
            WriteUpdateRay(ProbeIndex1, Header.ScreenCoords, RayRank, RayDirection, RayPdf);
        } else {
            // No need to do compressing since there're just a tiny number of rays being canceled
            WriteUpdateRay(ProbeIndex1, Header.ScreenCoords, RayRank, 0, 0);
        }
    }
    // Sample SGs
    [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
    for(int RayRankBase = NumProbeOctahedronSamples; RayRankBase < RayCount; RayRankBase += WAVE_SIZE) {
        // We assume that ray count is always a multiple of WAVE_SIZE
        int RayRank = RayRankBase + LocalID;
        float  u    = rng.rand();
        float2 u2   = rng.rand2();
        float U     = u * SumSizeBasis;
        int BasisRank = SampleBasisCount;
        [unroll(SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE)]
        for(int i = 0; i < SampleBasisCount; i++) {
            if(U < ThreadSizeSums[i]) {
                BasisRank = i;
                break;
            }
        }
        // Clamp to the first basis in case the random number is overflowed (should be rare)
        if(BasisRank == SampleBasisCount) BasisRank = 0;
        float3 RayDirection, SGDirection;
        {
            SGData SG = LocalSGData[BasisRank];
            float RayPdfTmp;
            RayDirection = SampleSG(u2, SG.Lambda, RayPdfTmp);
            SGDirection = SG.Direction;
        }
        float3 Tangent, Bitangent;
        GetOrthoVectors(SGDirection, Tangent, Bitangent);
        RayDirection = normalize(Tangent * RayDirection.x + Bitangent * RayDirection.y + SGDirection * RayDirection.z);
        // Compute ray pdf
        float  RayPdf = 0;
        {
            float SGPdfSum = 0.f;
            [unroll(SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE)]
            for(int i = 0; i < SampleBasisCount; i++) {
                SGData SG = LocalSGData[i];
                SGPdfSum += LocalSGSize[i] * SampleSGPDF(SG.Lambda, dot(RayDirection, SG.Direction));
            }
            float OctPdf = 0.f;
            float AreaCorrectionFactor = 1.f;
            if(dot(RayDirection, Header.Normal) > 0) {
                float3 ProbeRayDirection = float3(
                    dot(RayDirection, ProbeTangent),
                    dot(RayDirection, ProbeBitangent),
                    dot(RayDirection, Header.Normal)
                );
                float2 OctahedronUV = UnitVectorToHemiOctahedron01(ProbeRayDirection);
                int2   TexelCoords = int2(OctahedronUV * SSRC_PROBE_TEXTURE_SIZE);
                int    TexelIndex = TexelCoords.y * SSRC_PROBE_TEXTURE_SIZE + TexelCoords.x;
                OctPdf = LocalOctahedronSampleWeight[TexelIndex] / SumSizeOctahedronOriginal * SSRC_PROBE_TEXTURE_TEXEL_COUNT;
#ifdef UE_STYLE_HEMISPHERICAL_OCT_MAPPING
                AreaCorrectionFactor = 1.f / (SSRC_PROBE_TEXTURE_TEXEL_COUNT * g_UEHemiOctahedronCorrectionLutTexture.Load(int3(TexelCoords, 0)).x);
#endif
            }
            // Convert from [0, 1]^2 to S^2
            OctPdf = OctPdf * AreaCorrectionFactor * (1.f / TWO_PI);
            RayPdf = OctPdf * P_SampleOctahedron
                + SGPdfSum / max(SumSizeBasis, Epsilon) * (1.f - P_SampleOctahedron);
            // FIXME validate pdf!
            // what is \int_S^2 p_sg(w) dw?
            // if 1, then is correct, 2Pi is incorrect!
        }
        if(MI.NoImportanceSampling) {
            RayPdf = UniformSampleHemispherePdf();
            RayDirection = UniformSampleHemisphere(u2);
            RayDirection = normalize(ProbeTangent * RayDirection.x + ProbeBitangent * RayDirection.y + Header.Normal * RayDirection.z);
        }
        // 0623: This must be checked otherwise there're precision issues
        bool bValid = dot(RayDirection, Header.Normal) > 0;
        // Pack the ray
        int ProbeIndex1 = ProbeIndex.x + ProbeIndex.y * MI.TileDimensions.x;
        if(RayPdf >= MIN_PDF_TO_TRACE && bValid) {
            WriteUpdateRay(ProbeIndex1, Header.ScreenCoords, RayRank, RayDirection, RayPdf);
        } else {
            // No need to do compressing since there're just a tiny number of rays being canceled
            WriteUpdateRay(ProbeIndex1, Header.ScreenCoords, RayRank, 0, 0);
        }
    }
}

// Sample update rays for world cache update
[numthreads(WAVE_SIZE, 1, 1)]
void WorldCache_SampleUpdateRays (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {
    if(GroupID >= WorldCache_GetActiveProbeCount()) return ;
    int ProbeIndirectIndex = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0] + GroupID;
    int RayCount = g_RWProbeUpdateRayCountBuffer[ProbeIndirectIndex];
    // Simple uniform sampling using fibonacci lattice
    // TODO better sampling strategy
    Random rng = MakeRandom(67174928 + GroupID * WAVE_SIZE + LocalID, MI.FrameSeed);
    float3x3 Rotation = UniformRandomRotation(float3(rng.rand(), rng.rand(), rng.rand()));
    for(int RayRankBase = 0; RayRankBase < RayCount; RayRankBase += WAVE_SIZE) {
        int RayRank = RayRankBase + LocalID;
        if(RayRank < RayCount) {
            float3 RayDirection = FibonacciSphere(RayRank, RayCount);
            RayDirection = mul(Rotation, RayDirection);
            float RayPdf = UniformSampleSpherePdf(); // Sphere pdf
            WriteUpdateRay(ProbeIndirectIndex, int2(0, 0), RayRank, RayDirection, RayPdf);
        }
    }
}

#define SSRC_DISPATCH_RAYS_GROUP_SIZE 8

[numthreads(1, 1, 1)]
void MIGI_GenerateTraceUpdateRays () {
    int RayCount   = g_RWUpdateRayCountBuffer[0];
    DispatchRaysCommand dispatch_command_rays = (DispatchRaysCommand)0;
    dispatch_command_rays.ray_generation_shader_record = RayTracing.ray_generation_shader_record;
    dispatch_command_rays.miss_shader_table = RayTracing.miss_shader_table;
    dispatch_command_rays.hit_group_table = RayTracing.hit_group_table;
    dispatch_command_rays.callable_shader_table = RayTracing.callable_shader_table;
    dispatch_command_rays.width = RayCount;
    dispatch_command_rays.height = 1;
    dispatch_command_rays.depth = 1;
    g_RWDispatchRaysCommandBuffer[0] = dispatch_command_rays;

    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = 
        (RayCount + SSRC_DISPATCH_RAYS_GROUP_SIZE - 1) 
        / SSRC_DISPATCH_RAYS_GROUP_SIZE;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;

    // Also, set the world cache query count to ray count.
    g_RWWorldCacheQueryCountBuffer[0] = RayCount;
}

void MIGI_CacheUpdateHandleHit(uint DispatchID, inout MIGI_CacheUpdatePayload payload, RayDesc ray, HitInfo hit_info)
{
    WorldCacheVisibility Visibility;
    Visibility.InstanceIndex = hit_info.instanceIndex;
    Visibility.GeometryIndex = hit_info.geometryIndex;
    Visibility.PrimitiveIndex = hit_info.primitiveIndex;
    Visibility.Barycentrics = hit_info.barycentrics;
    Visibility.IsFrontFace = hit_info.frontFace;
    // Record query
    WorldCache_WriteQueryVisibility(DispatchID, Visibility);
    WorldCache_WriteQueryDirection(DispatchID, ray.Direction);
    
    // Clear radiance to 0
    float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[DispatchID]);
    g_RWUpdateRayRadianceInvPdfBuffer[DispatchID] = PackFp16x4Safe(float4(0.f.xxx, RayRadianceInvPdf.w));
    // Record hit distance
    g_RWUpdateRayLinearDepthBuffer[DispatchID] = Visibility.IsFrontFace ? payload.hit_dist : -payload.hit_dist;
}

void MIGI_CacheUpdateHandleMiss(uint DispatchID, inout MIGI_CacheUpdatePayload payload, RayDesc ray)
{
    payload.sky_sample = g_EnvironmentBuffer.SampleLevel(g_TextureSampler, ray.Direction, 0.0f).xyz;
    // Fallback to sky sample if no intersection
    float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[DispatchID]);
    g_RWUpdateRayRadianceInvPdfBuffer[DispatchID] = PackFp16x4Safe(float4(payload.sky_sample, RayRadianceInvPdf.w));
    g_RWUpdateRayLinearDepthBuffer[DispatchID] = MI.CameraFar;
}

void MIGI_CacheUpdateTraceRayInline(uint did, inout MIGI_CacheUpdatePayload payload, RayDesc ray)
{
    ClosestRayQuery ray_query = TraceRay<ClosestRayQuery>(ray);

    // If we hit some geometry, we append a new world-space hash-grid cache query
    if(ray_query.CommittedStatus() == COMMITTED_TRIANGLE_HIT)
    {
        payload.hit_dist = ray_query.CommittedRayT();
        MIGI_CacheUpdateHandleHit(did, payload, ray, GetHitInfoRtInlineCommitted(ray_query));
    } else {
        payload.hit_dist = ray_query.CommittedRayT();
        MIGI_CacheUpdateHandleMiss(did, payload, ray);
    }
}

void MIGI_CacheUpdateTraceRayRt(uint did, inout MIGI_CacheUpdatePayload payload, RayDesc ray)
{
    TraceRay(g_Scene, RAY_FLAG_NONE, 0xFFu, 0, 0, 0, ray, payload);
}

void MIGI_CacheUpdateTraceRay(uint did, inout MIGI_CacheUpdatePayload payload, RayDesc ray)
{
#if USE_INLINE_RT
    MIGI_CacheUpdateTraceRayInline(did, payload, ray);
#else
    MIGI_CacheUpdateTraceRayRt(did, payload, ray);
#endif
}

struct MIGI_RayProbeIndex {
    int2 ScreenProbeIndex;
    int  WorldProbeIndex;
    bool IsWorldProbe;
};
MIGI_RayProbeIndex GetUpdateRayProbeIndex (int QueryIndex) {
    MIGI_RayProbeIndex Result = (MIGI_RayProbeIndex)0;
    int SSRCUpdateRayCount = SSRC_GetTotalUpdateRayCount();
    if(QueryIndex >= SSRCUpdateRayCount) {
        Result.ScreenProbeIndex = int2(0, 0);
        int ActiveIndex = (QueryIndex - SSRCUpdateRayCount) / WorldCache.NumUpdateRayPerProbe;
        Result.WorldProbeIndex = g_RWWorldCacheActiveProbeIndexBuffer[ActiveIndex];
        Result.IsWorldProbe = true;
    } else {
        int ProbeIndex1 = g_RWUpdateRayProbeBuffer[QueryIndex / WAVE_SIZE];
        Result.ScreenProbeIndex = int2(ProbeIndex1 % MI.TileDimensions.x, ProbeIndex1 / MI.TileDimensions.x);
        Result.WorldProbeIndex = 0;
        Result.IsWorldProbe = false;
    }
    return Result;
}

// Trace visibility rays to generate secondary vertices / hits for world cache update 
void MIGI_TraceUpdateRays (uint DispatchID) {
    if(DispatchID >= g_RWUpdateRayCountBuffer[0]) return ;
    
    // Unpack ray data
    MIGI_RayProbeIndex RayProbeIndex = GetUpdateRayProbeIndex(DispatchID);

    float3 RayOrigin;
    if(!RayProbeIndex.IsWorldProbe) {
        // The probe origin offseted by an adaptive value, so no need to move further here.
        RayOrigin = GetScreenProbePosition(RayProbeIndex.ScreenProbeIndex);
    } else RayOrigin = WorldCache_GetProbeHeader(RayProbeIndex.WorldProbeIndex).WorldPosition;

    float3 RayDirection      = FetchUpdateRayDirection(DispatchID);
    float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[DispatchID]);
    float  InvPdf = RayRadianceInvPdf.w;

    // Early out if the ray is invalid / clipped for too tiny pdf.
    if(InvPdf == 0) {
        g_RWUpdateRayRadianceInvPdfBuffer[DispatchID] = PackFp16x4Safe(0.f);
        // Mark the ray as invalid in depth
        g_RWUpdateRayLinearDepthBuffer[DispatchID] = 0.f;
        return ;
    }

    // Override ray traced lighting for debugging
    if(MI.DebugLight != 0) {
        float3 LightPos = MI.DebugLightPosition;
        float  DistSqr  = lengthSqr(LightPos - RayOrigin);
        float  R2       = MI.DebugLightSize * MI.DebugLightSize;
        float  MaxCosTheta = sqrt(DistSqr - R2) / sqrt(DistSqr);
        float  CosTheta = dot(normalize(LightPos - RayOrigin), RayDirection);
        float3 L = (CosTheta > MaxCosTheta) ? MI.DebugLightColor : 0.f;
        g_RWUpdateRayRadianceInvPdfBuffer[DispatchID] = PackFp16x4Safe(float4(L, InvPdf));
        float  RayLenSqr = DistSqr - R2;
        g_RWUpdateRayLinearDepthBuffer[DispatchID] = sqrt(RayLenSqr);
        return ;
    }

    // Trace a visibility ray only.
    RayDesc VisibilityRayDesc;
    VisibilityRayDesc.Origin = RayOrigin;
    VisibilityRayDesc.Direction = RayDirection;
    VisibilityRayDesc.TMin = 0.f;
    VisibilityRayDesc.TMax = MAX_HIT_DISTANCE;

    // Fallback to far plane if no intersection
    g_RWUpdateRayLinearDepthBuffer[DispatchID]    = MI.CameraFar;

    MIGI_CacheUpdatePayload payload;
    payload.sky_sample = float3(0.0f, 0.0f, 0.0f);
    MIGI_CacheUpdateTraceRay(
        DispatchID,
        payload, VisibilityRayDesc
    );
    
}

[numthreads(SSRC_DISPATCH_RAYS_GROUP_SIZE, 1, 1)]
void MIGI_TraceUpdateRaysMain (uint DispatchID : SV_DispatchThreadID) {
    MIGI_TraceUpdateRays(DispatchID);
}

// HiZ required for injection culling
[numthreads(8, 8, 1)]
void PrecomputeHiZ (int2 DispatchID : SV_DispatchThreadID) {
    int2 Dimensions;
    g_RWHiZ_Out.GetDimensions(Dimensions.x, Dimensions.y);
    if(any(DispatchID >= Dimensions)) {
        return;
    }
    float X00 = g_RWHiZ_In[int2(2 * DispatchID.x + 0, 2 * DispatchID.y + 0)].x;
    float X01 = g_RWHiZ_In[int2(2 * DispatchID.x + 0, 2 * DispatchID.y + 1)].x;
    float X10 = g_RWHiZ_In[int2(2 * DispatchID.x + 1, 2 * DispatchID.y + 0)].x;
    float X11 = g_RWHiZ_In[int2(2 * DispatchID.x + 1, 2 * DispatchID.y + 1)].x;
#ifdef HIZ_MIN
    float X0 = min(X00, X01);
    float X1 = min(X10, X11);
    float X = min(X0, X1);
#else
    if(X00 == 1.f) X00 = 0.f;
    if(X01 == 1.f) X01 = 0.f;
    if(X10 == 1.f) X10 = 0.f;
    if(X11 == 1.f) X11 = 0.f;
    float X0 = max(X00, X01);
    float X1 = max(X10, X11);
    float X = max(X0, X1);
    if(X == 0.f) X = 1.f;
#endif
    g_RWHiZ_Out[DispatchID] = X;
}


[numthreads(SSRC_TILE_SIZE, SSRC_TILE_SIZE, 1)]
void SSRC_ReprojectPreviousUpdateError (int2 DispatchID : SV_DispatchThreadID) {
    if(any(DispatchID >= MI.ScreenDimensions)) {
        return;
    }

    float3 NormalPrev = g_GeometryNormalTexture.Load(int3(DispatchID, 0)).xyz;
    bool   IsSkyPixel = (dot(NormalPrev, NormalPrev) == 0.0f ? true : false);

    if (IsSkyPixel)
    {
        g_RWUpdateErrorSplatTexture[DispatchID] = 0.f;
        return;
    }
    float3 Normal = normalize(2.f * NormalPrev - 1.f);

    // Reproject the update error texture from previous frame to current frame
    float4 Visibility = g_VisibilityTexture.Load(int3(DispatchID, 0));
    float2 Barycentrics      = Visibility.xy;
    int   InstanceIndex      = asint(Visibility.z);
    int   PrimitiveIndex      = asint(Visibility.w);

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[InstanceIndex];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    TriangleNormUV vertices = fetchVerticesNormUV(mesh, PrimitiveIndex);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);

    vertices.n0 = transformNormal(vertices.n0, transform);
    vertices.n1 = transformNormal(vertices.n1, transform);
    vertices.n2 = transformNormal(vertices.n2, transform);

    float3   world    = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);

    float3 homogeneous = transformPointProjection(world, MI.CameraProjView);

    float2 UV          = 0.5f * float2(homogeneous.x, -homogeneous.y) + 0.5f;
    float  Depth       = homogeneous.z;

    // Severe precision loss here if we use the following reprojection method
    // float2 UV = (float2(DispatchID) + 0.5f) * MI.ScreenDimensionsInv;
    // float Depth = g_DepthTexture.Load(int3(UV, 0)).x;
    // float3 Normal = normalize(2.f * g_GeometryNormalTexture.Load(int3(UV, 0)).xyz - 1.f);
    // float3 homogeneous = float3(UV2NDC2(UV), Depth);

    if (all(UV > 0.0f) && all(UV < 1.0f) && Depth > 0.0f && Depth < 1.0f)
    {
        float2 previous_uv = UV - g_VelocityTexture.SampleLevel(g_NearestSampler, UV, 0.0f).xy;

        if (all(previous_uv > 0.0f) && all(previous_uv < 1.0f))
        {
            float3 homogeneous2 = transformPointProjection(homogeneous, MI.Reprojection);
            homogeneous2.z      = GetLinearDepth(homogeneous2.z);

            float  previous_depth  = GetLinearDepth(g_PreviousDepthTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).x);
            float3 previous_normal = normalize(2.0f * g_PreviousGeometryNormalTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz - 1.0f);

            if (dot(previous_normal, Normal) > 0.5f && abs(previous_depth - homogeneous2.z) / homogeneous2.z < 5e-2f)
            {
                // Using linear sampler in reprojection can significantly increase the reprojected error, why?
                float PreviousError = g_PreviousUpdateErrorSplatTexture.SampleLevel(g_NearestSampler, previous_uv, 0).x;
                g_RWUpdateErrorSplatTexture[DispatchID] = PreviousError;
                return; 
            }
        }
    }
    
    // TODO allocate a initial weight for the update error
    // FIXME
    g_RWUpdateErrorSplatTexture[DispatchID] = 0.f;
}

// UpdateErrorSplatTexture is later mipmapped.

[numthreads(WAVE_SIZE, 1, 1)]
void WorldCache_ShadeQueries(in uint DispatchID : SV_DispatchThreadID, in uint GroupID : SV_GroupID)
{
    uint QueryIndex = DispatchID;
    if (QueryIndex >= g_RWWorldCacheQueryCountBuffer[0])
    {
        return;
    }
    float SignedRayTravelDistance = g_RWUpdateRayLinearDepthBuffer[QueryIndex];
    float RayTravelDistance = abs(SignedRayTravelDistance);
    if(g_RWUpdateRayLinearDepthBuffer[QueryIndex] == 0 || RayTravelDistance >= MI.CameraFar) {
        // Early out if invalid / no visibility intersetion found for this ray
        return;
    }

    float Q_Noise = BlueNoise_Sample1D(int2(QueryIndex % 1024, QueryIndex / 1024), MI.FrameSeed, 6);

    // Load our visibility sample
    WorldCacheVisibility QueryVisibility = WorldCache_FetchQueryVisibility(QueryIndex);
    float3 QueryDirection = WorldCache_FetchQueryDirection(QueryIndex);

    // Reconstruct world-space position and normal
    Instance InstanceData  = g_InstanceBuffer[QueryVisibility.InstanceIndex];
    Mesh     mesh      = g_MeshBuffer[InstanceData.mesh_index];
    float3x4 transform = g_TransformBuffer[InstanceData.transform_index];

    TriangleNormUV vertices = fetchVerticesNormUV(mesh, QueryVisibility.PrimitiveIndex);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);

    vertices.n0 = transformNormal(vertices.n0, transform);
    vertices.n1 = transformNormal(vertices.n1, transform);
    vertices.n2 = transformNormal(vertices.n2, transform);

    float3   WorldPosition    = interpolate(vertices.v0, vertices.v1, vertices.v2, QueryVisibility.Barycentrics);
    float3   WorldNormal      = 
        (QueryVisibility.IsFrontFace ? 1.0f : -1.0f) * 
        normalize(interpolate(vertices.n0, vertices.n1, vertices.n2, QueryVisibility.Barycentrics));
    Material MaterialData = g_MaterialBuffer[InstanceData.material_index];

    // Recover the ray origin
    float3 RayOrigin = 0;
    {
        MIGI_RayProbeIndex RPI = GetUpdateRayProbeIndex(QueryIndex);
        if(RPI.IsWorldProbe)
            RayOrigin = WorldCache_GetProbeHeader(RPI.WorldProbeIndex).WorldPosition;
        else RayOrigin = GetScreenProbePosition(RPI.ScreenProbeIndex);
    }
    float2 MeshUV = interpolate(vertices.uv0, vertices.uv1, vertices.uv2, QueryVisibility.Barycentrics);

    // Bypass shading if we hit an emitter. Normally material emission can overwhelm ambient lighting.

    if (QueryVisibility.IsFrontFace && dot(MaterialData.emissivity.xyz, MaterialData.emissivity.xyz) > 0.0f)
    {
        MaterialEmissive emissive = MakeMaterialEmissive(MaterialData, MeshUV);
        float4 RadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[QueryIndex]);
        RadianceInvPdf.xyz = emissive.emissive;
        g_RWUpdateRayRadianceInvPdfBuffer[QueryIndex] = PackFp16x4Safe(RadianceInvPdf);
        return; // do not continue past an emissive surface
    }

    bool bReprojectionSuccess = false;
    float4 RayRadianceInvPdf    = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[QueryIndex]);
                       
    MaterialBRDF MaterialBRDFData = MakeMaterialBRDF(MaterialData, MeshUV);
    // Approximate the shading normal with the geometry normal
    float3 ShadingNormal = WorldNormal;
    float Roughness = sqrt(MaterialBRDFData.roughnessAlpha);
    float3 SpecDV = calculateGGXSpecularDirection(ShadingNormal, -QueryDirection, Roughness);
    float3 SpecHV = normalize(SpecDV - QueryDirection);
    float DotHV = saturate(dot(-QueryDirection, SpecHV));
    float3 DiffuseCompensation = diffuseCompensation(MaterialBRDFData.F0, DotHV);
    float  DotNV = saturate(dot(ShadingNormal, -QueryDirection));
    float2 LUT = g_LutBuffer.SampleLevel(g_LinearSampler, float2(DotNV, Roughness), 0.0f).xy;
    float3 DirectionalAlbedo = saturate(MaterialBRDFData.F0 * LUT.x + (1.0f - MaterialBRDFData.F0) * LUT.y);

    // Try to reproject the previous diffuse irradiance to the current frame 
    // and bypass world cache shading for possible queries 
    {
        float4 homogeneous_w = mul(MI.CameraProjView, float4(WorldPosition, 1.0f));
        if(homogeneous_w.w > 0) {
            float3 homogeneous = homogeneous_w.xyz / homogeneous_w.w;

            float2 uv    = 0.5f * float2(homogeneous.x, -homogeneous.y) + 0.5f;
            float  depth = homogeneous.z;

            if (all(uv > 0.0f) && all(uv < 1.0f) && depth > 0.0f && depth < 1.0f)
            {
                float2 previous_uv = uv - g_VelocityTexture.SampleLevel(g_NearestSampler, uv, 0.0f).xy;

                if (all(previous_uv > 0.0f) && all(previous_uv < 1.0f))
                {
                    float3 reprojected_homogeneous  = transformPointProjection(homogeneous, MI.Reprojection);
                    float  reprojected_linear_depth = GetLinearDepth(reprojected_homogeneous.z);

                    float  previous_linear_depth  = GetLinearDepth(g_PreviousDepthTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).x);
                    float3 previous_normal = normalize(2.0f * g_PreviousGeometryNormalTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz - 1.0f);
                    // Prevent front-to-back light leaks from thin meshes
                    bool normal_selection = dot(previous_normal, WorldNormal) > 5e-1f;
                    bool depth_selection  = 
                        abs(previous_linear_depth - reprojected_linear_depth) 
                        / max(previous_linear_depth, reprojected_linear_depth) < 5e-2f;
                        
                    if (normal_selection && depth_selection)
                    {
                        // Diffuse only. Glossy / specular lighting may vary significantly according
                        // to the viewing angle, so we cannot reuse them.
                        float3 PreviousDiffuse = g_PreviousDiffuseGITexture.SampleLevel(g_NearestSampler, previous_uv, 0).rgb;
    #ifdef ENABLE_INDIRECT
                        // Multiply by DiffuseCompensation over darken the result (though it should be logically correct)
                        RayRadianceInvPdf.xyz      += PreviousDiffuse;// * DiffuseCompensation;
    #endif // ENABLE_INDIRECT
                        bReprojectionSuccess = true;
                    }
                }
            }
        }
    }

    // Touch the cache to increase probe scores
    int WaveJitter = (MI.FrameIndex + GroupID) % 8;
    float3 WorldPositionBiased = 
        WorldPosition + WorldNormal * WorldCache_GetSampleOffsetAmount(WorldPosition);
    WorldCacheSample Sample = WorldCache_SampleProbes(
        WorldPosition, WorldPositionBiased, WorldNormal,
        RayTravelDistance, false, false, WaveJitter == 0);
    if(WaveJitter == 4) WorldCache_TouchSample(Sample);
    bool bIsDiffuseMaterial = DiffuseCompensation.x > 0.95f;
    if(bReprojectionSuccess && bIsDiffuseMaterial) {
        // Skip world cache shading for diffuse materials that project well on screen
        g_RWUpdateRayRadianceInvPdfBuffer[QueryIndex] = PackFp16x4Safe(RayRadianceInvPdf);
        return ;
    }
    
    // Shade query using world cache
    float3 Radiance = 0;
    float2 IrradianceTexPosition = 1.f + UnitVectorToOctahedron01(ShadingNormal) * WORLD_CACHE_PROBE_RESOLUTION_INTERNAL;
    for(int i = 0; i < 8; i++) {
        if(WorldCache_IsProbeIndexValid(Sample.ProbeIndex[i]) && Sample.Weights[i] > 0) {
            int2 AtlasBase = WorldCache_GetProbeAtlasBase(Sample.ProbeIndex[i]);
            float2 AtlasUV = (AtlasBase + IrradianceTexPosition) * WorldCache.InvAtlasDimensions;
            float3 Irradiance = TWO_PI * g_WorldCacheIrradiance2PLuminanceTexture.SampleLevel(g_LinearSampler, AtlasUV, 0).xyz;
            float3 Diffuse = DiffuseCompensation * Irradiance * evaluateLambert(MaterialBRDFData.albedo);
            // Skip diffuse lighting from world cache as we have reprojected that from the previous frame
            if(bReprojectionSuccess) Diffuse = 0; 
            // compute specular term with split-sum approximation
            float3 SpecularRadiance = Irradiance  / PI;
            float3 Specular = DirectionalAlbedo * SpecularRadiance;
            Radiance += (Diffuse + Specular) * Sample.Weights[i];
        }
    }

#ifdef ENABLE_INDIRECT
    RayRadianceInvPdf.xyz      += Radiance;
#endif

    g_RWUpdateRayRadianceInvPdfBuffer[QueryIndex] = PackFp16x4Safe(RayRadianceInvPdf);
}

// Update world cache
// Fine, I'll just use 2 warp ops for the whole thing on NVIDIA hardware. 
// (though almost a half of the threads wont be active)
[numthreads(WORLD_CACHE_PROBE_RESOLUTION, WORLD_CACHE_PROBE_RESOLUTION, 1)]
void WorldCache_UpdateProbes (int2 LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {
    int ActiveProbeListIndex = GroupID;
    int RayBaseOffset = SSRC_GetTotalUpdateRayCount() + ActiveProbeListIndex * WorldCache.NumUpdateRayPerProbe;
    int ProbeIndex = g_RWWorldCacheActiveProbeIndexBuffer[ActiveProbeListIndex];
    WorldCacheProbeHeader Header = WorldCache_GetProbeHeader(ProbeIndex);
    // Update probe atlas
    bool IsBorderPixel = LocalID.x == 0 || LocalID.y == 0 
        || LocalID.x == WORLD_CACHE_PROBE_RESOLUTION - 1 
        || LocalID.y == WORLD_CACHE_PROBE_RESOLUTION - 1;
    if(!IsBorderPixel) {
        float SumDepth = 0, SumDepthSqr = 0, SumWeight = 0;
        float3 SumIrradiance = 0;
        float SumIrradianceWeight = 0;
        float3 OctDirection = OctahedronToUnitVector01((LocalID - 0.5f) / float(WORLD_CACHE_PROBE_RESOLUTION_INTERNAL));
        int NumBackfaceHits = 0;
        int NumBackfaceHitsThreshold = WorldCache.NumUpdateRayPerProbe / 2;
        [unroll(WORLD_CACHE_MAX_UPDATE_RAYS_PER_PROBE)]
        for(int RayRank = 0; RayRank < WorldCache.NumUpdateRayPerProbe; RayRank++) {
            int RayIndex = RayBaseOffset + RayRank;
            float3 RayDirection = FetchUpdateRayDirection(RayIndex);
            float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
            float3 RayRadiance = RayRadianceInvPdf.xyz;
            float  RayDepth    = g_RWUpdateRayLinearDepthBuffer[RayIndex];
            if(RayRadianceInvPdf.w > 0) {
                if(RayDepth < 0) {
                    NumBackfaceHits ++;
                    if(NumBackfaceHits > NumBackfaceHitsThreshold) break;
                    // Omit backface hits
                    continue;
                }
                float CosineFactor = saturate(dot(RayDirection, OctDirection));
                SumIrradiance += RayRadiance * CosineFactor * RayRadianceInvPdf.w;
                SumIrradianceWeight += 1;
                float Weight = pow(CosineFactor, 50) * RayRadianceInvPdf.w;
                // Clamp the ray depth to 2.5 * the probe grid size, cause larger values are meaningless.
                // (We need 2 x grid size on cascade seams)
                RayDepth = min(RayDepth, 2.5f * WorldCache_GetGridSizeForLevel(Header.GridCoords.w));
                SumDepth += RayDepth * Weight;
                SumDepthSqr += RayDepth * RayDepth * Weight;
                SumWeight += Weight;
            }
        }
        float3 Irradiance2P = SumIrradiance / max(SumIrradianceWeight * TWO_PI, 1e-6f);
        float2 Momentum = float2(SumDepth, SumDepthSqr) / max(SumWeight, 1e-6f);
        int2 AtlasBase = WorldCache_GetProbeAtlasBase(ProbeIndex);
        int2 AtlasCoords = AtlasBase + LocalID;
        float3 PrevIrradiance2P = g_RWWorldCacheIrradiance2PLuminanceTexture[AtlasCoords].xyz;
        float2 PrevMomentum = g_RWWorldCacheMomentumTexture[AtlasCoords];

        // Implementation comes from RTXGI-DDGI source.
        float Hysteresis = 0.96f;
        // If the probe has been cleared, reset the hysteresis value
        if(dot(PrevIrradiance2P, PrevIrradiance2P) == 0) Hysteresis = 0.f;

        // Momentum update
        g_RWWorldCacheMomentumTexture[AtlasCoords] = lerp(Momentum, PrevMomentum, Hysteresis);

        // Get the difference between the current irradiance and the irradiance mean stored in the probe
        float3 Delta = Irradiance2P - PrevIrradiance2P;

        if (hmax(PrevIrradiance2P - Irradiance2P) > WorldCache.ProbeIrradianceThreshold)
        {
            // Lower the hysteresis when a large lighting (darkening) change is detected
            Hysteresis = max(0.f, Hysteresis - 0.75f);
        }

        if (luminance(Delta) > WorldCache.ProbeLuminanceThreshold)
        {
            // Clamp the maximum per-update change in irradiance when a large brightness change is detected
            Delta *= 0.25f;
        }

        // Interpolate the new blended irradiance with the existing irradiance in the probe.
        // A high hysteresis value emphasizes the existing probe irradiance.
        //
        // When using lower bit depth formats for irradiance, the difference between lerped values
        // may be smaller than what the texture format can represent. This can stop progress towards
        // the target value when going from high to low values. When darkening, step at least the minimum
        // value the texture format can represent to ensure the target value is reached. The threshold value
        // for 10-bit/channel formats is always used (even for 32-bit/channel formats) to speed up light to
        // dark convergence.
        static const float ColorThreshold = 1.f / 1024.f;
        float3 FinalDelta = (1.f - Hysteresis) * Delta;
        if (hmax(Irradiance2P) < hmax(PrevIrradiance2P))
        {
            FinalDelta = min(max(ColorThreshold, abs(FinalDelta)), abs(Delta)) * sign(FinalDelta);
        }
        float3 FinalIrradiance2P = PrevIrradiance2P + FinalDelta;

        g_RWWorldCacheIrradiance2PLuminanceTexture[AtlasCoords] = float4(FinalIrradiance2P, luminance(FinalIrradiance2P));
        {
            // Compute the coefficient of variation
            float3 Irradiance2 = (Irradiance2P - PrevIrradiance2P) * (Irradiance2P - FinalIrradiance2P);
            float  Luminance2 = luminance(Irradiance2);
            float  Luminance = luminance(FinalIrradiance2P);
            float  COV = (Luminance <= ColorThreshold) ? 0.f : (sqrt(Luminance2) / Luminance);
            g_RWWorldCacheCOVTexture[AtlasCoords] = COV;
        }
    }
    AllMemoryBarrierWithGroupSync();
    if(IsBorderPixel) {
        bool IsCornerTexel = (LocalID.x == 0 || LocalID.x == (WORLD_CACHE_PROBE_RESOLUTION - 1))
             && (LocalID.y == 0 || LocalID.y == (WORLD_CACHE_PROBE_RESOLUTION - 1));
        bool IsRowTexel = (LocalID.x > 0 && LocalID.x < (WORLD_CACHE_PROBE_RESOLUTION - 1));

        int2 CopyTexCoords = WorldCache_GetProbeAtlasBase(ProbeIndex);
        int2 TexCoords = CopyTexCoords + LocalID;

        if(IsCornerTexel)
        {
            CopyTexCoords.x += LocalID.x > 0 ? 1 : WORLD_CACHE_PROBE_RESOLUTION_INTERNAL;
            CopyTexCoords.y += LocalID.y > 0 ? 1 : WORLD_CACHE_PROBE_RESOLUTION_INTERNAL;
        }
        else if(IsRowTexel)
        {
            CopyTexCoords.x += (WORLD_CACHE_PROBE_RESOLUTION - 1) - LocalID.x;
            CopyTexCoords.y += LocalID.y + ((LocalID.y > 0) ? -1 : 1);
        }
        else // Column Texel
        {
            CopyTexCoords.x += LocalID.x + ((LocalID.x > 0) ? -1 : 1);
            CopyTexCoords.y += (WORLD_CACHE_PROBE_RESOLUTION - 1) - LocalID.y;
        }
        g_RWWorldCacheIrradiance2PLuminanceTexture[TexCoords] = g_RWWorldCacheIrradiance2PLuminanceTexture[CopyTexCoords];
        g_RWWorldCacheMomentumTexture[TexCoords] = g_RWWorldCacheMomentumTexture[CopyTexCoords];
    }
}

// The relocation heuristics come from RTXGI-DDGI
[numthreads(WAVE_SIZE, 1, 1)]
void WorldCache_MoveProbes (int DispatchID : SV_DispatchThreadID) {
    int ActiveProbeListIndex = DispatchID;
    if(ActiveProbeListIndex >= g_RWWorldCacheActiveProbeCountBuffer[0]) return ;
    int ProbeIndex = g_RWWorldCacheActiveProbeIndexBuffer[ActiveProbeListIndex];
    WorldCacheProbeHeader Header = WorldCache_GetProbeHeader(ProbeIndex);
    int RayBaseOffset = SSRC_GetTotalUpdateRayCount() + ActiveProbeListIndex * WorldCache.NumUpdateRayPerProbe;
    int MinFrontfaceIndex = -1;
    int MaxFrontfaceIndex = -1;
    int MinBackfaceIndex  = -1;
    float MinFrontfaceDepth = MI.CameraFar;
    float MaxFrontfaceDepth = 0;
    float MinBackfaceDepth  = MI.CameraFar;
    int NumBackfaceHits = 0;
    for(int RayRank = 0; RayRank < WorldCache.NumUpdateRayPerProbe; RayRank ++) {
        int RayIndex = RayBaseOffset + RayRank;
        float  RayDepth    = g_RWUpdateRayLinearDepthBuffer[RayIndex];
        float  AbsRayDepth = abs(RayDepth);
        if(RayDepth != 0) {
            if(RayDepth < 0) {
                NumBackfaceHits ++;
                if(AbsRayDepth < MinBackfaceDepth) {
                    MinBackfaceDepth = AbsRayDepth;
                    MinBackfaceIndex = RayIndex;
                }
            }
            if(RayDepth > 0) {
                if(AbsRayDepth < MinFrontfaceDepth) {
                    MinFrontfaceDepth = AbsRayDepth;
                    MinFrontfaceIndex = RayIndex;
                }
                if(AbsRayDepth > MaxFrontfaceDepth) {
                    MaxFrontfaceDepth = AbsRayDepth;
                    MaxFrontfaceIndex = RayIndex;
                }
            }
        }
    }
    int NumBackfaceHitsThreshold = WorldCache.NumUpdateRayPerProbe / 2;
    float3 ProbeOffset = Header.GridInternalNormalizedPosition;
    float3 NewOffset = ProbeOffset;
    float GridSize = WorldCache_GetGridSizeForLevel(Header.GridCoords.w);
    if (MinBackfaceIndex != -1 && NumBackfaceHits >= NumBackfaceHitsThreshold)
    {
        // If at least one backface triangle is hit AND backfaces are hit by enough probe rays,
        // assume the probe is inside geometry and move it outside of the geometry.
        float3 Direction = FetchUpdateRayDirection(MinBackfaceIndex);
        NewOffset = ProbeOffset + Direction * 0.1f;
    }
    else if (MinFrontfaceDepth < 0.2 * GridSize)
    {
        // Don't move the probe if moving towards the farthest frontface will also bring us closer to the nearest frontface
        float3 MinFrontfaceDirection = FetchUpdateRayDirection(MinFrontfaceIndex);
        float3 MaxFrontfaceDirection = FetchUpdateRayDirection(MaxFrontfaceIndex);

        if (dot(MinFrontfaceDirection, MaxFrontfaceDirection) <= 0.f)
        {
            // Ensures the probe never moves through the farthest frontface
            NewOffset = ProbeOffset + MaxFrontfaceDirection * 0.1f;
        }
    }
    else if (MinFrontfaceDepth > 0.5f * GridSize)
    {
        // Probe isn't near anything, try to move it back towards zero offset
        // float MoveBackMargin = min(MinFrontfaceDepth - 0.5f * GridSize, length(offset));
        float3 MoveBackDirection = normalize(-ProbeOffset);
        NewOffset = ProbeOffset + MoveBackDirection * 0.1f;
    }

    // Clamp to less than maximum distance to avoid degenerate cases
    if (dot(NewOffset, NewOffset) < 0.81f) // 0.9 * 0.9  == 0.81
    {
        ProbeOffset = NewOffset;
    }

    // Write the probe offsets
    WorldCache_WriteProbeGridInternalLocation(ProbeIndex, ProbeOffset);
}

int GetBasisRankToUpdate (int ProbeBasisCount) {
    return MI.FrameSeed % ProbeBasisCount;
}

float HeuristicSGDirectionBias (float3 SG_Direction, float3 Direction) {
    return 0.6f + dot(SG_Direction, Direction) * 0.4f;
}

void WriteScreenProbeSHCoefficients (int2 ProbeIndex, float3 SHCoefficients[9]) {
    float4 R1 = float4(SHCoefficients[1].x, SHCoefficients[2].x, SHCoefficients[3].x, SHCoefficients[4].x);
    float4 R2 = float4(SHCoefficients[5].x, SHCoefficients[6].x, SHCoefficients[7].x, SHCoefficients[8].x);
    float4 G1 = float4(SHCoefficients[1].y, SHCoefficients[2].y, SHCoefficients[3].y, SHCoefficients[4].y);
    float4 G2 = float4(SHCoefficients[5].y, SHCoefficients[6].y, SHCoefficients[7].y, SHCoefficients[8].y);
    float4 B1 = float4(SHCoefficients[1].z, SHCoefficients[2].z, SHCoefficients[3].z, SHCoefficients[4].z);
    float4 B2 = float4(SHCoefficients[5].z, SHCoefficients[6].z, SHCoefficients[7].z, SHCoefficients[8].z);
    float3 RGB0 = SHCoefficients[0];
    g_RWProbeIrradianceTexture[ProbeIndex].xyz = RGB0;
    g_RWProbeSHCoefficientsRTexture[ProbeIndex] = R1;
    g_RWProbeSHCoefficientsRTexture[ProbeIndex + int2(MI.TileDimensions.x, 0)] = R2;
    g_RWProbeSHCoefficientsBTexture[ProbeIndex] = B1;
    g_RWProbeSHCoefficientsBTexture[ProbeIndex + int2(MI.TileDimensions.x, 0)] = B2;
    g_RWProbeSHCoefficientsGTexture[ProbeIndex] = G1;
    g_RWProbeSHCoefficientsGTexture[ProbeIndex + int2(MI.TileDimensions.x, 0)] = G2;
}

// Update the probe cache
groupshared float3 LocalEvaluatedRadiance[SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE];

// The coverage of each ray by SGs
groupshared float  LocalRayCoverage[SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE];
groupshared float  LocalSampleWeightPrefixSum[WAVE_SIZE];

groupshared float3 LocalProbeTexels[SSRC_PROBE_TEXTURE_TEXEL_COUNT];

#ifdef DELAYED_SG_REPROJECTION
// Separate the depth from the radiance to avoid bank conflicts
groupshared float  LocalReprojectedOctDepth[SSRC_PROBE_TEXTURE_TEXEL_COUNT];
// Load update rays in advance to shared memory for multiple uses
groupshared float3 LocalUpdateRayRadiance[SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE];
groupshared float  LocalUpdateRayDepth[SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE];
groupshared float3 LocalUpdateRayDirection[SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE];
groupshared float  LocalUpdateRayInvPdf[SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE];
groupshared float  LocalSGCandidateScore[SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE];
groupshared float  LocalSGCandidateSampleWeight[SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE];
#endif

// Definitions about buffers holding SG data are reused from previous code snippets
// SGData LocalSGData[];

void AccumulateOctahedronRadiance (
    float3 RayDirection, float3 RayRadiance, float RayDepth, float RayWeight, float Q_Noise,
    float3 ProbeTangent, float3 ProbeBitangent, float3 ProbeNormal,
    inout float3 BackupRadianceSum, inout float BackupRadianceWeightSum) {
    // Accumulate the weighted radiance
    float3 ProbeRayDirection = float3(
        dot(ProbeTangent,   RayDirection),
        dot(ProbeBitangent, RayDirection),
        dot(ProbeNormal,    RayDirection)
    );
    float2 OctahedronUV = UnitVectorToHemiOctahedron01(ProbeRayDirection);
    int2 OctahedronTexelCoords = clamp(int2(
        int(OctahedronUV.x * SSRC_PROBE_TEXTURE_SIZE),
        int(OctahedronUV.y * SSRC_PROBE_TEXTURE_SIZE)
        ), 0, SSRC_PROBE_TEXTURE_SIZE - 1);
    int  OctahedronTexelIndex = OctahedronTexelCoords.y * SSRC_PROBE_TEXTURE_SIZE + OctahedronTexelCoords.x;
    // Re-weight the importance of each ray within each pixel with the inverse of their pdf
    // to avoid biased estimation of average radiance within the probe octahedron texel.
    float3 WeightedTargetRadiance = RayRadiance * RayWeight;
    float  WeightedRayDepth       = RayDepth * RayWeight;
    InterlockedAdd(LocalProbeTexelsQuantilized[OctahedronTexelIndex].x, QuantilizeRadiance(WeightedTargetRadiance.x, Q_Noise));
    InterlockedAdd(LocalProbeTexelsQuantilized[OctahedronTexelIndex].y, QuantilizeRadiance(WeightedTargetRadiance.y, Q_Noise));
    InterlockedAdd(LocalProbeTexelsQuantilized[OctahedronTexelIndex].z, QuantilizeRadiance(WeightedTargetRadiance.z, Q_Noise));
    InterlockedAdd(LocalProbeTexelsQuantilized[OctahedronTexelIndex].w, QuantilizeRadiance(WeightedRayDepth, Q_Noise));
    InterlockedAdd(LocalProbeTexelSampleWeightQuantilized[OctahedronTexelIndex], QuantilizeWeight(RayWeight, Q_Noise));
#ifndef BACKUP_RADIANCE_ON_PROBE_TEXELS
    // Accumulate backup radiance
    BackupRadianceSum += WeightedTargetRadiance;
    BackupRadianceWeightSum += RayWeight;
#endif
}

// TODO classify the number of update rays to completely unroll many loops
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_UpdateProbes (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {

    const float Epsilon = 1e-7f;

    int2 ProbeIndex = int2(GroupID % MI.TileDimensions.x, GroupID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    // Thread group early out if the probe is not valid
    [branch]
    if(!Header.bValid) return ;

    // Retrieve tangent space for current probe
    float3 ProbeTangent, ProbeBitangent;
    GetOrthoVectors(Header.Normal, ProbeTangent, ProbeBitangent);

    int  BasisCount = GetProbeBasisCountFromClass(Header.Class);
    int  ProbeRayCount   = g_RWProbeUpdateRayCountBuffer[GroupID];
    int  ProbeRayOffset  = g_RWProbeUpdateRayOffsetBuffer[GroupID];
    
    float  ReprojectionTrust = g_RWProbeHistoryTrustTexture[ProbeIndex].x;

    // Re-initialize the probe if it is not trusted at all
    [branch]
    if(ReprojectionTrust == 0) {
        // TODO heuristic initialization for probe octahedron radiances
        ResetProbe(GroupID, LocalID, ProbeIndex, BasisCount, Header.BasisOffset, Header.Normal);
    }

    // Clear accumulation buffer for octahedron radiance
    for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
        int ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
        LocalProbeTexelsQuantilized[ProbeTexelIndex] = 0.xxxx;
        LocalProbeTexelSampleWeightQuantilized[ProbeTexelIndex] = 0;
    }
    GroupMemoryBarrierWithGroupSync();
    // Noise for octahedron radiance quantilization
    float Q_Noise = BlueNoise_Sample1D(uint2(GroupID, LocalID), MI.FrameSeed, 8);
    // Backup radiance value for untraced probe texels in current update
    float3 BackupRadianceSum = 0.f;
    float  BackupRadianceWeightSum = 0.f;

#ifndef DELAYED_SG_REPROJECTION
    // Load the SG data to shared memory
    if(LocalID < BasisCount) {
        LocalSGData[LocalID] = FetchBasisData(Header.BasisOffset + LocalID);
    }
#else 
    // Load probe texels to shared memory for further use
    for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
        int  ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
        int2 TexelCoords = int2(ProbeTexelIndex % SSRC_PROBE_TEXTURE_SIZE, ProbeTexelIndex / SSRC_PROBE_TEXTURE_SIZE);
        float4 RadianceDepth = GetScreenProbeOctahedronRadianceDepth(ProbeIndex, TexelCoords);
        float3 Radiance = RadianceDepth.xyz;
        float  Depth = RadianceDepth.w;
        // Store reprojected radiance and depth to shared memory
        LocalProbeTexels[ProbeTexelIndex] = Radiance;
        LocalReprojectedOctDepth[ProbeTexelIndex] = Depth;
    }
    // Load update rays cooperatively
    for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
        int RayRank = RayRankBase + LocalID;
        int RayIndex = ProbeRayOffset + RayRank;
        float3 RayDirection = FetchUpdateRayDirection(RayIndex);
        float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
        float3 RayRadiance = RayRadianceInvPdf.xyz;
        // Sign of the depth is used to indicate the backface hits
        // SSRC just dont care about that
        float RayDepth = g_RWUpdateRayLinearDepthBuffer[RayIndex];
        LocalUpdateRayRadiance[RayRank]  = RayRadiance;
        LocalUpdateRayInvPdf[RayRank]    = RayRadianceInvPdf.w;
        LocalUpdateRayDepth[RayRank]     = RayDepth;
        LocalUpdateRayDirection[RayRank] = RayDirection;
    }
    GroupMemoryBarrierWithGroupSync();
    // Try to pick the best suited SGs for current probe with heuristics.
    // Reproject probe to find adjacent 4 probes from the last frame
    SSRC_SampleData Sample = (SSRC_SampleData)0;
    [branch]
    if(ReprojectionTrust != 0 && GetProbeReprojectionSample(Header.Normal, ProbeTangent, ProbeBitangent, Header.Position, Header.LinearDepth, ProbeIndex, false, Sample)) {
        int BasisOffsets[4];
        BasisOffsets[0] = GetScreenProbeBasisOffset(Sample.Index[0], true);
        BasisOffsets[1] = GetScreenProbeBasisOffset(Sample.Index[1], true);
        BasisOffsets[2] = GetScreenProbeBasisOffset(Sample.Index[2], true);
        BasisOffsets[3] = GetScreenProbeBasisOffset(Sample.Index[3], true);
        int PrevBasisCount[4];
        PrevBasisCount[0] = Sample.Weights[0] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[0], true).Class) : 0;
        PrevBasisCount[1] = Sample.Weights[1] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[1], true).Class) : 0;
        PrevBasisCount[2] = Sample.Weights[2] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[2], true).Class) : 0;
        PrevBasisCount[3] = Sample.Weights[3] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[3], true).Class) : 0;
        int NumBasis0 = PrevBasisCount[0] + PrevBasisCount[1];
        int NumBasis1 = PrevBasisCount[2] + PrevBasisCount[3];
        int NumBasis  = NumBasis0 + NumBasis1;
        // Load the SG candidates to shared memory
        if(LocalID < NumBasis) {
            int SampleLocation;
            int PrevCount;
            if(LocalID < NumBasis0) {
                SampleLocation = (LocalID < PrevBasisCount[0]) ? 0 : 1;
                PrevCount = (LocalID < PrevBasisCount[0]) ? 0 : PrevBasisCount[0];
            } else {
                SampleLocation = (LocalID - NumBasis0 < PrevBasisCount[2]) ? 2 : 3;
                PrevCount = ((LocalID - NumBasis0 < PrevBasisCount[2]) ? 0 :  PrevBasisCount[2]) + NumBasis0;
            }
            SGData SG = FetchBasisData(BasisOffsets[SampleLocation] + LocalID - PrevCount, true);
            LocalSGData[LocalID] = SG;
            LocalSGCandidateSampleWeight[LocalID] = Sample.Weights[SampleLocation];
        }
        GroupMemoryBarrierWithGroupSync();
        // LSM 
        for(int BasisRank = 0; BasisRank < NumBasis; BasisRank ++) {
            SGData SG = LocalSGData[BasisRank];
            float  SumAFactor = 0;
            float3 SumBFactor = 0;
            for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
                int RayRank = RayRankBase + LocalID;
                float3 RayDirection = LocalUpdateRayDirection[RayRank];
                float  InvPdf = LocalUpdateRayInvPdf[RayRank];
                float3 RayRadiance = LocalUpdateRayRadiance[RayRank];
                float3 LocalRayDirection = float3(
                    dot(RayDirection, ProbeTangent),
                    dot(RayDirection, ProbeBitangent),
                    dot(RayDirection, Header.Normal)
                );
                if(InvPdf > 0 && LocalRayDirection.z >= 0) {
                    float  SGEvaluatedRaw      = EvaluateSGRaw(SG, RayDirection);
                    // Evaluate reprojected mixed radiance for each ray
                    int2 TexCoords  = floor(UnitVectorToHemiOctahedron01(LocalRayDirection) * SSRC_PROBE_TEXTURE_SIZE);
                    int  TexelIndex = TexCoords.y * SSRC_PROBE_TEXTURE_SIZE + TexCoords.x;
                    float3 BaseRadiance   = LocalProbeTexels[TexelIndex];
                    float3 DiffRadiance   = RayRadiance - BaseRadiance;
                    float3 TargetRadiance = DiffRadiance;
                    float3 X = -2.f * DiffRadiance;
                    float  Y = dot(X, 1.f.xxx);

                    // The weight for balancing sample distribution
                    float  SampleWeight     = InvPdf;
#ifndef OPTIMAL_COLOR_UPDATE
                    if(SGEvaluatedRaw > 1e-2f) {
                        // least absolute deviation method using IRLS
                        // https://en.wikipedia.org/wiki/Iteratively_reweighted_least_squares
                        // SampleWeight canceled out.
                        float3 W = 1.f / max(abs(DiffRadiance)/* * SampleWeight */, 1e-3f);
                        SumAFactor        += 2.f * SGEvaluatedRaw * SGEvaluatedRaw * SampleWeight * W;
                        SumBFactor        += 2.f * TargetRadiance * SGEvaluatedRaw * SampleWeight * W;
                    }
#else
                    // least squares method
                    // Clip rays that only evaluates to a tiny value on SG to prevent outflares
                    if(SGEvaluatedRaw > 1e-2f) {
                        SumAFactor       += 2.f * SGEvaluatedRaw * SGEvaluatedRaw * SampleWeight;
                        SumBFactor       += 2.f * TargetRadiance * SGEvaluatedRaw * SampleWeight;
                    }
#endif
                }
            }
            SumAFactor = WaveActiveSum(SumAFactor);
            SumBFactor = WaveActiveSum(SumBFactor);
            float3 SGCandidateNewColor = SumBFactor / max(SumAFactor, 1e-6f);
            // Guess the color value using history value and the new value from LSM
            float3 SGCandidateColor = max(lerp(SG.Color, SGCandidateNewColor, 0.5f), 0);
            // Calculate SG error score
            float  SGErrorScore = 0;
            for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
                int RayRank = RayRankBase + LocalID;
                float3 RayDirection = LocalUpdateRayDirection[RayRank];
                float  InvPdf = LocalUpdateRayInvPdf[RayRank];
                float3 RayRadiance = LocalUpdateRayRadiance[RayRank];
                float3 LocalRayDirection = float3(
                    dot(RayDirection, ProbeTangent),
                    dot(RayDirection, ProbeBitangent),
                    dot(RayDirection, Header.Normal)
                );
                if(InvPdf > 0 && LocalRayDirection.z >= 0) {
                    int2 TexCoords  = floor(UnitVectorToHemiOctahedron01(LocalRayDirection) * SSRC_PROBE_TEXTURE_SIZE);
                    int  TexelIndex = TexCoords.y * SSRC_PROBE_TEXTURE_SIZE + TexCoords.x;
                    float3 BaseRadiance = LocalProbeTexels[TexelIndex];
                    float3 SGEvaluatedRadiance = EvaluateSGRaw(SG, RayDirection) * SGCandidateColor;
                    float3 DiffRadiance = RayRadiance - BaseRadiance - SGEvaluatedRadiance;
                    SGErrorScore += dot(DiffRadiance, DiffRadiance);
                }
            }
            SGErrorScore = WaveActiveSum(SGErrorScore);
            if(WaveIsFirstLane()) {
                // Reduce the possibility of selecting SGs with tiny sample weights
                float SGSampleWeight = LocalSGCandidateSampleWeight[BasisRank];
//                neighbor samples may massively affect visuals here
                float SampleCorrection = 1.f / max(sqrt(SGSampleWeight + 0.2f), 1e-6f);// asdasdasdas
                float Noise = BlueNoise_Sample1D(
                    int2(ProbeIndex.x * NumBasis +  BasisRank, ProbeIndex.y),
                    MI.FrameIndex, 7
                );
                // Jitter the score with noise to mitigate regular patterns upon selection
                float NoiseFactor = 1.f;//sqrt(0.001f + Noise);
#ifdef PURE_STOCHASTIC_SG_SELECTION
                LocalSGCandidateScore[BasisRank] = NoiseFactor;//SGErrorScore * SampleCorrection * NoiseFactor;
#else 
                LocalSGCandidateScore[BasisRank] = SGErrorScore * SampleCorrection * NoiseFactor;
#endif
            }
        }
        GroupMemoryBarrierWithGroupSync();
        // Pick the best SGs for current probe
        int PickingBasisRank = 0;
        [unroll(SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE)]
        for(; PickingBasisRank < BasisCount; PickingBasisRank ++) {
            int BestBasisRank = -1;
            float BestScore = 1e8f;
            if(WaveIsFirstLane()) {
                [unroll(SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE)]
                for(int BasisRank = 0; BasisRank < NumBasis; BasisRank ++) {
                    if(LocalSGCandidateScore[BasisRank] < BestScore) {
                        BestScore = LocalSGCandidateScore[BasisRank];
                        BestBasisRank = BasisRank;
                    }
                }
            }
            GroupMemoryBarrierWithGroupSync();
            BestBasisRank = WaveReadLaneFirst(BestBasisRank);
            if(BestBasisRank != -1) {
                SGData BestSG = LocalSGData[BestBasisRank];
                int CandidateBasisRank = LocalID;
                if(CandidateBasisRank < NumBasis) {
                    SGData CandidateSG = LocalSGData[CandidateBasisRank];
                    float Approximity = EvaluateSGRaw(CandidateSG, BestSG.Direction) * EvaluateSGRaw(BestSG, CandidateSG.Direction);
                    // Increase the score of similar SGs to prevent selecting
                    // SGs that are too similar to each other multiple times
                    float NewScore = LocalSGCandidateScore[CandidateBasisRank] /  max(1.f - Approximity, 1e-6f);
                    if(CandidateBasisRank == BestBasisRank) {
                        NewScore = 1e9f;
                    }
                    LocalSGCandidateScore[CandidateBasisRank] = NewScore;
                }
            } else break;
            GroupMemoryBarrierWithGroupSync();
            // Place it at the start of the array
            if(WaveIsFirstLane()) {
                if(PickingBasisRank != BestBasisRank) {
                    SGData TempSG = LocalSGData[PickingBasisRank];
                    LocalSGData[PickingBasisRank] = LocalSGData[BestBasisRank];
                    LocalSGData[BestBasisRank] = TempSG;
                    float TempScore = LocalSGCandidateScore[PickingBasisRank];
                    LocalSGCandidateScore[PickingBasisRank] = LocalSGCandidateScore[BestBasisRank];
                    LocalSGCandidateScore[BestBasisRank] = TempScore;
                    float TempWeight = LocalSGCandidateSampleWeight[PickingBasisRank];
                    LocalSGCandidateSampleWeight[PickingBasisRank] = LocalSGCandidateSampleWeight[BestBasisRank];
                    LocalSGCandidateSampleWeight[BestBasisRank] = TempWeight;
                }
            }
            GroupMemoryBarrierWithGroupSync();
        }
        // Deal with remaining SGs
        // 0. Apply Sample weights on SG colors.
        {
            if(LocalID < NumBasis) {
                LocalSGData[LocalID].Color *= LocalSGCandidateSampleWeight[LocalID];
            }
            GroupMemoryBarrierWithGroupSync();
        }
        // 1. Merge SGs similar enough into selected ones.
        {
            if(LocalID >= BasisCount && LocalID < NumBasis) {
                // Compute similarities between current basis with all selected basis.
                float MaxScore = MI.SGMergingThreshold;
                int   MaxIndex = -1;
                SGData CurrentSG = LocalSGData[LocalID];
                [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE)]
                for(int SelectedBasisRank = 0; SelectedBasisRank < BasisCount; SelectedBasisRank ++) {
                    SGData SelectedSG = LocalSGData[SelectedBasisRank];
                    float Score = SGSimilarity(SelectedSG, CurrentSG);
                    if(Score > MaxScore) {
                        MaxScore = Score;
                        MaxIndex = SelectedBasisRank;
                    }
                }
                GroupMemoryBarrierWithGroupSync();
                // Merge time! (this is sequential)
                // TODO parallize this? (is it really necessary?)
                if(MaxIndex >= 0) {
                    [unroll(SSRC_MAX_NUM_BASIS_TO_SAMPLE_PER_PROBE)]
                    for(int i = BasisCount; i < NumBasis; i ++) {
                        if(i == LocalID) {
                            LocalSGData[MaxIndex] = CombineSG(LocalSGData[MaxIndex], CurrentSG);
                        }
                        GroupMemoryBarrierWithGroupSync();
                    }
                    // Remove this SG from the candidate list as it has been
                    // merged into some selected SG.
                    LocalSGData[LocalID].Color = 0.f;
                }
                GroupMemoryBarrierWithGroupSync();
            }
        }
        // 2. Overflow the rest of them to octahedron radiance. 
        {
            float3 TexelRadianceValues[SSRC_PROBE_TEXTURE_TEXEL_COUNT / WAVE_SIZE];
            for(int i = 0; i < SSRC_PROBE_TEXTURE_TEXEL_COUNT / WAVE_SIZE; i++)
                TexelRadianceValues[i] = 0;
            for(int ProcessingBasisRank = BasisCount; ProcessingBasisRank < NumBasis; ProcessingBasisRank ++) {
                SGData CurrentSG = LocalSGData[ProcessingBasisRank];
                if(all(CurrentSG.Color == 0)) continue ;
                float3 Irradiance = SGIntegrate(CurrentSG.Lambda) * CurrentSG.Color;
                // Distribute irradiance onto the sphere
                float SGValues[SSRC_PROBE_TEXTURE_TEXEL_COUNT / WAVE_SIZE];
                for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
                    int TexelIndex = BaseProbeTexelIndex + LocalID;
                    int2 TexelCoords = int2(TexelIndex % SSRC_PROBE_TEXTURE_SIZE, TexelIndex / SSRC_PROBE_TEXTURE_SIZE);
                    float2 Oct01 = (TexelCoords + 0.5f) * (1.f / SSRC_PROBE_TEXTURE_SIZE);
                    float3 SampleDirection = HemiOctahedron01ToUnitVector(Oct01);
                    SampleDirection = SampleDirection.x * ProbeTangent + SampleDirection.y * ProbeBitangent + SampleDirection.z * Header.Normal;
                    float  SGValue  = EvaluateSGRaw(CurrentSG, SampleDirection);
                    SGValues[BaseProbeTexelIndex / WAVE_SIZE] = SGValue;
                }
                float Sum = 0.f;
                for(int i = 0; i < SSRC_PROBE_TEXTURE_TEXEL_COUNT / WAVE_SIZE; i++) {
                    Sum += SGValues[i];
                }
                Sum = WaveActiveSum(Sum);
                for(int i = 0; i < SSRC_PROBE_TEXTURE_TEXEL_COUNT / WAVE_SIZE; i++) {
                    float  Fraction = SGValues[i] / max(1e-5f, Sum);
                    float3 TexelIrradiance = Fraction * Irradiance;
                    int  TexelIndex  = i * WAVE_SIZE + LocalID;
                    int2 TexelCoords = int2(TexelIndex % SSRC_PROBE_TEXTURE_SIZE, TexelIndex / SSRC_PROBE_TEXTURE_SIZE);
                    float3 Radiance = TexelIrradiance * HemiOctahedronTexelIrradianceToRadiance(TexelCoords);
                    TexelRadianceValues[i] += Radiance;
                }
            }
            // Write back
            for(int i = 0; i < SSRC_PROBE_TEXTURE_TEXEL_COUNT / WAVE_SIZE; i++) {
                int TexelIndex = i * WAVE_SIZE + LocalID;
                LocalProbeTexels[TexelIndex] += TexelRadianceValues[i];
            }
            GroupMemoryBarrierWithGroupSync();
        }
        // Fallback to the default-initialized SGs upon reprojection failure
        if(PickingBasisRank <= LocalID && LocalID < BasisCount) {
            LocalSGData[LocalID] = FetchBasisData(Header.BasisOffset + LocalID);
        }
        // Now we're really ready
    } else {
        // Fallback to the default-initialized SGs upon reprojection failure
        if(LocalID < BasisCount) {
            LocalSGData[LocalID] = FetchBasisData(Header.BasisOffset + LocalID);
        }
    }

#endif

    GroupMemoryBarrierWithGroupSync();

    // Precomputation, evaluate the radiance of each update ray direction with the SG cache
    float  SumSampleWeight = 0.f;
#if SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE % WAVE_SIZE != 0
#error "SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE must be a multiple of WAVE_SIZE"
#endif
    [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
    for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
        int RayRank  = RayRankBase + LocalID;
        int RayIndex = ProbeRayOffset + RayRank;
        float3 RayDirection      = FetchUpdateRayDirection(RayIndex);
        float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
        float3 RayRadiance       = RayRadianceInvPdf.xyz;
        float  InvPdf            = RayRadianceInvPdf.w;
        if(InvPdf > 0) {
            float3 EvaluatedRadiance = 0.f.xxx;
            float  Coverage = 0;
            [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE)]
            for(int i = 0; i < BasisCount; i++) {
                float Raw = EvaluateSGRaw(LocalSGData[i], RayDirection);
                EvaluatedRadiance += Raw * LocalSGData[i].Color;
                Coverage = max(Coverage, HeuristicSGDirectionBias(LocalSGData[i].Direction, RayDirection));
            }
            LocalEvaluatedRadiance[RayRank] = EvaluatedRadiance;
            LocalRayCoverage[RayRank] = Coverage;
            SumSampleWeight += InvPdf;
        }
    }
    SumSampleWeight         = WaveActiveSum(SumSampleWeight) + Epsilon;

    GroupMemoryBarrierWithGroupSync();

    // TODO this must be very unstable
    float3 ImpactFactors = 1.f - ReprojectionTrust;

    // 1. Update probe octahedron radiance
    {
        // Enumerate rays and accumulate
        [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
        for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
            int RayRank  = RayRankBase + LocalID;
#ifndef DELAYED_SG_REPROJECTION
            int RayIndex = ProbeRayOffset + RayRank;
            float3 RayDirection      = FetchUpdateRayDirection(RayIndex);
            float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
            float3 RayRadiance       = RayRadianceInvPdf.xyz;
            // RayRadiance = select(RayRadiance > 0.05, 0.05f.xxx, 0.xxx);
            float  InvPdf            = RayRadianceInvPdf.w;
            float  RayDepth          = abs(g_RWUpdateRayLinearDepthBuffer[RayIndex]);
#else
            float3 RayDirection      = LocalUpdateRayDirection[RayRank];
            float3 RayRadiance       = LocalUpdateRayRadiance[RayRank];
            float  InvPdf            = LocalUpdateRayInvPdf[RayRank];
            float  RayDepth          = abs(LocalUpdateRayDepth[RayRank]);
#endif
            // Check for valid update rays
            if(InvPdf > 0 && dot(RayDirection, Header.Normal) > 0) {
                // Clamp to zero for negative radiance
#ifdef CLAMP_NEGATIVE_RADIANCE_VALUES
                float3 TargetRadiance = max(RayRadiance - LocalEvaluatedRadiance[RayRank], 0);
#else
                // 0809: Is clamping introducing bias?
                float3 TargetRadiance = RayRadiance - LocalEvaluatedRadiance[RayRank];
#endif
                
                float  SampleWeight   = InvPdf;
                
                // Accumulate the weighted radiance
                AccumulateOctahedronRadiance(
                    RayDirection, TargetRadiance, RayDepth, SampleWeight, Q_Noise,
                    ProbeTangent, ProbeBitangent, Header.Normal, BackupRadianceSum, BackupRadianceWeightSum
                );
            }
        }
#ifdef BACKUP_RADIANCE_ON_PROBE_TEXELS
        GroupMemoryBarrierWithGroupSync();
        // Accumulate backup radiance
        for(int BaseTexelIndex = 0; BaseTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseTexelIndex += WAVE_SIZE) {
            int TexelIndex = BaseTexelIndex + LocalID;
            float3 Radiance = RecoverRadiance(LocalProbeTexelsQuantilized[TexelIndex]);
            float  Weight   = RecoverWeight(LocalProbeTexelSampleWeightQuantilized[TexelIndex]);
            BackupRadianceSum += Radiance / max(Weight, 1e-4f);
            BackupRadianceWeightSum += (Weight != 0) ? 1 : 0;
        }
#endif
        BackupRadianceSum = WaveActiveSum(BackupRadianceSum);
        BackupRadianceWeightSum = WaveActiveSum(BackupRadianceWeightSum);
        // Clamp to zero for negative radiance
        BackupRadianceSum = max(BackupRadianceSum, 0.f.xxx);
        GroupMemoryBarrierWithGroupSync();
        // Compute the backup radiance
        float3 BackupRadiance = 0.f.xxx;
        {
            // Count untraced probe texels in current update
            int NumUntracedTexels = 0;
            [unroll(SSRC_PROBE_TEXTURE_TEXEL_COUNT / WAVE_SIZE)]
            for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
                int ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
                NumUntracedTexels += (LocalProbeTexelSampleWeightQuantilized[ProbeTexelIndex] == 0);
            }
            NumUntracedTexels = WaveActiveSum(NumUntracedTexels);
            // Compute the backup radiance
            BackupRadiance = BackupRadianceSum / max(BackupRadianceWeightSum, 1e-4f);
            float  empty_cell_count = NumUntracedTexels;
            BackupRadiance = BackupRadiance / max(NumUntracedTexels, 1.0f);
        }
        [unroll(SSRC_PROBE_TEXTURE_TEXEL_COUNT / WAVE_SIZE)]
        for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
            int  ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
            int2 ProbeTexelCoords = int2(ProbeTexelIndex % SSRC_PROBE_TEXTURE_SIZE, ProbeTexelIndex / SSRC_PROBE_TEXTURE_SIZE);
            int4  Quantilized = LocalProbeTexelsQuantilized[ProbeTexelIndex];
            float4 RadianceDepthSum = RecoverRadiance(Quantilized.xyzw);
            // Clamp to zero for negative radiance
            RadianceDepthSum.rgb = max(RadianceDepthSum.rgb, 0.f.xxx);
            float4 OldRadianceDepth;
#ifndef DELAYED_SG_REPROJECTION
            OldRadianceDepth = GetScreenProbeOctahedronRadianceDepth(ProbeIndex, ProbeTexelCoords);
#else
            // In this case old radiance and depth are loaded to shared memory earlier
            OldRadianceDepth = float4(
                LocalProbeTexels[ProbeTexelIndex],
                LocalReprojectedOctDepth[ProbeTexelIndex]
            );
#endif
            int    QuantilizedWeight = LocalProbeTexelSampleWeightQuantilized[ProbeTexelIndex];
            float  Weight   = QuantilizedWeight == 0 ? 1.f : RecoverWeight(QuantilizedWeight);
            // Overwrite the radiance depth with backup values if the texel is not traced in current update
            if(QuantilizedWeight == 0) RadianceDepthSum = float4(BackupRadiance, MI.CameraFar);
            float  LumaA = luminance(RadianceDepthSum.xyz);
            float  LumaB = luminance(OldRadianceDepth.xyz);
            // Copy-pasted from GI1.0
            // Shadow-preserving biased temporal hysteresis (inspired by: https://www.youtube.com/watch?v=WzpLWzGvFK4&t=630s)
            // It darkens the scene, while not good enough providing temporal stability as a trade-off.
            float TemporalBlend = squared(clamp(max(LumaA - LumaB - min(LumaA, LumaB), 0.0f) / max(max(LumaA, LumaB), 1e-4f), 0.0f, 0.95f));
            // We overwrite the heuristic with a fixed value for now (0904: where does bias comes from?)
            TemporalBlend = 0.5f;
            // Clamp the lerping factor with impact factors from our pipeline
            TemporalBlend = min(max(1.f - ImpactFactors.x - MI.CacheUpdateLearningRate, 0), TemporalBlend);
            float4 NewValue = lerp(RadianceDepthSum / Weight, OldRadianceDepth, TemporalBlend);
            LocalProbeTexels[ProbeTexelIndex] = NewValue.xyz;
            WriteScreenProbeOctahedronRadianceDepth(ProbeIndex, ProbeTexelCoords, NewValue);
        }
    }
    // Barrier updates on LocalProbeTexels
    GroupMemoryBarrierWithGroupSync();
    // Accumulate octahedron radiance into evaluated ray radiances for
    // further SG updates.
    [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
    for(int BaseUpdateRayRank = 0; BaseUpdateRayRank < ProbeRayCount; BaseUpdateRayRank += WAVE_SIZE) {
        int RayRank = BaseUpdateRayRank + LocalID;
        int UpdateRayIndex = ProbeRayOffset + RayRank;
        float4 RadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[UpdateRayIndex]);
        float3 Radiance = RadianceInvPdf.xyz;
        float  InvPdf   = RadianceInvPdf.w;
        if(InvPdf > 0) {
            float3 RayDirection = FetchUpdateRayDirection(UpdateRayIndex);
            float3 LocalRayDirection = float3(
                dot(ProbeTangent,   RayDirection),
                dot(ProbeBitangent, RayDirection),
                dot(Header.Normal,  RayDirection)
            );
            if(LocalRayDirection.z > 0) {
                float2 OctahedronUV = UnitVectorToHemiOctahedron01(LocalRayDirection);
                int2 OctahedronTexelCoords = clamp(int2(
                    int(OctahedronUV.x * SSRC_PROBE_TEXTURE_SIZE),
                    int(OctahedronUV.y * SSRC_PROBE_TEXTURE_SIZE)
                    ), 0, SSRC_PROBE_TEXTURE_SIZE - 1);
                int  OctahedronTexelIndex = OctahedronTexelCoords.y * SSRC_PROBE_TEXTURE_SIZE + OctahedronTexelCoords.x;
                LocalEvaluatedRadiance[RayRank] += LocalProbeTexels[OctahedronTexelIndex];
            }
        }
    }
    // Barrier updates on LocalEvaluatedRadiance
    GroupMemoryBarrierWithGroupSync();
    // 2.Update the SG direction first 
    [branch]
    if(MI.CacheUpdate_SGDirection) {
        float3 SumDirection = 0.f;
        // Pick one basis to update direction
        int BasisRankToUpdate = GetBasisRankToUpdate(BasisCount);
        SGData SG_D = LocalSGData[BasisRankToUpdate];
        SGData SG_O;
        [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
        for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
            int RayRank = RayRankBase + LocalID;
            int RayIndex = ProbeRayOffset + RayRank;
            float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
            float3 RayDirection      = FetchUpdateRayDirection(RayIndex);
            float3 RayRadiance       = RayRadianceInvPdf.xyz;
            float  InvPdf            = RayRadianceInvPdf.w;
            if(InvPdf > 0) {
                float  SGEvaluatedRaw      = EvaluateSGRaw(SG_D, RayDirection);
                float3 SGEvaluatedRadiance = SGEvaluatedRaw * SG_D.Color;
                // Clamp DiffRadiance to prevent "direction chasing" when the direction of a basis is updated
                // but its color is not converged to the correct result yet.
                float3 DiffRadianceClamped = max(RayRadiance - LocalEvaluatedRadiance[RayRank], 0.f);
                float3 TargetRadiance = DiffRadianceClamped + SGEvaluatedRadiance;
                float  RadianceWeight    = MI.SquaredSGDirectionalRadianceWeight ? dot(TargetRadiance, TargetRadiance) : dot(TargetRadiance, 1.f.xxx);
                // The weight for balancing sample distribution
                float  SampleWeight      = InvPdf;
                // 0529: Add a bias to reserve affection for closer light sources in the same direction
                float DirectionBias = HeuristicSGDirectionBias(SG_D.Direction, RayDirection);
                // Decay if it is closer to other SGs
                float Coverage = max(LocalRayCoverage[RayRank], Epsilon);
                float DirectionDecay =  pow(DirectionBias / Coverage, 6);
                float TotalWeight = RadianceWeight * SampleWeight * DirectionDecay;
                SumDirection  += RayDirection * TotalWeight;
            }
        }
        // Accumulate and normalize
        SumDirection = WaveActiveSum(SumDirection);
        if(dot(SumDirection, SumDirection) > 1e-6f) {
            float3 TargetDirection = normalize(SumDirection);
            // float  SrcWeight = SGIntegrate(SG_D.Lambda) * dot(SG_D.Color, 1.f.xxx) + Epsilon;
            // float  DstWeight = SumTotalWeight + Epsilon;
            // float  T = SrcWeight / (SrcWeight + DstWeight);
            float T = 0.15f;
            SG_O = SG_D;
            SG_D.Direction = normalize(lerp(SG_D.Direction, TargetDirection, T));//InterpolateDirection(SG_D.Direction, TargetDirection, T);
            if(WaveIsFirstLane()) {
                LocalSGData[BasisRankToUpdate] = SG_D;
            }
            // Re-calculate the evaluated radiance for the changed basis
            [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
            for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
                int RayRank  = RayRankBase + LocalID;
                int RayIndex = ProbeRayOffset + RayRank;
                float3 RayDirection      = FetchUpdateRayDirection(RayIndex);
                float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
                float3 RayRadiance       = RayRadianceInvPdf.xyz;
                float  InvPdf            = RayRadianceInvPdf.w;
                if(InvPdf > 0) {
                    float  RawPrevious = EvaluateSGRaw(SG_O, RayDirection);
                    float  Raw         = EvaluateSGRaw(SG_D, RayDirection);
                    float3 Delta = Raw * SG_D.Color - RawPrevious * SG_O.Color;
                    LocalEvaluatedRadiance[RayRank] += Delta;
                }
            }
        }
        GroupMemoryBarrierWithGroupSync();
    }

    // Update Color and Lambda

    for(int BasisRank = 0; BasisRank < BasisCount; BasisRank ++) {
        SGData SG = LocalSGData[BasisRank];
        SGGradients SumStepSize = (SGGradients)0;
#ifndef OPTIMAL_COLOR_UPDATE
        float3  SumAFactor = 0;
#else
        float   SumAFactor = 0;
#endif

        [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
        for(int RayGroupOffset = 0; RayGroupOffset < ProbeRayCount; RayGroupOffset += WAVE_SIZE) {
            int RayRank = RayGroupOffset + LocalID;
            if(RayRank < ProbeRayCount) {
                int RayIndex = ProbeRayOffset + RayRank;
#ifndef DELAYED_SG_REPROJECTION
                float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
                float  RayLinearDepth    = abs(g_RWUpdateRayLinearDepthBuffer[RayIndex]);
                float3 RayDirection      = FetchUpdateRayDirection(RayIndex);
                float3 RayRadiance       = RayRadianceInvPdf.xyz;
                float  InvPdf            = RayRadianceInvPdf.w;
#else
                // Ray data has been loaded to shared memory earlier
                float3 RayDirection      = LocalUpdateRayDirection[RayRank];
                float3 RayRadiance       = LocalUpdateRayRadiance[RayRank];
                float  InvPdf            = LocalUpdateRayInvPdf[RayRank];
                float  RayLinearDepth    = abs(LocalUpdateRayDepth[RayRank]);
#endif

                if(InvPdf > 0) {
                    float  SGEvaluatedRaw      = EvaluateSGRaw(SG, RayDirection);
                    float3 SGEvaluatedRadiance = SGEvaluatedRaw * SG.Color;

                    float3 dColorExtra;
                    SGGradients Gradients;
                    EvaluateSG_Gradients(SG, RayDirection, Gradients, dColorExtra);
                    float3 DiffRadiance   = RayRadiance - LocalEvaluatedRadiance[RayRank];
                    float3 TargetRadiance = DiffRadiance + SGEvaluatedRadiance;
                    float3 X = -2.f * DiffRadiance;
                    float  Y = dot(X, 1.f.xxx);

                    // The weight for balancing sample distribution
                    float  SampleWeight     = InvPdf;
#ifndef OPTIMAL_COLOR_UPDATE
                    if(SGEvaluatedRaw > 1e-2f || dot(TargetRadiance, 1.f.xxx) < dot(SGEvaluatedRadiance, 1.f.xxx)) {
                        // least absolute deviation method using IRLS
                        // https://en.wikipedia.org/wiki/Iteratively_reweighted_least_squares
                        // SampleWeight canceled out.
                        float3 W = 1.f / max(abs(DiffRadiance)/* * SampleWeight */, 1e-3f);
                        SumAFactor                += 2.f * SGEvaluatedRaw * SGEvaluatedRaw /* * SampleWeight */ * SampleWeight * W;
                        SumStepSize.dColor        += 2.f * TargetRadiance * SGEvaluatedRaw /* * SampleWeight */ * SampleWeight * W;
                    }
#else
                    // least squares method
                    // Clip rays that only evaluates to a tiny value on SG to prevent outflares
                    if(SGEvaluatedRaw > 1e-2f || dot(TargetRadiance, 1.f.xxx) < dot(SGEvaluatedRadiance, 1.f.xxx)) {
                        SumAFactor                += 2.f * SGEvaluatedRaw * SGEvaluatedRaw * SampleWeight;
                        SumStepSize.dColor        += 2.f * TargetRadiance * SGEvaluatedRaw * SampleWeight;
                    }
#endif
                    // 0529: Add a bias to reserve affection for closer light sources in the same direction
                    float  HeuristicBias = HeuristicSGDirectionBias(SG.Direction, RayDirection);
                    float  DirectionalDecay  = 1.f;//pow(HeuristicBias / LocalRayCoverage[RayRank], 6);
                    SumStepSize.dLambda    -= Y * Gradients.dLambda    * SampleWeight * DirectionalDecay;
                }
            }
        }

        // Accumulate weights
        SumAFactor = WaveActiveSum(SumAFactor);
        SumStepSize.dColor  = WaveActiveSum(SumStepSize.dColor);
        SumStepSize.dLambda = WaveActiveSum(SumStepSize.dLambda);
        GroupMemoryBarrierWithGroupSync();
        // The chosen thread for updating each basis
        if(WaveIsFirstLane()) {
            // It's possible for SumAFactor to be very tiny (because of large SG Lambdas), so we clamp it to prevent outflares
            SumStepSize.dColor     /= max(SumAFactor, Epsilon);

            if(MI.CacheUpdate_SGColor) {
                // TODO Clamping is not the smartest choice for outflares
                // it relates to lambda and importance sampling
                float Factor = min(MI.CacheUpdateLearningRate + ImpactFactors.x, 1.f);
                // Allow the color of the SG with updated direction to change violently
                // if(MI.CacheUpdate_SGDirection && BasisRank == GetBasisRankToUpdate(BasisCount)) {
                //     Factor = max(Factor, 0.2f);
                // }
                float3 NewColor = lerp(SG.Color, SumStepSize.dColor, Factor);
                float3 DeltaColor = NewColor - SG.Color;
                SG.Color += DeltaColor;
                SG.Color = max(SG.Color, 0.00001f.xxx); // Color is in [0.001, inf)
            }
            if(MI.CacheUpdate_SGLambda) {
                float Step = SumStepSize.dLambda    * MI.CacheUpdateLearningRate * (1 + ImpactFactors.z);
                // FIXME better lambda update
                float Factor = exp(Step);
                Factor = clamp(Factor, 0.82f, 1.2f);
                SG.Lambda *= Factor;
                // SG.Lambda    += Step;
                SG.Lambda    = clamp(SG.Lambda, MIN_SG_LAMBDA, MAX_SG_LAMBDA); // Lambda is in [MIN_SG_LAMBDA, 200.f]
            }
            // FIXME SG depth is never updated

            // Write back
            WriteBasisData(Header.BasisOffset + BasisRank, SG);
        }
    }
}

// From Lumen
float GetFilterPositionWeight(float NeighborLinearDepth, float LinearDepth)
{
	float DepthDifference = abs(NeighborLinearDepth - LinearDepth);
	float RelativeDepthDifference = DepthDifference / LinearDepth;
	return exp2(-1000.f * (RelativeDepthDifference * RelativeDepthDifference));
}

void GatherProbeRadiance (
    float3 Position,
    float  LinearDepth,
    float3 HitPosition,
    int2   NeighborProbeIndex,
    inout float3 SumRadiance,
    inout float  SumWeight
) {
    if(all(NeighborProbeIndex >= 0) && all(NeighborProbeIndex < MI.TileDimensions)) {
        float NeighborLinearDepth = GetScreenProbeLinearDepth(NeighborProbeIndex);
        if(NeighborLinearDepth > 0) { // Valid
            float PositionWeight = GetFilterPositionWeight(NeighborLinearDepth, LinearDepth);
            if(PositionWeight > 0) {
                float3 NeighborWorldPosition = GetScreenProbePosition(NeighborProbeIndex);
                float3 ToNeighbor = HitPosition - NeighborWorldPosition;
                float  ToNeighborLength = max(length(ToNeighbor), 1e-3f);
                float3 ToNeighborUnit = ToNeighbor / ToNeighborLength;
                float3 NeighborProbeNormal = GetScreenProbeNormal(NeighborProbeIndex);
                float3 Tangent, Bitangent;
                GetOrthoVectors(NeighborProbeNormal, Tangent, Bitangent);
                float3 NeighborProbeLocalDirection = float3(
                    dot(Tangent,   ToNeighborUnit),
                    dot(Bitangent, ToNeighborUnit),
                    dot(NeighborProbeNormal, ToNeighborUnit)
                );
                if(NeighborProbeLocalDirection.z > 0) {
                    float2 NeighborProbeUV = UnitVectorToHemiOctahedron01(NeighborProbeLocalDirection);
                    int2   NeighborTexelCoords = clamp(NeighborProbeUV * SSRC_PROBE_TEXTURE_SIZE, 0, SSRC_PROBE_TEXTURE_SIZE - 1);
                    float4 NeighborRadianceDepth = GetScreenProbeOctahedronRadianceDepth(NeighborProbeIndex, NeighborTexelCoords);
                    float3 NeighborRadiance = NeighborRadianceDepth.xyz;
                    float  NeighborDepth = NeighborRadianceDepth.w;
                    float  DepthWeight = 1 - abs(NeighborDepth - ToNeighborLength) / max(1e-3f, max(NeighborDepth, ToNeighborLength));
                    DepthWeight = pow(saturate(DepthWeight), 6);
                    float  Weight = PositionWeight * DepthWeight;
                    SumRadiance += NeighborRadiance * Weight;
                    SumWeight   += Weight;
                }
            }
        }
    }
    
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_FilterProbes (int GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {

    int2 ProbeIndex = int2(GroupID % MI.TileDimensions.x, GroupID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    // Thread group early out if the probe is not valid
    [branch]
    if(!Header.bValid) return ;
    
    int2 ProbeScreenCoords  = Header.ScreenCoords;
    int2 TileIndex = int2(ProbeScreenCoords / SSRC_TILE_SIZE);
    float  ReprojectionTrust = g_RWProbeHistoryTrustTexture[ProbeIndex].x;

    float3 Tangent, Bitangent;
    GetOrthoVectors(Header.Normal, Tangent, Bitangent);

    float3 SH_Coefficients[9];
    for(int i = 0; i < 9; i++) {
        SH_Coefficients[i] = 0.f;
    }

    for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
        int  ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
        int2 ProbeTexelCoords = int2(ProbeTexelIndex % SSRC_PROBE_TEXTURE_SIZE, ProbeTexelIndex / SSRC_PROBE_TEXTURE_SIZE);
        float2 ProbeTexelUV = (ProbeTexelCoords + 0.5f) / SSRC_PROBE_TEXTURE_SIZE;
        float3 ProbeLocalTexelDirection = HemiOctahedron01ToUnitVector(ProbeTexelUV);
        float3 ProbeWorldTexelDirection = 
            Tangent * ProbeLocalTexelDirection.x 
          + Bitangent * ProbeLocalTexelDirection.y
          + Header.Normal * ProbeLocalTexelDirection.z;
        float4  TexelRadianceDepth = GetScreenProbeOctahedronRadianceDepth(ProbeIndex, ProbeTexelCoords);
        float3 HitPosition = Header.Position + ProbeWorldTexelDirection * TexelRadianceDepth.w;

        float3 SumRadiance = TexelRadianceDepth.xyz;
        float  SumWeight = 1.f;

        if(MI.ProbeFiltering) {
            int2 Offsets[4];
            Offsets[0] = int2(-1, 0);
            Offsets[1] = int2(1, 0);
            Offsets[2] = int2(0, -1);
            Offsets[3] = int2(0, 1);
            for (uint OffsetIndex = 0; OffsetIndex < 4; OffsetIndex++)
            {
                GatherProbeRadiance(
                    Header.Position,
                    Header.LinearDepth,
                    HitPosition,
                    TileIndex + Offsets[OffsetIndex],
                    SumRadiance,
                    SumWeight
                );
            }
        }

        if(MI.ProbeFiltering && ReprojectionTrust < 0.8f) {
            int2 Offsets[8];
            Offsets[0] = int2(-2, 0);
            Offsets[1] = int2(2, 0);
            Offsets[2] = int2(0, -2);
            Offsets[3] = int2(0, 2);
            Offsets[4] = int2(-1, 1);
            Offsets[5] = int2(1, 1);
            Offsets[6] = int2(-1, -1);
            Offsets[7] = int2(1, -1);
            for (uint OffsetIndex = 0; OffsetIndex < 8; OffsetIndex++)
            {
                GatherProbeRadiance(
                    Header.Position,
                    Header.LinearDepth,
                    HitPosition,
                    TileIndex + Offsets[OffsetIndex],
                    SumRadiance,
                    SumWeight
                );
            }
        }
    
        float3 NewRadiance = SumRadiance / SumWeight;
        float4 NewRadianceDepth = float4(NewRadiance, TexelRadianceDepth.w);
        WriteScreenProbeOctahedronRadianceDepth(ProbeIndex, ProbeTexelCoords, NewRadianceDepth, true);

        // Accumulate SH coefficients
        float  Coefficients[9];
        SH_GetCoefficients(ProbeWorldTexelDirection, Coefficients);
        float AreaCorrection = 1.f;
#ifdef UE_STYLE_HEMISPHERICAL_OCT_MAPPING
        AreaCorrection = SSRC_PROBE_TEXTURE_TEXEL_COUNT * g_UEHemiOctahedronCorrectionLutTexture.Load(int3(ProbeTexelCoords, 0)).x;
#endif
        for(int i = 0; i < 9; i++) {
            SH_Coefficients[i] += Coefficients[i] * NewRadiance * AreaCorrection;
        }
    }

    // Write SH coefficients
    for(int i = 0; i<9; i++) {
        // Multiply by TWO_PI to monte-carlo integrate to retrieve the coefficients
        // (TWO_PI: Hemispherical integration)
        SH_Coefficients[i] = WaveActiveSum(SH_Coefficients[i]) * (1.f / SSRC_PROBE_TEXTURE_TEXEL_COUNT) * TWO_PI;
    }
    if(WaveIsFirstLane()) {
        WriteScreenProbeSHCoefficients(ProbeIndex, SH_Coefficients);
    }
    // TODO filter SG

}


[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_PadProbeTextureEdges (int GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {

    int2 ProbeIndex = int2(GroupID % MI.TileDimensions.x, GroupID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    // Thread group early out if the probe is not valid
    [branch]
    if(!Header.bValid) return ;
    int2 BaseSrcTexCoords = ProbeIndex * SSRC_PROBE_TEXTURE_SIZE;
    int2 BaseDstTexCoords = ProbeIndex * (SSRC_PROBE_TEXTURE_SIZE + 2);
    
    if(LocalID < SSRC_PROBE_TEXTURE_SIZE + 2) {
        g_RWProbeSampleColorTexture[BaseDstTexCoords + int2(LocalID, 0)] = g_RWProbeColorTexture[BaseSrcTexCoords + int2(clamp(LocalID - 1, 0, SSRC_PROBE_TEXTURE_SIZE - 1), 0)];
        g_RWProbeSampleColorTexture[BaseDstTexCoords + int2(LocalID, SSRC_PROBE_TEXTURE_SIZE + 1)] = g_RWProbeColorTexture[BaseSrcTexCoords + int2(clamp(LocalID - 1, 0, SSRC_PROBE_TEXTURE_SIZE - 1), SSRC_PROBE_TEXTURE_SIZE - 1)];
    }
    if(LocalID < SSRC_PROBE_TEXTURE_SIZE) {
        g_RWProbeSampleColorTexture[BaseDstTexCoords + int2(0, LocalID + 1)] = g_RWProbeColorTexture[BaseSrcTexCoords + int2(0, LocalID)];
        g_RWProbeSampleColorTexture[BaseDstTexCoords + int2(SSRC_PROBE_TEXTURE_SIZE + 1, LocalID + 1)] = g_RWProbeColorTexture[BaseSrcTexCoords + int2(SSRC_PROBE_TEXTURE_SIZE - 1, LocalID)];
    }
    for(int BaseTexelRank = 0; BaseTexelRank < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseTexelRank += WAVE_SIZE) {
        int TexelRank = BaseTexelRank + LocalID;
        int2 TexelCoords = int2(TexelRank % SSRC_PROBE_TEXTURE_SIZE, TexelRank / SSRC_PROBE_TEXTURE_SIZE);
        int2 SrcTexCoords = BaseSrcTexCoords + TexelCoords;
        int2 DstTexCoords = BaseDstTexCoords + TexelCoords + 1.xx;
        g_RWProbeSampleColorTexture[DstTexCoords] = g_RWProbeColorTexture[SrcTexCoords];
    }
}

void GetScreenProbeSHCoefficients (int2 ProbeIndex, out float3 ProbeSH[9]) {
    float4 R1 = g_RWProbeSHCoefficientsRTexture[ProbeIndex];
    float4 R2 = g_RWProbeSHCoefficientsRTexture[ProbeIndex + int2(MI.TileDimensions.x, 0)];
    float4 G1 = g_RWProbeSHCoefficientsGTexture[ProbeIndex];
    float4 G2 = g_RWProbeSHCoefficientsGTexture[ProbeIndex + int2(MI.TileDimensions.x, 0)];
    float4 B1 = g_RWProbeSHCoefficientsBTexture[ProbeIndex];
    float4 B2 = g_RWProbeSHCoefficientsBTexture[ProbeIndex + int2(MI.TileDimensions.x, 0)];
    float3 RGB0 = g_RWProbeIrradianceTexture[ProbeIndex].xyz;
    ProbeSH[0] = RGB0;
    ProbeSH[1] = float3(R1.x, G1.x, B1.x);
    ProbeSH[2] = float3(R1.y, G1.y, B1.y);
    ProbeSH[3] = float3(R1.z, G1.z, B1.z);
    ProbeSH[4] = float3(R1.w, G1.w, B1.w);
    ProbeSH[5] = float3(R2.x, G2.x, B2.x);
    ProbeSH[6] = float3(R2.y, G2.y, B2.y);
    ProbeSH[7] = float3(R2.z, G2.z, B2.z);
    ProbeSH[8] = float3(R2.w, G2.w, B2.w);
}

// Modified from GI1.0
// Evaluates the irradiance from the probe's SH representation using a bent cone.
float3 ProbeIntegrateBentCone(float3 normal, float ao, int2 ProbeIndex)
{
    float ClampedCosineSH[9];
    SH_GetCoefficients_ClampedCosine_Cone(normal, acos(sqrt(saturate(1.0f - ao))), ClampedCosineSH);

    float3 irradiance = float3(0.0f, 0.0f, 0.0f);
    float3 ProbeSH[9];
    GetScreenProbeSHCoefficients(ProbeIndex, ProbeSH);
    for (uint i = 0; i < 9; ++i)
    {
        irradiance += ClampedCosineSH[i] * ProbeSH[i];
    }

    return max(irradiance, 0.0f);
}

float4 SampleScreenProbeRadianceDepth (int2 ProbeIndex, float3 LocalDirection) {
    float2 TexelPosition = SSRC_PROBE_TEXTURE_SIZE * UnitVectorToHemiOctahedron01(LocalDirection);
    float2 AtlasPosition = TexelPosition + ProbeIndex * (SSRC_PROBE_TEXTURE_SIZE + 2) + 1.xx;
    uint2  Dimensions;
    g_ProbeSampleColorTexture.GetDimensions(Dimensions.x, Dimensions.y);
    float2 AtlasUV = AtlasPosition / Dimensions;
    return g_ProbeSampleColorTexture.SampleLevel(g_LinearSampler, AtlasUV, 0);
}


[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_IntegrateASG (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * MI.TileDimensions.x;
    int2 TileTextureBaseOffset = int2(GroupID) * SSRC_TILE_SIZE;
    const int PIXEL_PER_THREAD = SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE;
    Random rng = MakeRandom(TileID, LocalID);
    for(int i = 0; i< PIXEL_PER_THREAD; i++) {
        int PixelIndex = i * WAVE_SIZE + LocalID;
        // Operate in subtiles (8x8) to get better coherency in loop branching
        // with the more likely the same number of basis to access for each thread
        int SubtileIndex  = PixelIndex / (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int SubPixelIndex = PixelIndex % (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int PixelX = (SSRC_TILE_SIZE/2) * (SubtileIndex % 2) + SubPixelIndex % (SSRC_TILE_SIZE/2);
        int PixelY = (SSRC_TILE_SIZE/2) * (SubtileIndex / 2) + SubPixelIndex / (SSRC_TILE_SIZE/2);
        int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
        float2 UV = (TexCoords + 0.5f) / MI.ScreenDimensions;
        float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
        if(Depth < 1.f) {
            float LinearDepth   = GetLinearDepth(Depth);
            // Texture coordinates
            float4 Visibility   = g_VisibilityTexture[TexCoords];
            float2 Barycentrics = Visibility.xy;
            uint   InstanceID   = asuint(Visibility.z);
            uint   PrimitiveID  = asuint(Visibility.w);

            Instance InstanceData = g_InstanceBuffer[InstanceID];
            Mesh     mesh     = g_MeshBuffer[InstanceData.mesh_index];

            Triangle vertices = fetchVertices(mesh, PrimitiveID);

            // Reconstruct world space position from barycentrics
            float3x4 transform = g_TransformBuffer[InstanceData.transform_index];
            vertices.v0 = transformPoint(vertices.v0, transform);
            vertices.v1 = transformPoint(vertices.v1, transform);
            vertices.v2 = transformPoint(vertices.v2, transform);

            // Frame
            float3 WorldPosition = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);
            float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
            float3 ShadingNormal  = normalize(2.f * g_ShadingNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);

            UVs PrimitiveUVs = fetchUVs(g_MeshBuffer[InstanceData.mesh_index], PrimitiveID);
            float2 MeshUV = interpolate(PrimitiveUVs.uv0, PrimitiveUVs.uv1, PrimitiveUVs.uv2, Barycentrics);
            Material MaterialData = g_MaterialBuffer[InstanceData.material_index];
            MaterialEmissive EmissiveMaterialData = MakeMaterialEmissive(MaterialData, MeshUV);
            MaterialBRDF MaterialBRDFData = MakeMaterialBRDF(MaterialData, MeshUV);
            
            float3 ViewDirection = normalize(MI.CameraPosition - WorldPosition);
            float DotNV = saturate(dot(ShadingNormal, ViewDirection));

            SSRC_SampleData Sample;
            CalculateSSRCSampleWeights(
                TexCoords + 0.5f,
                WorldPosition,
                LinearDepth, 
                GeometryNormal,
                true,
                Sample
            );

            ProbeHeader Headers[4];
            Headers[0] = GetScreenProbeHeader(Sample.Index[0]);
            Headers[1] = GetScreenProbeHeader(Sample.Index[1]);
            Headers[2] = GetScreenProbeHeader(Sample.Index[2]);
            Headers[3] = GetScreenProbeHeader(Sample.Index[3]);
            float3 ProbeTangents[4];
            float3 ProbeBitangents[4];
            for(int i = 0; i < 4; i++) {
                GetOrthoVectors(Headers[i].Normal, ProbeTangents[i], ProbeBitangents[i]);
            }
            int BasisCounts[4];
            BasisCounts[0] = GetProbeBasisCountFromClass(Headers[0].Class);
            BasisCounts[1] = GetProbeBasisCountFromClass(Headers[1].Class);
            BasisCounts[2] = GetProbeBasisCountFromClass(Headers[2].Class);
            BasisCounts[3] = GetProbeBasisCountFromClass(Headers[3].Class);
            int BasisCount0 = BasisCounts[0] + BasisCounts[1];
            int BasisCount1 = BasisCounts[2] + BasisCounts[3];
            int BasisCount  = BasisCount0 + BasisCount1;
            // Normalize weights
            Sample.Weights /= max(dot(Sample.Weights, 1.f.xxxx), 0.01f);
            if(dot(Sample.Weights, 1.f.xxxx) > 0.99f) {
                // Lighting is split into 3 parts:
                // 1. High frequency incident radiance + all frequency BSDF (ASG integration with SG radiance cache)
                // 2. Low frequency incident radiance + diffuse BSDF  (probe octahedron radiance cache)
                // 3. Low frequency incident radiance + specular BSDF (specular ray tracing)

                float  AO = MI.UseAmbientOcclusion 
                    ? g_BentNormalAndOcclusionTexture.Load(int3(TexCoords, 0)).w
                    : 1.f;
                float3 ReflectionDirection = calculateGGXSpecularDirection(ShadingNormal, ViewDirection, sqrt(MaterialBRDFData.roughnessAlpha));
                float3 HalfVector_Spec = normalize(ReflectionDirection + ViewDirection);
                float dotSpecHV = saturate(dot(HalfVector_Spec, ViewDirection));
                // Approximate the Fresnel term with the ReflectionDirection as light direction
                // which is the same approximation used by GI1.0
                float3 FresnelTerm = fresnel(MaterialBRDFData.F0, dotSpecHV);
                float3 DiffuseCompensation = diffuseCompensationTerm(FresnelTerm, dotSpecHV);

                float3 HighFreq_Diffuse = 0.f.xxx;
                float3 HighFreq_Glossy  = 0.f.xxx;
                // HighFreq-AllFreq shading
                [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
                for(int BasisRank = 0; BasisRank < BasisCount; BasisRank++) {
                    int ProbeRank, ProbeBasisIndex;
                    if(BasisRank < BasisCount0) {
                        ProbeRank = BasisRank < BasisCounts[0] ? 0 : 1;
                        ProbeBasisIndex = BasisRank - (BasisRank < BasisCounts[0] ? 0 : BasisCounts[0]);
                    } else {
                        ProbeBasisIndex = BasisRank - BasisCount0;
                        ProbeRank = ProbeBasisIndex < BasisCounts[2] ? 2 : 3;
                        ProbeBasisIndex -= (ProbeBasisIndex < BasisCounts[2] ? 0 : BasisCounts[2]);
                    }
                    int BasisIndex = Headers[ProbeRank].BasisOffset + ProbeBasisIndex;
                    SGData SG = FetchBasisData(BasisIndex);
                    float3 LightDirection = SG.Direction;                    
                    float3 HalfVector = normalize(LightDirection + ViewDirection);
                    float dotNL = saturate(dot(LightDirection, ShadingNormal));
                    float dotNV = saturate(dot(ShadingNormal, ViewDirection));
                    float dotHV = saturate(dot(HalfVector, ViewDirection));
                    // Approximate \int D * Li with ASG
                    // we use RoughnessAlpha here
                    float3 GGX_D_Li_Approx = SpecularTermASGWarp(SG, ShadingNormal, MaterialBRDFData.roughnessAlphaSqr, ViewDirection);
                    float  VisibilityTerm   = evaluateVisibilityGGX(MaterialBRDFData.roughnessAlphaSqr, dotNL, dotNV);
                    float3 GGXIntegrationApprox = (FresnelTerm / VisibilityTerm) * GGX_D_Li_Approx;
                    // Albedo is later applied for diffuse lighting
#ifndef HIGH_PRECISION_SG_INTEGRATION
                    float3 Irradiance = SGIrradianceInnerProduct(SG, ShadingNormal);
#else
                    float3 Irradiance = SGIrradianceInnerProduct_HighPrecision(SG, ShadingNormal);
#endif
                    HighFreq_Diffuse += Irradiance           * Sample.Weights[ProbeRank] * AO;
                    HighFreq_Glossy  += GGXIntegrationApprox * Sample.Weights[ProbeRank] * AO;
                }
                // LowFreq-Diffuse shading
                float3 LowFreq_Diffuse = 0.f.xxx;
                [unroll(4)]
                for(int CornerIndex = 0; CornerIndex < 4; CornerIndex ++) {
                    if(Sample.Weights[CornerIndex] > 0.f) { 
                        float3 Irradiance = ProbeIntegrateBentCone(ShadingNormal, AO, Sample.Index[CornerIndex]);
                        float3 WeightedIrradiance = Irradiance * Sample.Weights[CornerIndex];
                        LowFreq_Diffuse += WeightedIrradiance * AO;
                    }
                }
                
                float3 LowFreq_Specular = 0.f.xxx;
                // Use radiance values from probes directly for low frequency specular
#if false
                float2 LUT = g_LutBuffer.SampleLevel(g_LinearSampler, float2(saturate(dot(ShadingNormal, ViewDirection)), sqrt(MaterialBRDFData.roughnessAlpha)), 0.0f).xy;
                float3 SpecularAlbedo = saturate(MaterialBRDFData.F0 * LUT.x + (1.0f - MaterialBRDFData.F0) * LUT.y);
                
                [unroll(4)]
                for(int SampleIndex = 0; SampleIndex < 4; SampleIndex++) {
                    float2 u2 = rng.rand2();
                    Quaternion LocalRotation = QuaternionRotationZ(ShadingNormal);
                    float3 LocalViewDirection = LocalRotation.transform(ViewDirection);
                    float  ClampedRA = max(0.000001f, MaterialBRDFData.roughnessAlpha);
                    float3 LocalSampleDirection = sampleGGX(ClampedRA, LocalViewDirection, u2);
                    float3 SampleDirection = normalize(LocalRotation.inverse().transform(LocalSampleDirection));
                    for(int CornerIndex = 0; CornerIndex < 4; CornerIndex ++) {
                        if(Sample.Weights[CornerIndex] > 0.f) {
                            convert sample direction to probe local space!!!
                            float3 Radiance = SampleScreenProbeRadiance(Sample.Index[CornerIndex], SampleDirection);
                            LowFreq_Specular += Radiance * Sample.Weights[CornerIndex];
                        }
                    }
                }
                LowFreq_Specular = SpecularAlbedo * LowFreq_Specular;
#else
                
                float2 LUT = g_LutBuffer.SampleLevel(g_LinearSampler, float2(saturate(dot(ShadingNormal, ViewDirection)), sqrt(MaterialBRDFData.roughnessAlpha)), 0.0f).xy;
                float3 SpecularAlbedo = saturate(MaterialBRDFData.F0 * LUT.x + (1.0f - MaterialBRDFData.F0) * LUT.y);
                
                for(int CornerIndex = 0; CornerIndex < 4; CornerIndex ++) {
                    if(Sample.Weights[CornerIndex] > 0.f) {
                        float3 LocalReflectionDirection = float3(
                            dot(ProbeTangents[CornerIndex],   ReflectionDirection),
                            dot(ProbeBitangents[CornerIndex], ReflectionDirection),
                            dot(Headers[CornerIndex].Normal, ReflectionDirection)
                        );
                        if(LocalReflectionDirection.z > 0.f) {
                            float4 RadianceDepth = SampleScreenProbeRadianceDepth(Sample.Index[CornerIndex], LocalReflectionDirection);
                            // Fade specular radiance near occlusions to give more accurate reflections
                            float  DistanceFade  = RadianceDepth.w / max(1e-3f, Headers[CornerIndex].LinearDepth);
                            DistanceFade = saturate(DistanceFade * DistanceFade);
                            LowFreq_Specular += RadianceDepth.xyz * DistanceFade * Sample.Weights[CornerIndex];
                        }
                    }
                }
                LowFreq_Specular = SpecularAlbedo * LowFreq_Specular;

#endif

                // Composite final lighting
                float3 FarFieldIrradiance  = (HighFreq_Diffuse + LowFreq_Diffuse) * DiffuseCompensation;
                float3 NearFieldIrradiance = MI.UseNearFieldGI 
                    ? g_NearFieldGlobalIlluminationTexture.Load(int3(TexCoords, 0)).xyz
                    : 0.f;
                float3 FarFieldGlossySpecular = (HighFreq_Glossy + LowFreq_Specular) * AO;

                // Write to output                
                g_RWIrradianceTexture[TexCoords] = float4(FarFieldIrradiance + NearFieldIrradiance,  1.f);
                g_RWGlossySpecularTexture[TexCoords] = float4(FarFieldGlossySpecular, 1.f);
            } else {
                g_RWIrradianceTexture[TexCoords] = float4(0.f, 0.f, 0.f, 0.f);
                g_RWGlossySpecularTexture[TexCoords] = float4(0.f, 0.f, 0.f, 0.f);
            }
        } else {
            g_RWIrradianceTexture[TexCoords] = float4(0.f, 0.f, 0.f, 0.f);
            g_RWGlossySpecularTexture[TexCoords] = float4(0.f, 0.f, 0.f, 0.f);
        }
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_IntegrateDDGI (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * MI.TileDimensions.x;
    int2 TileTextureBaseOffset = int2(GroupID) * SSRC_TILE_SIZE;
    const int PIXEL_PER_THREAD = SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE;
    Random rng = MakeRandom(TileID, LocalID);
    for(int i = 0; i< PIXEL_PER_THREAD; i++) {
        int PixelIndex = i * WAVE_SIZE + LocalID;
        // Operate in subtiles (8x8) to get better coherency in loop branching
        // with the more likely the same number of basis to access for each thread
        int SubtileIndex  = PixelIndex / (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int SubPixelIndex = PixelIndex % (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int PixelX = (SSRC_TILE_SIZE/2) * (SubtileIndex % 2) + SubPixelIndex % (SSRC_TILE_SIZE/2);
        int PixelY = (SSRC_TILE_SIZE/2) * (SubtileIndex / 2) + SubPixelIndex / (SSRC_TILE_SIZE/2);
        int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
        float2 UV = (TexCoords + 0.5f) / MI.ScreenDimensions;
        float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
        if(Depth < 1.f) {
            float LinearDepth   = GetLinearDepth(Depth);
            // Texture coordinates
            float4 Visibility   = g_VisibilityTexture[TexCoords];
            float2 Barycentrics = Visibility.xy;
            uint   InstanceID   = asuint(Visibility.z);
            uint   PrimitiveID  = asuint(Visibility.w);

            Instance InstanceData = g_InstanceBuffer[InstanceID];
            Mesh     mesh     = g_MeshBuffer[InstanceData.mesh_index];

            Triangle vertices = fetchVertices(mesh, PrimitiveID);

            // Reconstruct world space position from barycentrics
            float3x4 transform = g_TransformBuffer[InstanceData.transform_index];
            vertices.v0 = transformPoint(vertices.v0, transform);
            vertices.v1 = transformPoint(vertices.v1, transform);
            vertices.v2 = transformPoint(vertices.v2, transform);

            // Frame
            float3 WorldPosition = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);
            float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
            float3 ShadingNormal  = normalize(2.f * g_ShadingNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);

            UVs PrimitiveUVs = fetchUVs(g_MeshBuffer[InstanceData.mesh_index], PrimitiveID);
            float2 MeshUV = interpolate(PrimitiveUVs.uv0, PrimitiveUVs.uv1, PrimitiveUVs.uv2, Barycentrics);
            Material MaterialData = g_MaterialBuffer[InstanceData.material_index];
            MaterialEmissive EmissiveMaterialData = MakeMaterialEmissive(MaterialData, MeshUV);
            MaterialBRDF MaterialBRDFData = MakeMaterialBRDF(MaterialData, MeshUV);
            
            float3 ViewDirection = normalize(MI.CameraPosition - WorldPosition);
            float DotNV = saturate(dot(ShadingNormal, ViewDirection));

            WorldCacheSample Sample = WorldCache_SampleProbes(
                WorldPosition,
                WorldPosition + GeometryNormal * WorldCache_GetSampleOffsetAmount(WorldPosition),
                GeometryNormal,
                LinearDepth, 
                false,
                false,
                true
            );
            {
                float  AO = MI.UseAmbientOcclusion 
                    ? g_BentNormalAndOcclusionTexture.Load(int3(TexCoords, 0)).w
                    : 1.f;
                float3 ReflectionDirection = calculateGGXSpecularDirection(ShadingNormal, ViewDirection, sqrt(MaterialBRDFData.roughnessAlpha));
                float3 HalfVector_Spec = normalize(ReflectionDirection + ViewDirection);
                float dotSpecHV = saturate(dot(HalfVector_Spec, ViewDirection));
                // Approximate the Fresnel term with the ReflectionDirection as light direction
                // which is the same approximation used by GI1.0
                float3 FresnelTerm = fresnel(MaterialBRDFData.F0, dotSpecHV);
                float3 DiffuseCompensation = diffuseCompensationTerm(FresnelTerm, dotSpecHV);

                float3 Diffuse = 0.f.xxx;
                float3 Specular = 0.f.xxx;
                
                float2 LUT = g_LutBuffer.SampleLevel(g_LinearSampler, float2(saturate(dot(ShadingNormal, ViewDirection)), sqrt(MaterialBRDFData.roughnessAlpha)), 0.0f).xy;
                float3 SpecularAlbedo = saturate(MaterialBRDFData.F0 * LUT.x + (1.0f - MaterialBRDFData.F0) * LUT.y);
                
                for(int ProbeIndex = 0; ProbeIndex < 8; ProbeIndex ++) {
                    if(WorldCache_IsProbeIndexValid(Sample.ProbeIndex[ProbeIndex])
                     && Sample.Weights[ProbeIndex] > 0.f) {
                        int2 AtlasBase = WorldCache_GetProbeAtlasBase(Sample.ProbeIndex[ProbeIndex]); 
                        float2 Oct01 = UnitVectorToHemiOctahedron01(ShadingNormal);
                        float2 TexelPosition = float2(Oct01 * WORLD_CACHE_PROBE_RESOLUTION_INTERNAL + 1 + AtlasBase);
                        float2 UV = TexelPosition * WorldCache.InvAtlasDimensions;
                        float3 Irradiance = 
                            g_WorldCacheIrradiance2PLuminanceTexture.SampleLevel(g_LinearSampler, UV, 0).xyz
                            * TWO_PI;
                        float3 WeightedIrradiance = Irradiance * Sample.Weights[ProbeIndex];
                        Diffuse += WeightedIrradiance * AO;
                        // Specular += WeightedIrradiance * AO;
                    }
                }
                
                Specular = SpecularAlbedo * Specular;

                // Composite final lighting
                float3 FarFieldIrradiance  = Diffuse * DiffuseCompensation;
                float3 NearFieldIrradiance = MI.UseNearFieldGI 
                    ? g_NearFieldGlobalIlluminationTexture.Load(int3(TexCoords, 0)).xyz
                    : 0.f;
                float3 GlossySpecular = Specular * AO;

                // Write to output                
                g_RWIrradianceTexture[TexCoords] = float4(FarFieldIrradiance + NearFieldIrradiance,  1.f);
                g_RWGlossySpecularTexture[TexCoords] = float4(GlossySpecular, 1.f);
            }
        } else {
            g_RWIrradianceTexture[TexCoords] = float4(0.f, 0.f, 0.f, 0.f);
            g_RWGlossySpecularTexture[TexCoords] = float4(0.f, 0.f, 0.f, 0.f);
        }
    }
}

#define MAX_TEMPORAL_ACCUMULATION 10

// https://www.gdcvault.com/play/1022970/Temporal-Reprojection-Anti-Aliasing-in
float2 GetClosestVelocity(in float2 uv, in float2 texel_size, out bool is_sky_pixel)
{
    float2 velocity;
    float  closest_depth = 9.9f;

    for (int y = -1; y <= 1; ++y)
    {
        for (int x = -1; x <= 1; ++x)
        {
            float2 st    = uv + float2(x, y) * texel_size;
            float  depth = g_DepthTexture.SampleLevel(g_NearestSampler, st, 0.0f).x;

            if (depth < closest_depth)
            {
                velocity      = g_VelocityTexture.SampleLevel(g_NearestSampler, st, 0.0f).xy;
                closest_depth = depth;
            }
        }
    }

    is_sky_pixel = (closest_depth >= 1.0f);

    return velocity;
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_Denoise (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * MI.TileDimensions.x;
    int2 TileTextureBaseOffset = int2(GroupID) * SSRC_TILE_SIZE;
    const int PIXEL_PER_THREAD = SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE;
    for(int i = 0; i< PIXEL_PER_THREAD; i++) {
        int PixelIndex = i * WAVE_SIZE + LocalID;
        // Operate in subtiles (8x8)
        int SubtileIndex  = PixelIndex / (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int SubPixelIndex = PixelIndex % (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int PixelX = (SSRC_TILE_SIZE/2) * (SubtileIndex % 2) + SubPixelIndex % (SSRC_TILE_SIZE/2);
        int PixelY = (SSRC_TILE_SIZE/2) * (SubtileIndex / 2) + SubPixelIndex / (SSRC_TILE_SIZE/2);
        int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
        float2 UV = (TexCoords + 0.5f) / MI.ScreenDimensions;
        float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
        if(Depth < 1.f) {
            float LinearDepth   = GetLinearDepth(Depth);
            // Texture coordinates
            float4 Visibility   = g_VisibilityTexture[TexCoords];
            float2 Barycentrics = Visibility.xy;
            uint   InstanceID   = asuint(Visibility.z);
            uint   PrimitiveID  = asuint(Visibility.w);

            Instance InstanceData = g_InstanceBuffer[InstanceID];
            Mesh     mesh     = g_MeshBuffer[InstanceData.mesh_index];

            Triangle vertices = fetchVertices(mesh, PrimitiveID);

            // Reconstruct world space position from barycentrics
            float3x4 transform = g_TransformBuffer[InstanceData.transform_index];
            vertices.v0 = transformPoint(vertices.v0, transform);
            vertices.v1 = transformPoint(vertices.v1, transform);
            vertices.v2 = transformPoint(vertices.v2, transform);

            // Frame
            float3 WorldPosition = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);
            float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
            float3 ShadingNormal  = normalize(2.f * g_ShadingNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);

            UVs PrimitiveUVs = fetchUVs(g_MeshBuffer[InstanceData.mesh_index], PrimitiveID);
            float2 MeshUV = interpolate(PrimitiveUVs.uv0, PrimitiveUVs.uv1, PrimitiveUVs.uv2, Barycentrics);
            Material MaterialData = g_MaterialBuffer[InstanceData.material_index];
            MaterialEmissive EmissiveMaterialData = MakeMaterialEmissive(MaterialData, MeshUV);
            MaterialBRDF MaterialBRDFData = MakeMaterialBRDF(MaterialData, MeshUV);
            
            float3 ViewDirection = normalize(MI.CameraPosition - WorldPosition);

            
            float4 NewIrradianceW    = g_RWIrradianceTexture[TexCoords];
            float3 NewGlossySpecular = g_RWGlossySpecularTexture[TexCoords].xyz;
            float3 NewIrradiance     = NewIrradianceW.xyz;
            float  NewLightingValid  = NewIrradianceW.w;
            float3 HistoryIrradiance = 0.f;
            float3 HistoryGlossySpecular     = 0.f;
            float3 DenoisedIrradiance = 0.f;
            float3 DenoisedGlossySpecular = 0.f;
            float  Alpha           = NewLightingValid > 0 ? 1.f : 0.f;
            float  TotalSamples    = NewLightingValid > 0 ? 1.f : 0.f;

            // Reproject to previous frame
            bool PreviousIsSkyPixel = false;
            float2 PreviousUV = UV - g_VelocityTexture.SampleLevel(g_NearestSampler, UV, 0).xy;
            //GetClosestVelocity(UV, MI.ScreenDimensionsInv, PreviousIsSkyPixel);

            if (!PreviousIsSkyPixel && all(PreviousUV >= 0.0f) && all(PreviousUV < 1.0f))
            {
                float3 Homogeneous     = float3(UV2NDC2(UV), Depth);
                float3 HomogeneousPrev = transformPointProjection(Homogeneous, MI.Reprojection);
                float  PreviousLinearDepth = GetLinearDepth(HomogeneousPrev.z);

                float2 PixelScale2 = 0.5f / MI.ScreenDimensions;
                float2 PixelScale  = 1.0f / MI.ScreenDimensions;

                // top-left corner pixel index for bilinear interpolation
                float2 PreviousBilinear         = PreviousUV * MI.ScreenDimensions - 0.5;
                float2 PreviousBilinearPixelPos = floor(PreviousBilinear);
                float2 PreviousBilinearSubpixel = frac(PreviousBilinear);
                float2 HistoryGatherUV          = (PreviousBilinearPixelPos + 1) * MI.ScreenDimensionsInv;

                float4 HistoryGBufferDepths  = g_PreviousDepthTexture.GatherRed(g_ClampedPointSampler, HistoryGatherUV).wzxy;
                float4 HistoryLinearDepths   = float4(
                    GetLinearDepth(HistoryGBufferDepths.x),
                    GetLinearDepth(HistoryGBufferDepths.y),
                    GetLinearDepth(HistoryGBufferDepths.z),
                    GetLinearDepth(HistoryGBufferDepths.w)
                );
                // Lumen alike method, jitter disocclusion threshold
                float Noise = BlueNoise_Sample1D(uint2(PixelX, PixelY), MI.FrameSeed, 9);
                float HistoryDistanceThreshold = 0.005f;
                float DisocclusionDistanceThreshold = HistoryDistanceThreshold * lerp(0.5f, 1.5f, Noise);
                DisocclusionDistanceThreshold /= clamp(saturate(dot(ViewDirection, GeometryNormal)), .1f, 1.0f); 
                float4 DepthDistances    = abs(HistoryLinearDepths - PreviousLinearDepth);
                float4 OcclusionWeights  = select(DepthDistances >= PreviousLinearDepth * DisocclusionDistanceThreshold, 1.f, 0.f);
                float4 VisibilityWeights = saturate(1.f - OcclusionWeights);
                float4 BilinearWeights   = float4(
                    (1.f - PreviousBilinearSubpixel.x) * (1.f - PreviousBilinearSubpixel.y),
                    PreviousBilinearSubpixel.x * (1.f - PreviousBilinearSubpixel.y),
                    (1.f - PreviousBilinearSubpixel.x) * PreviousBilinearSubpixel.y,
                    PreviousBilinearSubpixel.x * PreviousBilinearSubpixel.y
                );
                float4 NormalWeights = 1.f.xxxx;
#if false
                // Normal rejection
                {
                    float2 BaseUV = (PreviousBilinearPixelPos + 0.5f) * MI.ScreenDimensionsInv;
                    float3 HistoryNormalX00 = normalize(g_PreviousGeometryNormalTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV, 0.f
                    ).xyz * 2.f - 1.f);
                    float3 HistoryNormalX10 = normalize(g_PreviousGeometryNormalTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(PixelScale.x, 0), 0.f
                    ).xyz * 2.f - 1.f);
                    float3 HistoryNormalX01 = normalize(g_PreviousGeometryNormalTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(0,  PixelScale.y), 0.f
                    ).xyz * 2.f - 1.f);
                    float3 HistoryNormalX11 = normalize(g_PreviousGeometryNormalTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(PixelScale.x,  PixelScale.y), 0.f
                    ).xyz * 2.f - 1.f);
                    NormalWeights = float4(
                        saturate(dot(HistoryNormalX00, GeometryNormal)),
                        saturate(dot(HistoryNormalX10, GeometryNormal)),
                        saturate(dot(HistoryNormalX01, GeometryNormal)),
                        saturate(dot(HistoryNormalX11, GeometryNormal))
                    );
                    NormalWeights = select(NormalWeights < 0.5 + 0.5f * Noise, 0.f, 1.f);
                }
#endif
                float4 FinalWeights = BilinearWeights * VisibilityWeights * NormalWeights;

                FinalWeights = FinalWeights / max(dot(FinalWeights, 1.f.xxxx), 1e-5f);

                float4 HistorySamples    = 
                    g_PreviousHistoryAccumulationTexture.GatherRed(g_ClampedPointSampler, HistoryGatherUV).wzxy
                    * MAX_TEMPORAL_ACCUMULATION;
                TotalSamples = dot(min(HistorySamples + NewLightingValid, MAX_TEMPORAL_ACCUMULATION) * FinalWeights, 1.f.xxxx);
                TotalSamples = min(TotalSamples, MAX_TEMPORAL_ACCUMULATION);
                
                Alpha = NewLightingValid / max(TotalSamples, 1.f);
                
                {
                    // Note: PrevCombinedGlobalIllumination includes the skybox, so we manually keep a copy of ours
                    float2 BaseUV = (PreviousBilinearPixelPos + 0.5f) * MI.ScreenDimensionsInv;
                    float3 HistoryIrradianceX00 = g_PreviousIrradianceTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV, 0.f
                    ).xyz;
                    float3 HistoryIrradianceX10 = g_PreviousIrradianceTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(PixelScale.x, 0), 0.f
                    ).xyz;
                    float3 HistoryIrradianceX01 = g_PreviousIrradianceTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(0,  PixelScale.y), 0.f
                    ).xyz;
                    float3 HistoryIrradianceX11 = g_PreviousIrradianceTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(PixelScale.x,  PixelScale.y), 0.f
                    ).xyz;
                    HistoryIrradiance = 
                        HistoryIrradianceX00 * FinalWeights.x + 
                        HistoryIrradianceX10 * FinalWeights.y + 
                        HistoryIrradianceX01 * FinalWeights.z + 
                        HistoryIrradianceX11 * FinalWeights.w;
                    
                    float3 HistoryGlossySpecularX00 = g_PreviousGlossySpecularTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV, 0.f
                    ).xyz;
                    float3 HistoryGlossySpecularX10 = g_PreviousGlossySpecularTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(PixelScale.x, 0), 0.f
                    ).xyz;
                    float3 HistoryGlossySpecularX01 = g_PreviousGlossySpecularTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(0,  PixelScale.y), 0.f
                    ).xyz;
                    float3 HistoryGlossySpecularX11 = g_PreviousGlossySpecularTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(PixelScale.x,  PixelScale.y), 0.f
                    ).xyz;
                    HistoryGlossySpecular = 
                        HistoryGlossySpecularX00 * FinalWeights.x + 
                        HistoryGlossySpecularX10 * FinalWeights.y + 
                        HistoryGlossySpecularX01 * FinalWeights.z + 
                        HistoryGlossySpecularX11 * FinalWeights.w;

                }
            }
            if(MI.NoDenoiser) {
                Alpha = NewLightingValid > 0 ? 1.f : 0.f;
            }
            DenoisedIrradiance = lerp(HistoryIrradiance, NewIrradiance, Alpha);
            DenoisedGlossySpecular     = lerp(HistoryGlossySpecular, NewGlossySpecular, Alpha);
            g_RWIrradianceTexture[TexCoords] = float4(DenoisedIrradiance, 1.0f);
            g_RWGlossySpecularTexture[TexCoords] = float4(DenoisedGlossySpecular, 1.0f);
            g_RWHistoryAccumulationTexture[TexCoords] = TotalSamples / MAX_TEMPORAL_ACCUMULATION;

            // Shade
            float3 Albedo = MaterialBRDFData.albedo;
            // Save diffuse only lighting for GI reuse
            g_RWDiffuseGITexture[TexCoords] = float4(
                DenoisedIrradiance * evaluateLambert(Albedo) + EmissiveMaterialData.emissive,
                1.0f
            );
            g_RWGlobalIlluminationOutput[TexCoords] = float4(
                DenoisedIrradiance * evaluateLambert(Albedo) + DenoisedGlossySpecular + EmissiveMaterialData.emissive,
                1.0f
            );
        } else{
            // Sky
            g_RWHistoryAccumulationTexture[TexCoords] = 0.f;
            g_RWGlobalIlluminationOutput[TexCoords] = 0.f.xxxx;
        }        
    }
}

// [numthreads(WAVE_SIZE, 1, 1)]
// void SSRC_AccumulateUpdateError (int DispatchID : SV_DispatchThreadID) {
//     // >= 96 registers for each thread (meanwhile < 128)
//     // anyway that's not big deal
//     float ThreadErrorAccumulation[SSRC_TILE_SIZE][SSRC_TILE_SIZE];
//     float ThreadErrorAccumulationWeight[SSRC_TILE_SIZE][SSRC_TILE_SIZE];
//     for(int i = 0; i<SSRC_TILE_SIZE; i++) 
//         for(int j = 0; j<SSRC_TILE_SIZE; j++) {
//             ThreadErrorAccumulation[i][j] = 0;
//         }
//     for(int i = 0; i<SSRC_TILE_SIZE; i++) 
//         for(int j = 0; j<SSRC_TILE_SIZE; j++) {
//             ThreadErrorAccumulationWeight[i][j] = 0;
//         }
//     int2 TileCoords = int2(DispatchID % g_TileDimensions.x, DispatchID / g_TileDimensions.x);
//     int2 TexOffset = TileCoords * SSRC_TILE_SIZE;
//     int TileID = DispatchID;
//     int TileRayCount = g_RWTileRayCountBuffer[TileID];
//     int TileRayOffset = g_RWTileRayOffsetBuffer[TileID];
//     for(int TileRayRank = 0; TileRayRank < TileRayCount; TileRayRank++) {
//         int RayIndex = TileRayOffset + TileRayRank;
//         int2 TexCoords  = UnpackUint16x2(g_RWUpdateRayOriginBuffer[RayIndex]);
//         float4 RadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
//         if(RadianceInvPdf.w > 0) {
//             float3 Error    = RadianceInvPdf.xyz;
//             float  InvPdf   = RadianceInvPdf.w;

//             float  Contrib  = (dot(Error, Error) ) * InvPdf;

//             // Accumulate the error
//             int2  PixelCoords = TexCoords - TexOffset;
//             ThreadErrorAccumulation[PixelCoords.y][PixelCoords.x] += Contrib;
//             ThreadErrorAccumulationWeight[PixelCoords.y][PixelCoords.x] += InvPdf;
//         }
//     }
//     for(int j = 0; j<SSRC_TILE_SIZE; j++) {
//         for(int i = 0; i<SSRC_TILE_SIZE; i++) {
//             int2 TexCoords = TexOffset + int2(i, j);
//             float Error  = ThreadErrorAccumulation[j][i];
//             float Weight = ThreadErrorAccumulationWeight[j][i];
//             float PrevError = g_RWUpdateErrorSplatTexture[TexCoords];
//             if(Weight > 0) {
//                 g_RWUpdateErrorSplatTexture[TexCoords] = lerp(PrevError, Error / Weight, 0.005f);
//             } else {
//                 g_RWUpdateErrorSplatTexture[TexCoords] = lerp(PrevError, 0.f,  0.005f);
//             }
//         }
//     }
// }

// [numthreads(8, 8, 1)]
// void DebugSSRC_ShowDifference (uint2 DispatchID : SV_DispatchThreadID) {
//     if(any(DispatchID >= MI.ScreenDimensions)) {
//         return;
//     }
//     if(g_DebugVisualizeMode == 0) {
//         float Depth = g_DepthTexture.Load(int3(DispatchID, 0)).x;
//         if(Depth < 1.f) {
//             float2 UV = (DispatchID + 0.5f.xx) / MI.ScreenDimensions;
//             float Difference = g_UpdateErrorSplatTexture.SampleLevel(g_LinearSampler, UV, ERROR_BLUR_LOD).x;
//             g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(Difference * g_DebugTonemapExposure), 1.f);
//         } else {
//             g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
//         }
//     } else if(g_DebugVisualizeMode == 1) {
//         int2 TileCoords = DispatchID / SSRC_TILE_SIZE;
//         int TileID = TileCoords.x + TileCoords.y * g_TileDimensions.x;
//         int TileRayCount = g_RWTileRayCountBuffer[TileID];
//         if(TileRayCount == 0) {
//             g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
//         } else {
//             g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(TileRayCount / 128.f), 1.f);
//         }
//     } else if(g_DebugVisualizeMode == 2) {
//         float Depth = g_DepthTexture.Load(int3(DispatchID, 0)).x;
//         if(Depth < 1.f) {
//             float Difference = g_UpdateErrorSplatTexture.Load(int3(DispatchID, 0)).x;
//             g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(Difference * g_DebugTonemapExposure), 1.f);
//         } else {
//             g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
//         }
//     }
// }

// ***********************************************
// *                 Misc                        *
// ***********************************************


// [numthreads(1, 1, 1)]
// void DebugSSRC_GenerateDrawIndexed (uint DispatchID : SV_DispatchThreadID) {
//     DrawIndexedCommand draw_command;
//     draw_command.index_count_per_instance = 3;
//     draw_command.instance_count  = g_RWActiveBasisCountBuffer[0];
//     draw_command.index_offset    = 0;
//     draw_command.vertex_offset   = 0;
//     draw_command.instance_offset = 0;
//     g_RWDrawIndexedCommandBuffer[0] = draw_command;
// }

[numthreads(1, 1, 1)]
void DebugSSRC_FetchCursorPos (uint DipspatchID : SV_DispatchThreadID) {
    float4 Visibility = g_VisibilityTexture.Load(int3(MI.DebugCursorPixelCoords, 0));
    float2 Barycentrics = Visibility.xy;
    uint InstanceID = asuint(Visibility.z);
    uint PrimitiveID = asuint(Visibility.w);
    Instance InstanceData = g_InstanceBuffer[InstanceID];
    Mesh mesh = g_MeshBuffer[InstanceData.mesh_index];
    Triangle vertices = fetchVertices(mesh, PrimitiveID);
    float3x4 transform = g_TransformBuffer[InstanceData.transform_index];
    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);
    float3 WorldPosition = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);
    g_RWDebugCursorWorldPosBuffer[0] = WorldPosition;
}

[numthreads(WAVE_SIZE, 1, 1)]
void DebugSSRC_VisualizeProbePlacement (int DispatchID : SV_DispatchThreadID) {
    int2 ProbeIndex = int2(DispatchID % MI.TileDimensions.x, DispatchID / MI.TileDimensions.x);
    if(ProbeIndex.x >= MI.TileDimensions.x || ProbeIndex.y >= MI.TileDimensions.y) {
        return;
    }
    int2 UniformProbeScreenCoords = GetUniformScreenProbeScreenCoords(ProbeIndex);

    if(all(UniformProbeScreenCoords >= 0) && all(UniformProbeScreenCoords < MI.ScreenDimensions)
    && IsScreenProbeValid(ProbeIndex))
        g_RWDebugOutput[UniformProbeScreenCoords] = float4(10.f.xxx, 1.f);
    // Visualize adaptive probes
    int  AdaptiveProbeCount = g_RWTileAdaptiveProbeCountTexture[ProbeIndex];
    for(int i = 0; i < AdaptiveProbeCount; i++) {
        int  ScreenProbeIndex1 = GetAdaptiveProbeIndex(ProbeIndex, i) + MI.UniformScreenProbeCount;
        int2 AdaptiveProbeIndex = int2(ScreenProbeIndex1 % MI.TileDimensions.x, ScreenProbeIndex1 / MI.TileDimensions.x);
        ProbeHeader Header = GetScreenProbeHeader(AdaptiveProbeIndex);
        int2 AdaptiveProbeScreenCoords = Header.ScreenCoords;
        g_RWDebugOutput[AdaptiveProbeScreenCoords] = float4(10.f.xxx, 1.f);
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void DebugSSRC_PrepareProbeIncidentRadiance (uint DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= MI.DebugVisualizeIncidentRadianceNumPoints) {
        return;
    }
    if(DispatchID == 0) {
        // 3 channel sum
        g_RWReduceCountBuffer[0] = MI.DebugVisualizeIncidentRadianceNumPoints * 3;
    }
    float3 Direction      = FibonacciSphere(DispatchID, MI.DebugVisualizeIncidentRadianceNumPoints);
    float3 DebugWorldPos  = g_RWDebugCursorWorldPosBuffer[0];
    float3 Homogeneous    = transformPointProjection(DebugWorldPos, MI.CameraProjView);
    float2 UV             = NDC22UV(Homogeneous.xy);
    int2   TexCoords      = int2(UV * MI.ScreenDimensions);
    
    int2   TileIndex       = int2(TexCoords.x / SSRC_TILE_SIZE, TexCoords.y / SSRC_TILE_SIZE);
    int2   ProbeIndex      = TileIndex;
    ProbeHeader Header     = GetScreenProbeHeader(ProbeIndex);
    float  MinScreenDistance = Header.bValid ? length(UV - Header.ScreenCoords - 0.5) : 1e6f;
    int AdaptiveProbeCount = g_RWTileAdaptiveProbeCountTexture[TileIndex];
    for(int AdaptiveProbeRank = 0; AdaptiveProbeRank < AdaptiveProbeCount; AdaptiveProbeRank++) {
        int ScreenProbeIndex1 = GetAdaptiveProbeIndex(ProbeIndex, AdaptiveProbeRank) + MI.UniformScreenProbeCount;
        int2 ScreenProbeIndex = int2(ScreenProbeIndex1 % MI.TileDimensions.x, ScreenProbeIndex1 / MI.TileDimensions.x);
        ProbeHeader AdaptiveHeader = GetScreenProbeHeader(ScreenProbeIndex);
        float ScreenDistance  = length(UV - AdaptiveHeader.ScreenCoords - 0.5);
        if(!Header.bValid || ScreenDistance < MinScreenDistance) {
            ProbeIndex = ScreenProbeIndex;
            Header = AdaptiveHeader;
            MinScreenDistance = ScreenDistance;
        }
    }

    if(DispatchID == 0) {
        g_RWDebugProbeWorldPositionBuffer[0] = Header.Position;
        g_RWDebugProbeIndexBuffer[0]         = ProbeIndex;
    }
    
    int BasisCount = GetProbeBasisCountFromClass(Header.Class);

    float3 SumRadiance = 0.f.xxx;
    for(int i = 0; i < BasisCount; i++) {
        int BasisIndex = Header.BasisOffset + i;
        SGData SG = FetchBasisData(BasisIndex);
        float3 EvaluatedSG   = EvaluateSG(SG, Direction);
        SumRadiance += EvaluatedSG;
    }
    float3 OctEvaluated = 0.f;
    if(MI.DebugVisualizeChannel == 0) {
        float3 SHCoefficients[9];
        float  SH9[9];
        GetScreenProbeSHCoefficients(ProbeIndex, SHCoefficients);
        SH_GetCoefficients(Direction, SH9);
        for(int i = 0; i < 9; i++) {
            OctEvaluated += SHCoefficients[i] * SH9[i];
        }
    } else {
        float3 Tangent, Bitangent;
        GetOrthoVectors(Header.Normal, Tangent, Bitangent);
        float3 LocalDirection = float3(
            dot(Direction, Tangent),
            dot(Direction, Bitangent),
            dot(Direction, Header.Normal)
        );
        if(LocalDirection.z >= 0) {
            float4 RadianceDepth = SampleScreenProbeRadianceDepth(ProbeIndex, LocalDirection);
            OctEvaluated = RadianceDepth.rgb;
        }
        if(MI.DebugVisualizeChannel == 2) {
            SumRadiance = 0.f;
        }
    }
    g_RWDebugVisualizeIncidentRadianceBuffer[DispatchID] = SumRadiance + OctEvaluated;
}

[numthreads(1, 1, 1)]
void DebugSSRC_PrepareUpdateRays () {
    int2   TexCoords      = MI.DebugCursorPixelCoords;
    float  Depth          = g_DepthTexture.Load(int3(TexCoords, 0)).x;
    if(Depth < 1.f) {
        float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
        SSRC_SampleData Sample;
        CalculateSSRCSampleWeights(
            TexCoords + 0.5f,
            g_RWDebugCursorWorldPosBuffer[0],
            GetLinearDepth(Depth),
            GeometryNormal,
            true,
            Sample
        );
        int MaxIndex;
        if(Sample.Weights[0] > Sample.Weights[1]) {
            MaxIndex = 0;
        } else {
            MaxIndex = 1;
        }
        if(Sample.Weights[2] > Sample.Weights[MaxIndex]) {
            MaxIndex = 2;
        }
        if(Sample.Weights[3] > Sample.Weights[MaxIndex]) {
            MaxIndex = 3;
        }
        if(Sample.Weights[MaxIndex] != 0) {
            int2 ProbeIndex  = Sample.Index[MaxIndex];
            g_RWDebugProbeIndexBuffer[0] = ProbeIndex;
            int  ProbeIndex1 = ProbeIndex.x + ProbeIndex.y * MI.TileDimensions.x;
            int  ProbeRayCount = g_RWProbeUpdateRayCountBuffer[ProbeIndex1];
            DrawCommand draw_command = (DrawCommand)0;
            draw_command.vertex_count_per_instance = 2;
            draw_command.instance_count  = ProbeRayCount;
            draw_command.vertex_offset   = 0;
            draw_command.instance_offset = 0;
            g_RWDrawCommandBuffer[0] = draw_command;
        } else {
            DrawCommand draw_command = (DrawCommand)0;
            draw_command.vertex_count_per_instance = 0;
            draw_command.instance_count  = 0;
            draw_command.vertex_offset   = 0;
            draw_command.instance_offset = 0;
            g_RWDrawCommandBuffer[0] = draw_command;
        }
    } else {
        DrawCommand draw_command = (DrawCommand)0;
        draw_command.vertex_count_per_instance = 0;
        draw_command.instance_count  = 0;
        draw_command.vertex_offset   = 0;
        draw_command.instance_offset = 0;
        g_RWDrawCommandBuffer[0] = draw_command;
    }
}


[numthreads(SSRC_TILE_SIZE, SSRC_TILE_SIZE, 1)]
void DebugSSRC_VisualizeReprojectionTrust (int2 DispatchID : SV_DispatchThreadID) {
    float  Depth          = g_DepthTexture.Load(int3(DispatchID, 0)).x;
    if(Depth < 1.f) {
        float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(DispatchID, 0)).xyz - 1.f);
        SSRC_SampleData Sample;
        float3 Position = RecoverWorldPositionHiRes(DispatchID);
        CalculateSSRCSampleWeights(
            DispatchID + 0.5f,
            Position,
            GetLinearDepth(Depth),
            GeometryNormal,
            true,
            Sample
        );
        int MaxIndex;
        if(Sample.Weights[0] > Sample.Weights[1]) {
            MaxIndex = 0;
        } else {
            MaxIndex = 1;
        }
        if(Sample.Weights[2] > Sample.Weights[MaxIndex]) {
            MaxIndex = 2;
        }
        if(Sample.Weights[3] > Sample.Weights[MaxIndex]) {
            MaxIndex = 3;
        }
        int2 ProbeIndex = Sample.Index[MaxIndex];
        ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
        if(Header.bValid) {
            float Trust = g_RWProbeHistoryTrustTexture[ProbeIndex];
            g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(Trust), 1.f);
        }
    }
}

[numthreads(SSRC_TILE_SIZE, SSRC_TILE_SIZE, 1)]
void DebugSSRC_VisualizeProbeColor (int2 DispatchID : SV_DispatchThreadID) {
    float  Depth          = g_DepthTexture.Load(int3(DispatchID, 0)).x;
#if SSRC_TILE_SIZE < SSRC_PROBE_TEXTURE_SIZE || SSRC_TILE_SIZE % SSRC_PROBE_TEXTURE_SIZE != 0
    #error "SSRC_TILE_SIZE must be a multiple of SSRC_PROBE_TEXTURE_SIZE"
#endif 
    int Scale = SSRC_TILE_SIZE / SSRC_PROBE_TEXTURE_SIZE;
    int2 TexCoords = DispatchID / Scale;
    if(all(TexCoords < MI.TileDimensions * SSRC_PROBE_TEXTURE_SIZE)) {
        float4 Color          = g_RWProbeColorTexture[TexCoords];
        float3 Normal         = GetScreenProbeNormal(TexCoords/SSRC_PROBE_TEXTURE_SIZE);
        if(MI.DebugVisualizeChannel == 0) 
            g_RWDebugOutput[DispatchID] = float4(Color.xyz, 1.f);
        else g_RWDebugOutput[DispatchID] = float4(Color.w, 0.f, 0.f, 1.f);
    }
}

[numthreads(1, 1, 1)]
void DebugWorldCache_GenerateDraw () {
    DrawIndexedCommand draw_command = (DrawIndexedCommand)0;
    draw_command.index_count_per_instance = WorldCache.Debug_DrawProbeInstanceIndexCount;
    draw_command.instance_count  = g_RWWorldCacheActiveProbeCountBuffer[0];
    draw_command.index_offset    = 0;
    draw_command.vertex_offset   = 0;
    draw_command.instance_offset = 0;
    g_RWDrawIndexedCommandBuffer[0] = draw_command;
}

groupshared int LocalUEHemiOctahedronTexelHitCount[SSRC_PROBE_TEXTURE_TEXEL_COUNT];

[numthreads(WAVE_SIZE, 1, 1)]
void UEHemiOctahedronLutPrepare1 (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {
    for(int i = 0; i < SSRC_PROBE_TEXTURE_TEXEL_COUNT / WAVE_SIZE; i++) {
        LocalUEHemiOctahedronTexelHitCount[i * WAVE_SIZE + LocalID] = 0;
    }
    Random rng = MakeRandom(GroupID * WAVE_SIZE + LocalID);
    const int NumSamples = 32768;
    for(int i = 0; i < NumSamples; i++) {
        float3 Direction = UniformSampleHemisphere(rng.rand2());
        int2 TexelCoords = floor(UnitVectorToHemiOctahedron01(Direction) * SSRC_PROBE_TEXTURE_SIZE);
        int  TexelIndex  = TexelCoords.x + TexelCoords.y * SSRC_PROBE_TEXTURE_SIZE;
        InterlockedAdd(LocalUEHemiOctahedronTexelHitCount[TexelIndex], 1);
    }
    GroupMemoryBarrierWithGroupSync();
    for(int i = 0; i < SSRC_PROBE_TEXTURE_TEXEL_COUNT / WAVE_SIZE; i++) {
        int HitCount = LocalUEHemiOctahedronTexelHitCount[i * WAVE_SIZE + LocalID];
        float Fraction = float(HitCount) / (NumSamples * WAVE_SIZE);
        g_RWUEHemiOctahedronCorrectionLutTempBuffer[
            GroupID * SSRC_PROBE_TEXTURE_TEXEL_COUNT 
            + i * WAVE_SIZE + LocalID] = Fraction;
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void UEHemiOctahedronLutPrepare2 (int LocalID : SV_GroupThreadID) {
    for(int i = 0; i < SSRC_PROBE_TEXTURE_TEXEL_COUNT / WAVE_SIZE; i++) {
        float Sum = 0.f;
        int TexelIndex = i * WAVE_SIZE + LocalID;
        for(int j = 0; j < MI.UEHemiOctahedronLutPrecomputeGroupCount; j++) {
            Sum += g_RWUEHemiOctahedronCorrectionLutTempBuffer[
                j * SSRC_PROBE_TEXTURE_TEXEL_COUNT + TexelIndex];
        }
        int2 TexelCoords = int2(TexelIndex % SSRC_PROBE_TEXTURE_SIZE, TexelIndex / SSRC_PROBE_TEXTURE_SIZE);
        g_RWUEHemiOctahedronCorrectionLutTexture[TexelCoords] = Sum / MI.UEHemiOctahedronLutPrecomputeGroupCount;
    }
}

// New line required for termination.
