#ifndef USE_INLINE_RT
#define USE_INLINE_RT 1
#endif

#ifndef WAVE_SIZE
// NVIDIA's default warp size
#define WAVE_SIZE 32
#endif

#define MIN_COLOR 0.000001f

// Shared structs among CPU and GPU
#include "../../gpu_shared.h"

// Parameters & Globals & Helper functions
#include "migi_inc.hlsl"

// Library for MIGI
#include "migi_lib.hlsl"

// Hash grid cache library
#include "hash_grid_cache.hlsl"
// World space ReSTIR library
#include "world_space_restir.hlsl"

#define MAX_HIT_DISTANCE 1e9f

struct ScreenCacheUpdatePayload
{
    float3 sky_sample;
    float hit_dist;
};

struct PopulateCellsPayload
{
    uint      query_index;
    float3    world;
    float3    normal;
    float3    lighting;
    Reservoir reservoir;
};

struct TraceReflectionsPayload
{
    int2   full_pos;
    float3 radiance;
    float2 s;
    float  hit_distance;
};


// A naive kernel for generating dispatch commands
[numthreads(1, 1, 1)]
void GenerateDispatch()
{
    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = (g_CountBuffer[0] + g_GroupSize - 1) / g_GroupSize;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

[numthreads(1, 1, 1)]
void GenerateDispatchRays()
{
    DispatchRaysCommand dispatch_rays_command;
    dispatch_rays_command.ray_generation_shader_record = g_RTConstants.ray_generation_shader_record;
    dispatch_rays_command.miss_shader_table = g_RTConstants.miss_shader_table;
    dispatch_rays_command.hit_group_table = g_RTConstants.hit_group_table;
    dispatch_rays_command.callable_shader_table = g_RTConstants.callable_shader_table;
    dispatch_rays_command.width = g_CountBuffer[0];
    dispatch_rays_command.height = 1;
    dispatch_rays_command.depth = 1;
    dispatch_rays_command.padding[0] = 0;
    dispatch_rays_command.padding[1] = 0;
    dispatch_rays_command.padding[2] = 0;
    g_RWDispatchRaysCommandBuffer[0] = dispatch_rays_command;
}

[numthreads(64, 1, 1)]
void PurgeTiles(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_PreviousPackedTileCountBuffer[0])
    {
        return; // out of bounds
    }

    // We opt for calculating the decay of each tile from the
    // current frame index, as it saves many writes per frame
    // and is quite a bit faster than having to decrement all
    // cell's decay values.
    uint tile_index = g_HashGridCache_PreviousPackedTileIndexBuffer[did];
    uint tile_decay = g_HashGridCache_DecayTileBuffer[tile_index];

    if (g_FrameIndex < tile_decay)   // account for integer wraparound case
    {
        tile_decay = ((0xFFFFFFFFu - tile_decay) + g_FrameIndex + 1);
    }
    else
    {
        tile_decay = (g_FrameIndex - tile_decay);
    }

    if (tile_decay >= kHashGridCache_TileDecay)
    {
        g_HashGridCache_HashBuffer[tile_index] = 0;

#ifdef DEBUG_HASH_CELLS
        // Clear all mipmaps
        for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile; ++cell_offset)
        {
            uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
            g_HashGridCache_DecayCellBuffer[cell_index] = 0xFFFFFFFFu;
        }
#endif // DEBUG_HASH_CELLS

        return; // kill the tile
    }

    uint packed_tile_index;
    InterlockedAdd(g_HashGridCache_PackedTileCountBuffer[0], 1, packed_tile_index);
    g_HashGridCache_PackedTileIndexBuffer[packed_tile_index] = tile_index;
}

[numthreads(1, 1, 1)]
void ClearCounters()
{
    g_Reservoir_HashListCountBuffer[0] = 0; // reset counters

    g_HashGridCache_PackedTileCountBuffer[0]    = 0;
    g_HashGridCache_UpdateTileCountBuffer[0]    = 0;
    g_HashGridCache_VisibilityCountBuffer[0]    = 0;
    g_HashGridCache_VisibilityRayCountBuffer[0] = 0;
    
}

void ScreenCacheUpdateHandleHit(uint DispatchID, inout ScreenCacheUpdatePayload payload, RayDesc ray, HitInfo hit_info)
{
    HashGridCache_Data data;
    data.eye_position = g_CameraPosition;
    data.hit_position = ray.Origin + payload.hit_dist * ray.Direction;
    data.direction    = ray.Direction;
    data.hit_distance = payload.hit_dist;

    uint tile_index;
    bool is_new_tile;
    uint cell_index = HashGridCache_InsertCell(data, tile_index, is_new_tile);

    if (cell_index != kGI10_InvalidId)
    {
        // Bump the cell's decay to the max. now that it's been 'touched'
        uint previous_tile_decay;
        InterlockedExchange(g_HashGridCache_DecayTileBuffer[tile_index], g_FrameIndex, previous_tile_decay);

        HashGridCache_Visibility visibility;
        visibility.is_front_face   = hit_info.frontFace;
        visibility.instance_index  = hit_info.instanceIndex;
        visibility.geometry_index  = hit_info.geometryIndex;
        visibility.primitive_index = hit_info.primitiveIndex;
        visibility.barycentrics    = hit_info.barycentrics;

        // We update the cell index for later passes
        uint visibility_index;
        InterlockedAdd(g_HashGridCache_VisibilityCountBuffer[0], 1, visibility_index);
        g_HashGridCache_VisibilityBuffer[visibility_index]      = HashGridCache_PackVisibility(visibility);
        g_HashGridCache_VisibilityCellBuffer[visibility_index]  = cell_index;
        g_HashGridCache_VisibilityQueryBuffer[visibility_index] = DispatchID;

        // Write out bounds of visibility
        requestLightSampleLocation(data.hit_position);

        // If this cell is inside a new tile, we need to add the tile to the packed storage and clear its cells.
        if (is_new_tile)
        {
            uint packed_tile_index;
            InterlockedAdd(g_HashGridCache_PackedTileCountBuffer[0], 1, packed_tile_index);
            g_HashGridCache_PackedTileIndexBuffer[packed_tile_index] = tile_index;

            // Clear mip0 cells (others will be reset anyways by UpdateTiles)
            for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile_mip0; ++cell_offset)
            {
                uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
                g_HashGridCache_ValueBuffer[cell_index] = uint2(0, 0);
            }
        }

        // If we're the 1st invocation touching this cell (this frame), we want to clear the
        // scratch storage that'll be used for atomically updating the radiance.
        // The accumulation will be resolved in the 'UpdateTiles()' kernel to
        // avoid integer overflow.
        if (is_new_tile || previous_tile_decay != g_FrameIndex)
        {
            uint update_tile_index;
            InterlockedAdd(g_HashGridCache_UpdateTileCountBuffer[0], 1, update_tile_index);
            g_HashGridCache_UpdateTileBuffer[update_tile_index] = tile_index;
        }

#ifdef DEBUG_HASH_CELLS
        // For debugging purposes, we need to be able to retrieve the position
        // & orientation of cells as we iterate the content of the cache.
        // So, write the packed cell descriptor out to memory in this case.
        if (is_new_tile)
        {
            // Clear debug cells (all mips)
            for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile; ++cell_offset)
            {
                uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
                g_HashGridCache_DebugCellBuffer[cell_index] = HashGridCache_ClearDebugCell();
            }
        }

        float4 packed_debug_cell;
        uint debug_cell_index = HashGridCache_PackDebugCell(data, tile_index, packed_debug_cell);

        // BE CAREFUL: writing to g_HashGridCache_DebugCellBuffer isn't atomic and several writings could occur
        uint previous_cell_decay;
        InterlockedExchange(g_HashGridCache_DecayCellBuffer[debug_cell_index], g_FrameIndex, previous_cell_decay);
        if (previous_cell_decay != g_FrameIndex)
        {
            g_HashGridCache_DebugCellBuffer[debug_cell_index] = packed_debug_cell;
        }
#endif // DEBUG_HASH_CELLS
    }
}

void ScreenCacheUpdateHandleMiss(inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    payload.sky_sample = g_EnvironmentBuffer.SampleLevel(g_TextureSampler, ray.Direction, 0.0f).xyz;
}

void ScreenCacheUpdateTraceRayInline(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    ClosestRayQuery ray_query = TraceRay<ClosestRayQuery>(ray);

    // If we hit some geometry, we append a new world-space hash-grid cache query
    if (ray_query.CommittedStatus() == COMMITTED_NOTHING)
    {
        payload.hit_dist = ray_query.CommittedRayT();
        ScreenCacheUpdateHandleMiss(payload, ray);
    }
    else
    {
        payload.hit_dist = ray_query.CommittedRayT();
        ScreenCacheUpdateHandleHit(did, payload, ray, GetHitInfoRtInlineCommitted(ray_query));
    }
}

void ScreenCacheUpdateTraceRayRt(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    TraceRay(g_Scene, RAY_FLAG_NONE, 0xFFu, 0, 0, 0, ray, payload);
}

void ScreenCacheUpdateTraceRay(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
#if USE_INLINE_RT
    ScreenCacheUpdateTraceRayInline(did, payload, ray);
#else
    ScreenCacheUpdateTraceRayRt(did, payload, ray);
#endif
}


[numthreads(1, 1, 1)]
void SSRC_ClearActiveCounter() {
    g_RWActiveBasisCountBuffer[0] = 0;
}

// Reproject basis from previous frame, filter dead basis
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_ReprojectAndFilter (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= g_MaxBasisCount) {
        return;
    }
    uint Flags = g_RWBasisFlagsBuffer[DispatchID];
    // The basis has been inactive for at least 1 frame.
    // Omit it.
    if(g_FrameIndex - Flags > BASIS_RETIRE_FRAME_COUNT) {
        return ;
    }
    if(g_FreezeBasisAllocation) {
        // Refresh all basis every frame if the freezing mode is on
        g_RWBasisFlagsBuffer[DispatchID] = g_FrameIndex;
    }

    // Clear the step size for step accumulation
    ScreenCache_ResetStepSize(DispatchID);

    SGData SG;
    WData W;
    float3 BasisPosition;
    FetchBasisData_W(DispatchID, SG, W);
    FetchBasisLocation(DispatchID, BasisPosition);
    float3 CurrentHomogeneous = transformPointProjection(BasisPosition, g_CameraProjView);

    float2 CurrentUV = 0.5f * float2(CurrentHomogeneous.x, -CurrentHomogeneous.y) + 0.5f;
    float  CurrentDepth = CurrentHomogeneous.z;

    int ActiveFlag = 1;

    // The basis turns inactive this frame.
    if(g_FrameIndex - Flags == BASIS_RETIRE_FRAME_COUNT) {
        ActiveFlag = 0;
    }

    // Free the slot if reprojection failed
    if(any(CurrentUV < -0.01f) || any(CurrentUV > 1.01f) || CurrentDepth < 0.f || CurrentDepth >= 1.f) {
        ActiveFlag = 0;
    }
    
    float LinearDepth = dot(BasisPosition - g_CameraPosition, g_CameraDirection);
    float PixelDepth  = g_DepthTexture.SampleLevel(g_LinearSampler, CurrentUV, 0.0f).x;
    float LinearPixelDepth = GetLinearDepth(PixelDepth);
    
    // Malfunction with TAA
    // Remove the basis if the depth is not consistent
    // if(abs(LinearDepth - LinearPixelDepth) > 0.01f) {
    //     ActiveFlag = 0;
    // }
    
    float BasisEffectiveRadius = EvaluateW_EffectiveRadius(W, g_MinWeightE);
    // The basis is too small for injection, remove it right on the way
    if(BasisEffectiveRadius == 0) {
        ActiveFlag = 0;
    }

    if(ActiveFlag == 0 && !g_FreezeBasisAllocation) {
        uint Slot;
        InterlockedAdd(g_RWFreeBasisIndicesCountBuffer[0], 1, Slot);
        g_RWFreeBasisIndicesBuffer[Slot] = DispatchID;
        g_RWBasisFlagsBuffer[DispatchID] = g_FrameIndex - BASIS_RETIRE_FRAME_COUNT;
        return ;
    }

    // The basis is still active this frame.
    // Get ready for injection and later computation.
    int  Rank = WavePrefixCountBits(1);
    uint Sum  = WaveActiveSum(1);
    uint Offset;
    if(WaveIsFirstLane()) {
        InterlockedAdd(g_RWActiveBasisCountBuffer[0], Sum, Offset);
    }
    Offset = WaveReadLaneFirst(Offset);
    g_RWActiveBasisIndexBuffer[Offset + Rank] = DispatchID;

    // Cache per instance effective radius for later injection rasterization
    g_RWBasisEffectiveRadiusBuffer[DispatchID] = BasisEffectiveRadius;
    // Update the center projection for this basis
    g_RWBasisFilmPositionBuffer[DispatchID] = packUnorm2x16(CurrentUV);
    // Update screen lambda parameter
    if(ActiveFlag) {
        float  BasisLinearDepth = dot(BasisPosition - g_CameraPosition, g_CameraDirection);
        float  BasisEffectiveRadiusFilm = BasisEffectiveRadius / (BasisLinearDepth * g_CameraPixelScale);
        g_RWBasisEffectiveRadiusFilmBuffer[DispatchID] = BasisEffectiveRadiusFilm;
    } else {
        // Make sure we do inject correctly when the basis is inactive under freeze mode
        g_RWBasisEffectiveRadiusFilmBuffer[DispatchID] = 0.1f;
    }
}

// Clear tile injection index
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_ClearTileInjectionIndex (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    g_RWTileBasisCountBuffer[DispatchID] = 0;
}

// Generate draw command for injection
[numthreads(1, 1, 1)]
void SSRC_InjectGenerateDrawIndexed () {
    DrawIndexedCommand draw_command;
    draw_command.index_count_per_instance = 3 * (g_CR_DiskVertexCount - 2);
    draw_command.instance_count  = g_RWActiveBasisCountBuffer[0];
    draw_command.index_offset    = 0;
    draw_command.vertex_offset   = 0;
    draw_command.instance_offset = 0;
    g_RWDrawIndexedCommandBuffer[0] = draw_command;
}

// Inject reprojected basis to tile injection index
// Performed within the fragment shader with conservative rasterization
// InjectReprojectedBasis : TOPOLOGY_TRIANGLEFAN

// Clip overflowing tile index
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_ClipOverflowTileIndex (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID > g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    if(g_RWTileBasisCountBuffer[DispatchID] > SSRC_MAX_BASIS_PER_TILE) {
        g_RWTileBasisCountBuffer[DispatchID] = SSRC_MAX_BASIS_PER_TILE;
    }
}

// A scan sum is performed to accumulate g_RWTileBasisBaseOffsetBuffer

// Allocate one extra slot for each tile and accumulate it to the accumulated base basis index offset,
// which is used to store the newly allocated basis index this frame
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateExtraSlotForBasisGeneration (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    g_RWTileBaseSlotOffsetBuffer[DispatchID] = g_RWTileBaseSlotOffsetBuffer[DispatchID] + DispatchID;
}

// Compress the tile basis index
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_CompressTileBasisIndex (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    if(any(GroupID >= g_TileDimensions)) {
        return;
    }
    int TileID = GroupID.x + GroupID.y * g_TileDimensions.x;
    int UncompressedTileSlotOffset = TileID * SSRC_MAX_BASIS_PER_TILE;
    int CompressedTileSlotOffset   = g_RWTileBaseSlotOffsetBuffer[TileID];
    // Cooperatively fill the compressed index
    int Count = g_RWTileBasisCountBuffer[TileID];
    
    for(int TileSlotOffset = 0; TileSlotOffset < Count; TileSlotOffset += WAVE_SIZE) {
        int TileSlot = TileSlotOffset + LocalID;
        if(TileSlot < Count) {
            g_RWTileBasisIndexBuffer[CompressedTileSlotOffset + TileSlot] = 
                g_RWTileBasisIndexInjectionBuffer[UncompressedTileSlotOffset + TileSlot];
        }
    }
}

[numthreads(SSRC_TILE_SIZE, SSRC_TILE_SIZE, 1)]
void ReprojectPreviousUpdateError (int2 DispatchID : SV_DispatchThreadID) {
    if(any(DispatchID >= g_OutputDimensions)) {
        return;
    }
    // Reproject the update error texture from previous frame to current frame
    {
        float2 UV     = (DispatchID + 0.5f) * g_OutputDimensionsInv;
        float  Depth  = g_DepthTexture.Load(int3(DispatchID, 0)).x;
        float3 Normal = normalize(2.f * g_GeometryNormalTexture.Load(int3(DispatchID, 0)) - 1.f);

        if (all(UV > 0.0f) && all(UV < 1.0f) && Depth > 0.0f && Depth < 1.0f)
        {
            float2 previous_uv = UV - g_VelocityTexture.SampleLevel(g_NearestSampler, UV, 0.0f).xy;

            if (all(previous_uv > 0.0f) && all(previous_uv < 1.0f))
            {
                float3 homogeneous2 = transformPointProjection(float3(2.0f * float2(UV.x, 1.0f - UV.y) - 1.0f, depth), g_Reprojection);
                homogeneous2.z      = GetLinearDepth(homogeneous2.z);

                float  previous_depth  = GetLinearDepth(g_PreviousDepthTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).x);
                float3 previous_normal = normalize(2.0f * g_PreviousGeometryNormalTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz - 1.0f);

                if (dot(previous_normal, Normal) > 5e-1f && abs(previous_depth - homogeneous2.z) / homogeneous2.z < 5e-2f)
                {
                    float PreviousError = g_PreviousUpdateErrorSplatTexture.SampleLevel(g_LinearSampler, previous_uv, 0).x;
                    g_RWUpdateErrorSplatTexture[DispatchID] = float4(PreviousError, 0.0f, 0.0f, 0.0f);
                    return; 
                }
            }
        }
    }
    // TODO allocate a initial weight for the update error
    // FIXME
    g_RWUpdateErrorSplatTexture[DispatchID] = 0.f.xxxx;
}

// UpdateErrorSplatTexture is later blurred into mipmaps.

[numthreads(WAVE_SIZE, 1, 1)]
void PreomputeRayBudgetForTiles (int DispatchID : SV_DispatchThreadID, int GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int  TileID = DispatchID;
    if(TileID > g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    int2 TileCoords = int2(TileID % g_TileDimensions.x, TileID / g_TileDimensions.x);
    float TileAvgUpdateError = g_UpdateErrorSplatTexture.Load(int3(TileCoords, SSRC_TILE_SIZE_L2)).x;

    int   WaveActiveLaneCount       = WaveActiveSum(1);
    float WaveTileAvgUpdateErrorSum = WaveActiveSum(TileAvgUpdateError);
    if(LocalID == 0) {;
        g_RWTileUpdateErrorSumsBuffer[GroupID] = WaveTileAvgUpdateErrorSum;
    }
}

// A reduce sum is performed to accumulate g_RWTileUpdateErrorSumsBuffer into g_RWUpdateErrorBuffer

// Allocate update rays for each tile
// To achieve maximum parallelism, we allocate rays by WAVE_SIZE * X for each tile (X <= WAVE_RAY_SIZE)
// Using russian roulette to round the number of rays to one of the nearest multiples of WAVE_SIZE
[numthreads(WAVE_SIZE, 1, 1)]
void AllocateUpdateRays (int DispatchID : SV_DispatchThreadID) {
    int TileID = DispatchID;
    if(TileID >= g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    int2 TileCoords          = int2(TileID % g_TileDimensions.x, TileID / g_TileDimensions.x);
    float TileAvgUpdateError = g_UpdateErrorSplatTexture.Load(int3(TileCoords, SSRC_TILE_SIZE_L2)).x;
    float Fraction           = TileAvgUpdateError / max(g_RWUpdateErrorBuffer[0], 1e-4f);
    float ExpectedRayCount   = Fraction * g_RWTileUpdateErrorSumsBuffer[TileID];
    // RR
    int X                    = int(ExpectedRayCount / WAVE_SIZE);
    float Remainder          = (ExpectedRayCount - X * WAVE_SIZE) / WAVE_SIZE;
    Random rng = MakeRandom(97462891 + DispatchID, g_FrameIndex).rand();
    if(rng.rand() < Remainder) {
        X++;
    }
    g_RWTileRayCountBuffer[TileID] = min(X, WAVE_RAY_SIZE) * WAVE_SIZE;
}

// A scan sum is performed to accumulate g_RWTileRayCountBuffer into g_RWTileRayBaseOffsetBuffer

// Importance sample the allocated update rays for each tile
float LocalUpdateErrorMip0[SSRC_TILE_SIZE][SSRC_TILE_SIZE];
float LocalUpdateErrorMip1[SSRC_TILE_SIZE / 2][SSRC_TILE_SIZE / 2];
float LocalUpdateErrorMip2[SSRC_TILE_SIZE / 4][SSRC_TILE_SIZE / 4];
[numthreads(WAVE_SIZE, 1, 1)]
void SampleUpdateRays (int GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID;
    if(TileID >= g_TileDimensions.x * g_TileDimensions.y) {
        return;
    }
    int2 TileCoords = int2(TileID % g_TileDimensions.x, TileID / g_TileDimensions.x);
    int2 TileBaseTextureOffset = TileCoords * SSRC_TILE_SIZE;
    // Cooperatively load the update error mipmaps
    int L0PixelCount = SSRC_TILE_SIZE * SSRC_TILE_SIZE;
    for(int i = 0; i < L0PixelCount; i += WAVE_SIZE) {
        int PixelIndex = i + LocalID;
        if(PixelIndex < L0PixelCount) {
            int  PixelX = PixelIndex % SSRC_TILE_SIZE;
            int  PixelY = PixelIndex / SSRC_TILE_SIZE;
            int2 TexCoords = TileBaseTextureOffset + int2(PixelX, PixelY);
            LocalUpdateErrorMip0[PixelY][PixelX] = g_UpdateErrorSplatTexture.Load(int3(TexCoords, 0)).x;
        }
    }
    int L1PixelCount = (SSRC_TILE_SIZE * SSRC_TILE_SIZE) / 4;
    for(int i = 0; i < L1PixelCount; i += WAVE_SIZE) {
        int PixelIndex = i + LocalID;
        if(PixelIndex < L1PixelCount) {
            int  PixelX = PixelIndex % (SSRC_TILE_SIZE / 2);
            int  PixelY = PixelIndex / (SSRC_TILE_SIZE / 2);
            int2 TexCoords = TileBaseTextureOffset / 2 + int2(PixelX, PixelY);
            LocalUpdateErrorMip0[PixelY][PixelX] = g_UpdateErrorSplatTexture.Load(int3(TexCoords, 1)).x;
        }
    }
    int L2PixelCount = (SSRC_TILE_SIZE * SSRC_TILE_SIZE) / 16;
    for(int i = 0; i < L2PixelCount; i += WAVE_SIZE) {
        int PixelIndex = i + LocalID;
        if(PixelIndex < L2PixelCount) {
            int  PixelX = PixelIndex % (SSRC_TILE_SIZE / 4);
            int  PixelY = PixelIndex / (SSRC_TILE_SIZE / 4);
            int2 TexCoords = TileBaseTextureOffset / 4 + int2(PixelX, PixelY);
            LocalUpdateErrorMip0[PixelY][PixelX] = g_UpdateErrorSplatTexture.Load(int3(TexCoords, 2)).x;
        }
    }
    GroupMemoryBarrierWithGroupSync();

    int TileRayCount  = g_RWTileRayCountBuffer[TileID];
    int TileRayOffset = g_RWTileRayOffsetBuffer[TileID];
    int REPEAT        = (TileRayCount + WAVE_SIZE - 1) / WAVE_SIZE;
    Random rng        = MakeRandom(34622891 + TileID * WAVE_SIZE + LocalID, g_FrameIndex);
    for(int i = 0; i < REPEAT; i++) {
        int RayIndex = i * WAVE_SIZE + LocalID;
        if(RayIndex < TileRayCount) {
            float u = rng.rand();
            int2  Offset = 0;
            // Assume the tile size is 8x8
            // 8x8 sub tile sampling
            {
                float X00 = LocalUpdateErrorMip2[Offset.y][Offset.x];
                float X01 = LocalUpdateErrorMip2[Offset.y][Offset.x + 1];
                float X10 = LocalUpdateErrorMip2[Offset.y + 1][Offset.x];
                float X11 = LocalUpdateErrorMip2[Offset.y + 1][Offset.x + 1];
                float S   = X00 + X01 + X10 + X11;
                float P00 = X00 / S;
                float P01 = X01 / S;
                float P10 = X10 / S;
                float P11 = X11 / S;
                if(u < P00) {
                    u = u / P00;
                } else if(u < P00 + P01) {
                    Offset.x ++;
                    u = (u - P00) / P01;
                } else if(u < P00 + P01 + P10) {
                    Offset.y ++;
                    u = (u - (P00 + P01)) / P10;
                } else {
                    Offset += int2(1, 1);
                    u = (u - (P00 + P01 + P10)) / P11;
                }
            }
            Offset = Offset * 2;
            // 4x4 sub tile sampling
            {
                float X00 = LocalUpdateErrorMip1[Offset.y][Offset.x];
                float X01 = LocalUpdateErrorMip1[Offset.y][Offset.x + 1];
                float X10 = LocalUpdateErrorMip1[Offset.y + 1][Offset.x];
                float X11 = LocalUpdateErrorMip1[Offset.y + 1][Offset.x + 1];
                float S   = X00 + X01 + X10 + X11;
                float P00 = X00 / S;
                float P01 = X01 / S;
                float P10 = X10 / S;
                float P11 = X11 / S;
                if(u < P00) {
                    u = u / P00;
                } else if(u < P00 + P01) {
                    Offset.x ++;
                    u = (u - P00) / P01;
                } else if(u < P00 + P01 + P10) {
                    Offset.y ++;
                    u = (u - (P00 + P01)) / P10;
                } else {
                    Offset += int2(1, 1);
                    u = (u - (P00 + P01 + P10)) / P11;
                }
            }
            Offset = Offset * 2;
            // 2x2 sub tile sampling
            {
                float X00 = LocalUpdateErrorMip0[Offset.y][Offset.x];
                float X01 = LocalUpdateErrorMip0[Offset.y][Offset.x + 1];
                float X10 = LocalUpdateErrorMip0[Offset.y + 1][Offset.x];
                float X11 = LocalUpdateErrorMip0[Offset.y + 1][Offset.x + 1];
                float S   = X00 + X01 + X10 + X11;
                float P00 = X00 / S;
                float P01 = X01 / S;
                float P10 = X10 / S;
                float P11 = X11 / S;
                if(u < P00) {

                } else if(u < P00 + P01) {
                    Offset.x ++;
                } else if(u < P00 + P01 + P10) {
                    Offset.y ++;
                } else {
                    Offset += int2(1, 1);
                }
            }
            // Sample film position
            g_RWRay????
        }
    }

}

// Trace visibility rays to generate intersections for secondary vertices
void SSRC_TraceUpdateRays (uint2 DispatchID) {
    if(DispatchID.x >= g_OutputDimensions.x || DispatchID.y >= g_OutputDimensions.y) return ;

    {
        float Depth = g_DepthTexture.Load(int3(DispatchID, 0)).x;
        if(Depth >= 1.f) return ;
    }
    
    float2 UV = (DispatchID + 0.5f) / float2(g_OutputDimensions);

    float4 Visibility   = g_VisibilityTexture.Load(int3(DispatchID, 0));
    float2 Barycentrics = Visibility.xy;
    uint   InstanceID   = asuint(Visibility.z);
    uint   PrimitiveID  = asuint(Visibility.w);

    Instance InstanceData  = g_InstanceBuffer[InstanceID];
    Mesh     MeshData      = g_MeshBuffer[InstanceData.mesh_index];
    float3x4 Transform     = g_TransformBuffer[InstanceData.transform_index];

    Triangle vertices = fetchVertices(MeshData, PrimitiveID);
    float3 v0 = transformPoint(vertices.v0, Transform);
    float3 v1 = transformPoint(vertices.v1, Transform);
    float3 v2 = transformPoint(vertices.v2, Transform);

    float3 WorldPixelPosition  = interpolate(v0, v1, v2, Barycentrics);
    
    float3 GeometryNormal = normalize(2.0f * g_GeometryNormalTexture.Load(int3(DispatchID, 0)).xyz - 1.0f);
    float3 ShadingNormal  = normalize(2.0f * g_ShadingNormalTexture.Load(int3(DispatchID, 0)).xyz - 1.0f);

    float3 RayOrigin = offsetPosition(WorldPixelPosition, GeometryNormal);

    float2 u_b;
    // FIXME
    if(false && g_UseBlueNoiseSampleDirection) {
        u_b = BlueNoise_Sample2D(DispatchID, g_FrameIndex);
    } else {
        Random randomNG = MakeRandom(DispatchID.x + DispatchID.y * g_OutputDimensions.x, g_FrameIndex);
        u_b = randomNG.rand2();
    }
    float3 RayDirection;
    float Pdf;

    RayDirection = UniformSampleSphere(u_b);//UniformSampleHemisphere(u_b);//CosineWeightedSampleHemisphere(u_b);
    Pdf          = UniformSampleSpherePdf();

    float3 PixelTangent, PixelBitangent;
    TangentVectors(ShadingNormal, PixelTangent, PixelBitangent);
    RayDirection = normalize(RayDirection.x * PixelTangent + RayDirection.y * PixelBitangent + RayDirection.z * ShadingNormal);

    // Record trace ray direction for later hit position recovery
    g_RWRayDirectionTexture[DispatchID.xy] = float4(RayDirection, 1.f / Pdf);


    // g_RWRayRadianceTexture[DispatchID.xy] = float4(max(dot(RayDirection, normalize(float3(0.f, 1.f, -1.f))) - 0.8f, 0.f).xxx * 12.f, 0.f);
    // return ;

    if(dot(RayDirection, GeometryNormal) < 0.0f) {
        // Learn negative samples.
        g_RWRayRadianceTexture[DispatchID.xy] = float4(0.0f, 0.0f, 0.0f, 0.f);
        return ;
    }

    // Trace a visibility ray only.
    RayDesc VisibilityRayDesc;
    VisibilityRayDesc.Origin = RayOrigin;
    VisibilityRayDesc.Direction = RayDirection;
    VisibilityRayDesc.TMin = 0.f;
    VisibilityRayDesc.TMax = MAX_HIT_DISTANCE;

    ScreenCacheUpdatePayload payload;
    payload.sky_sample = float3(0.0f, 0.0f, 0.0f);
    ScreenCacheUpdateTraceRay(
        DispatchID.y * g_OutputDimensions.x + DispatchID.x,
        payload, VisibilityRayDesc
    );
    g_RWRayRadianceTexture[DispatchID.xy] = float4(payload.sky_sample, 0.f);
}

[numthreads(4, 4, 1)]
void SSRC_TraceUpdateRaysMain (uint2 DispatchID : SV_DispatchThreadID) {
    SSRC_TraceUpdateRays(DispatchID);
}

[numthreads(32, 1, 1)]
void ClearReservoirs(in uint did : SV_DispatchThreadID)
{
    g_Reservoir_HashBuffer[did]      = 0;
    g_Reservoir_HashCountBuffer[did] = 0;
}


[numthreads(32, 1, 1)]
void GenerateReservoirs(in uint DispatchID : SV_DispatchThreadID)
{
    if (DispatchID >= g_HashGridCache_VisibilityCountBuffer[0])
    {
        return; // out of bounds
    }

    // Load our visibility sample
    float4                   packed_visibility = g_HashGridCache_VisibilityBuffer[DispatchID];
    HashGridCache_Visibility visibility        = HashGridCache_UnpackVisibility(packed_visibility);

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[visibility.instance_index];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index + visibility.geometry_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    TriangleNormUV vertices = fetchVerticesNormUV(mesh, visibility.primitive_index);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);

    vertices.n0 = transformNormal(vertices.n0, transform);
    vertices.n1 = transformNormal(vertices.n1, transform);
    vertices.n2 = transformNormal(vertices.n2, transform);

    float3   world    =                                                       interpolate(vertices.v0, vertices.v1, vertices.v2, visibility.barycentrics);
    float3   normal   = (visibility.is_front_face ? 1.0f : -1.0f) * normalize(interpolate(vertices.n0, vertices.n1, vertices.n2, visibility.barycentrics));
    Material material = g_MaterialBuffer[instance.material_index];

    // Recover the ray origin
    uint query_index = g_HashGridCache_VisibilityQueryBuffer[DispatchID];
    // Queries are indexed with pixel coordinates (currently).
    int2 pixel_coords = int2(query_index % g_OutputDimensions.x, query_index / g_OutputDimensions.x);
    float depth = g_DepthTexture.Load(int3(pixel_coords, 0)).x;
    float2 uv = (pixel_coords + 0.5f) / g_OutputDimensions;
    float3 origin = InverseProject(g_CameraProjViewInv, uv, depth);
    float2 mesh_uv = interpolate(vertices.uv0, vertices.uv1, vertices.uv2, visibility.barycentrics);

    // Patch the screen space cache with some emissivity information:
    // We bypass the hash-grid cache entirely here, as adding emissive information to the cells
    // effectively enlarges the area light (due to the spatial nature of the grid) and leads to
    // light leaks and generally poorer visuals.
    if (visibility.is_front_face && dot(material.emissivity.xyz, material.emissivity.xyz) > 0.0f)
    {
        MaterialEmissive emissive = MakeMaterialEmissive(material, mesh_uv);
        g_RWRayRadianceTexture[pixel_coords] = float4(emissive.emissive, 1.f);

        return; // do not continue past an emissive surface
    }

    // We can perform some temporal radiance feedback from last frame if direct lighting was
    // evaluated.
    // If successful, we inject the reprojected radiance into the cache so it can be re-used
    // by neighbor vertices but bypass the filtered readback as the sample is already denoised.
    {
        float3 homogeneous = transformPointProjection(world, g_CameraProjView);

        uv    = 0.5f * float2(homogeneous.x, -homogeneous.y) + 0.5f;
        depth = homogeneous.z;

        if (all(uv > 0.0f) && all(uv < 1.0f) && depth > 0.0f && depth < 1.0f)
        {
            float2 previous_uv = uv - g_VelocityTexture.SampleLevel(g_NearestSampler, uv, 0.0f).xy;

            if (all(previous_uv > 0.0f) && all(previous_uv < 1.0f))
            {
                float3 homogeneous2 = transformPointProjection(float3(2.0f * float2(uv.x, 1.0f - uv.y) - 1.0f, depth), g_Reprojection);
                homogeneous2.z      = GetLinearDepth(homogeneous2.z);

                float  previous_depth  = GetLinearDepth(g_PreviousDepthTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).x);
                float3 previous_normal = normalize(2.0f * g_PreviousGeometryNormalTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz - 1.0f);

                if (dot(previous_normal, normal) > 5e-1f && abs(previous_depth - homogeneous2.z) / homogeneous2.z < 5e-2f)
                {
                    float3 previous_lighting = g_PrevCombinedIlluminationTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz;

                    uint  cell_index         = g_HashGridCache_VisibilityCellBuffer[DispatchID];
                    uint4 quantized_radiance = HashGridCache_QuantizeRadiance(previous_lighting);
#ifdef ENABLE_INDIRECT
                    g_RWRayRadianceTexture[pixel_coords] = g_RWRayRadianceTexture[pixel_coords] + float4(previous_lighting, 0.f);
#endif // ENABLE_INDIRECT
                    if (dot(previous_lighting, previous_lighting) > 0.0f)
                    {
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0], quantized_radiance.x);
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1], quantized_radiance.y);
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2], quantized_radiance.z);
                    }
                    InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3], quantized_radiance.w);

                    return; // we can skip the shadow ray for this sample :)
                }
            }
        }
    }

    float3 view_direction = normalize(origin - world);

    // Sample new lights
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 1.5f);
    MaterialEvaluated material2 = MakeMaterialEvaluated(material, mesh_uv);
    MaterialBRDF materialBRDF = MakeMaterialBRDF(material2);
    // Make the seed different from the one used in TraceUpdateRays
    Random random = MakeRandom(DispatchID ^ 0x8a197727, g_FrameIndex);
    LightSampler lightSampler = MakeLightSampler(random);
    Reservoir reservoir = lightSampler.sampleLightListCone<kReservoir_SampleCount>(world, normal, view_direction, solid_angle, materialBRDF);

    if (!reservoir.isValid())
    {
        return;
    }

    // Append our resampled shadow ray, generate a ray index for later tracing and updates
    uint ray_index;
    InterlockedAdd(g_HashGridCache_VisibilityRayCountBuffer[0], 1, ray_index);

    g_HashGridCache_VisibilityRayBuffer[ray_index] = DispatchID;   // compact the surviving shadow rays

    // Here, we check that the ray has traversed at least a full hash cell
    // before hitting something.
    // If it hasn't, we bypass the filtering from the cache (although we
    // still accumulate the contribution into the cell).
    //
    // This avoids possible light leaks in the following configuration:
    //
    //    bright area   +--------------+
    //                  |    dark area |
    //                  | |            |
    //                  | x            |
    //                  |/|            |
    //                 /|\             |
    //                / | eye          |
    // bright radiance  +--------------+
    //
    // Here the point 'x' is reached after bouncing from the first vertex.
    // (i.e., it is a 2nd vertex, the ones filtered through the hash grid)
    // Because it is close to the wall and has a similar direction to the
    // 'bright radiance' event, both vertices will share the same hash cell
    // leading to a light leak on the bounced lighting from the inner wall.
    //
    // Such a scenario mostly occurs if the length of the ray connecting
    // the 2nd vertex is less than the size of the hash cell being used.
    // So, we detect this case and flag a bypass of the filtered readback.
    float cell_size  = HashGridCache_GetCellSize(world);
    float ray_length = distance(origin, world);

    if (ray_length < cell_size)
    {
        g_HashGridCache_VisibilityRayBuffer[ray_index] |= 0x80000000u;
    }

    // Insert the reservoir into the hash table
#ifdef USE_RESAMPLING
    float3 b1, b2;
    GetOrthoVectors(normal, b1, b2);
    float2 jitter = 2.0f * random.rand2() - 1.0f;
    jitter *= Reservoir_GetCellSize(world) * kReservoir_SpatialJitter;
    Reservoir_InsertEntry(ray_index, world + jitter.x * b1 + jitter.y * b2);

    g_Reservoir_IndirectSampleBuffer[ray_index]       = Reservoir_PackIndirectSample(origin, world);
    g_Reservoir_IndirectSampleNormalBuffer[ray_index] = packNormal(normal);
#endif // USE_RESAMPLING

    // Write the results out to memory
    g_Reservoir_IndirectSampleMaterialBuffer[ray_index]  = packMaterial(material2);  // cannot afford to re-fetch the full material each time, so we need to approximate it...
    g_Reservoir_IndirectSampleReservoirBuffer[ray_index] = packReservoir(reservoir);
}

// 32 threads for NVIDIA hardwares (warp size)
[numthreads(32, 1, 1)]
void CompactReservoirs(in uint did : SV_DispatchThreadID)
{
    if (did >= g_Reservoir_HashListCountBuffer[0])
    {
        return; // out of bounds
    }

    uint4 list_element = g_Reservoir_HashListBuffer[did];
    uint  value_index  = g_Reservoir_HashIndexBuffer[list_element.y] + list_element.z;

    g_Reservoir_HashValueBuffer[value_index] = list_element.x;
}

// Temporal resampling only
[numthreads(64, 1, 1)]
void ResampleReservoirs(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    // Load our shading information
    float3 origin, world;
    Reservoir_UnpackIndirectSample(g_Reservoir_IndirectSampleBuffer[did], origin, world);

    float3       normal    = unpackNormal(g_Reservoir_IndirectSampleNormalBuffer[did]);
    MaterialBRDF material  = unpackMaterial(g_Reservoir_IndirectSampleMaterialBuffer[did]);
    Reservoir    reservoir = unpackReservoir(g_Reservoir_IndirectSampleReservoirBuffer[did]);

    // Normalize the sample count M (a.k.a. confidence weight) with the initial sample count for simplicity.
    reservoir.M = 1.0f;

    // Make the random numbers different from previous samples
    Random random = MakeRandom(did + g_OutputDimensions.x * g_OutputDimensions.y, g_FrameIndex);

    // Locate our hash table cell
    float3 b1, b2;
    GetOrthoVectors(normal, b1, b2);
    float2 jitter = 2.0f * random.rand2() - 1.0f;
    jitter *= Reservoir_GetCellSize(world) * kReservoir_SpatialJitter;
    uint entry_index = Reservoir_FindPreviousEntry(world + jitter.x * b1 + jitter.y * b2);

    if (entry_index == kGI10_InvalidId)
    {
        return; // no previous reservoir cell - temporal resampling failed :'(
    }

    uint index = g_Reservoir_PreviousHashIndexBuffer[entry_index];
    uint count = g_Reservoir_PreviousHashCountBuffer[entry_index];

    // Stochastically iterate the cell content
    uint max_count = 4;
    uint increment = (count + max_count - 1) / max_count;
    uint offset    = random.randInt(increment);

    // And combine the reservoirs
    float3 view_direction = normalize(origin - world);
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 12000.0f);
    ReservoirUpdater updater = MakeReservoirUpdater();
    mergeReservoirsCone(updater, reservoir, random, material, world, normal, view_direction, solid_angle);
    for (uint i = 0; i < count; i += increment)
    {
        // Load up the iterated reservoir
        uint      reservoir_index = g_Reservoir_PreviousHashValueBuffer[index + ((i + offset) % count)];
        Reservoir reservoir2      = unpackReservoir(g_Reservoir_PreviousIndirectSampleReservoirBuffer[reservoir_index]);
        float3    filter_normal   = unpackNormal(g_Reservoir_PreviousIndirectSampleNormalBuffer[reservoir_index]);

        if (!reservoir2.isValid())
        {
            continue;   // skip invalid reservoir(s)
        }

        // Bilaterally filter the neighbor reservoir
        float bilateral_weight = max(dot(normal, filter_normal), 0.0f);
        bilateral_weight = squared(squared(bilateral_weight)); // make it steep
        if (bilateral_weight < kReservoir_BilateralThreshold) continue;

        // And combine it with our current reservoir
        Reservoir_ClampPrevious(reservoir2);
        mergeReservoirsCone(updater, reservoir2, random, material, world, normal, view_direction, solid_angle);
    }

    if (!updater.reservoir.M)
    {
        return; // reprojection failed
    }

    // Finalize our reservoir
    reservoir = updater.reservoir;

    // And write it out to memory
    g_Reservoir_IndirectSampleReservoirBuffer[did] = packReservoir(reservoir);
}

void PopulateCellsHandleHit(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    payload.lighting    = float3(0.0f, 0.0f, 0.0f);

    Reservoir reservoir = payload.reservoir;
    // Update our reservoir cache for next frame's temporal resampling
#ifdef USE_RESAMPLING
    reservoir.W = 0.0f; // invalidate the reservoir

    g_Reservoir_IndirectSampleReservoirBuffer[did] = packReservoir(reservoir);
#endif // USE_RESAMPLING
}

void PopulateCellsHandleMiss(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    float3       light_radiance = payload.lighting;
    float        light_weight   = payload.reservoir.W;
    int2         pixel_coords   = int2(payload.query_index % g_OutputDimensions.x, payload.query_index / g_OutputDimensions.x);
    MaterialBRDF material       = unpackMaterial(g_Reservoir_IndirectSampleMaterialBuffer[did]);

    // Recover the ray origin
    float  depth  = g_DepthTexture.Load(int3(pixel_coords, 0)).x;
    float2 uv     = (pixel_coords + 0.5f) / g_OutputDimensions;
    float3 origin = InverseProject(g_CameraProjViewInv, uv, depth);

    // And evaluate our lighting
    payload.lighting =
        evaluateBRDF(material, payload.normal, normalize(origin - payload.world), ray.Direction)
        * light_radiance * light_weight;
}

void PopulateCellsTraceRayInline(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    ShadowRayQuery ray_query = TraceRay<ShadowRayQuery>(ray);

    if (ray_query.CommittedStatus() == COMMITTED_NOTHING)
    {
        PopulateCellsHandleMiss(did, payload, ray);
    }
    else
    {
        PopulateCellsHandleHit(did, payload, ray);
    }
}

void PopulateCellsTraceRayRt(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    TraceRay(g_Scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH, 0xFFu, 0, 0, 0, ray, payload);
}

void PopulateCellsTraceRay(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
#if USE_INLINE_RT
    return PopulateCellsTraceRayInline(did, payload, ray);
#else
    return PopulateCellsTraceRayRt(did, payload, ray);
#endif
}

// Light sampling completed, actually trace a shadow ray for each hash grid cache query.
void PopulateCells(uint did)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    uint                     visibility_index = (g_HashGridCache_VisibilityRayBuffer[did] & ~0x80000000u);
    HashGridCache_Visibility visibility       = HashGridCache_UnpackVisibility(g_HashGridCache_VisibilityBuffer[visibility_index]);

    uint query_index = g_HashGridCache_VisibilityQueryBuffer[visibility_index];
    int2 pixel_coords = int2(query_index % g_OutputDimensions.x, query_index / g_OutputDimensions.x);    

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[visibility.instance_index];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index + visibility.geometry_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    Triangle vertices = fetchVertices(mesh, visibility.primitive_index);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);
    float3 world = interpolate(vertices.v0, vertices.v1, vertices.v2, visibility.barycentrics);
    float3 edge10 = vertices.v1 - vertices.v0;
    float3 edge20 = vertices.v2 - vertices.v0;
    float3 normal = normalize(transformNormal(cross(edge10, edge20) * (visibility.is_front_face ? 1.0f : -1.0f), transform));

    // Retrieve the light sample that we should use for our shadow ray
    Reservoir reservoir    = unpackReservoir(g_Reservoir_IndirectSampleReservoirBuffer[did]);

    // Decode the light sample from our reservoir
    float3 direction, light_position;
    // Approximate visible light surface based on number of samples being used
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 12000.0f);
    Light selected_light = getLight(reservoir.lightSample.index);
    float3 light_radiance = evaluateLightConeSampled(selected_light, world, reservoir.lightSample.sampleParams, solid_angle, direction, light_position);

    // Traverse the BVH
    RayDesc ray_desc;
    ray_desc.Direction = direction;
    ray_desc.Origin    = offsetPosition(world, normal);
    ray_desc.TMin      = 0.0f;
    ray_desc.TMax      = hasLightPosition(selected_light) ? length(light_position - ray_desc.Origin) : FLT_MAX;

    PopulateCellsPayload payload;
    payload.query_index = query_index;
    payload.world       = world;
    payload.normal      = normal;
    payload.lighting    = light_radiance;
    payload.reservoir   = reservoir;
    PopulateCellsTraceRay(did, payload, ray_desc);

    // And update the hash-grid cell payload
    uint  cell_index         = g_HashGridCache_VisibilityCellBuffer[visibility_index];
    uint4 quantized_radiance = HashGridCache_QuantizeRadiance(payload.lighting);

    if (dot(payload.lighting, payload.lighting) > 0.0f)
    {
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0], quantized_radiance.x);
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1], quantized_radiance.y);
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2], quantized_radiance.z);
    }
    InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3], quantized_radiance.w);

    // In some cases, we want to bypass the cache to avoid light leaks;
    // so we simply patch the screen probes directly and invalidate the
    // cache connection.
    bool is_bypass_cache = ((g_HashGridCache_VisibilityRayBuffer[did] >> 31) != 0);

    if (is_bypass_cache)
    {
        g_RWRayRadianceTexture[pixel_coords] = g_RWRayRadianceTexture[pixel_coords] + float4(GIDenoiser_RemoveNaNs(payload.lighting), 0.f);
    }
}

[numthreads(32, 1, 1)]
void PopulateCellsMain(in uint did : SV_DispatchThreadID)
{
    PopulateCells(did);
}

// BE CAREFUL: we assume
//             UPDATE_TILES_NOT_SLICED_GROUP_* >= g_HashGridCacheConstants.size_tile_mip0
//             UPDATE_TILES_NOT_SLICED_GROUP_*  % g_HashGridCacheConstants.size_tile_mip0 == 0
//
#define UPDATE_TILES_GROUP_X 8
#define UPDATE_TILES_GROUP_Y 8
#define UPDATE_TILES_GROUP_SIZE (UPDATE_TILES_GROUP_X * UPDATE_TILES_GROUP_Y)

groupshared uint2 lds_UpdateTiles_ValueBuffer[UPDATE_TILES_GROUP_X][UPDATE_TILES_GROUP_Y];

[numthreads(1, 1, 1)]
void GenerateUpdateTilesDispatch()
{
    uint num_tiles_by_group = UPDATE_TILES_GROUP_SIZE / g_HashGridCacheConstants.num_cells_per_tile_mip0;

    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = (g_HashGridCache_UpdateTileCountBuffer[0] + num_tiles_by_group - 1) / num_tiles_by_group;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

[numthreads(UPDATE_TILES_GROUP_X, UPDATE_TILES_GROUP_Y, 1)]
void UpdateTiles(in uint group_id : SV_GroupID, in uint2 group_thread_id : SV_GroupThreadID)
{
    // A group cover from 1 tile/subgroup (8x8) to 64 tiles/subgroups (1x1)
    uint2 subgroup_id        = group_thread_id / g_HashGridCacheConstants.size_tile_mip0;
    uint2 subgroup_thread_id = group_thread_id % g_HashGridCacheConstants.size_tile_mip0;
    uint2 subgroup_size      = uint2(UPDATE_TILES_GROUP_X, UPDATE_TILES_GROUP_Y) / g_HashGridCacheConstants.size_tile_mip0;
    uint  update_tile_index  = group_id * subgroup_size.x * subgroup_size.y +
                               subgroup_id.y * subgroup_size.x +
                               subgroup_id.x;

    if (update_tile_index >= g_HashGridCache_UpdateTileCountBuffer[0])
    {
        return;
    }

    uint tile_index = g_HashGridCache_UpdateTileBuffer[update_tile_index];

    // MIP 0
    {
        uint cell_index  = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 0);

        // Temporal accumulation
        float4 radiance     = HashGridCache_UnpackRadiance(g_HashGridCache_ValueBuffer[cell_index]);
        float4 new_radiance = HashGridCache_RecoverRadiance(uint4(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3]));

        float sample_count = min(radiance.w + new_radiance.w, g_HashGridCacheConstants.max_sample_count);

        radiance     /= max(radiance.w, 1.0f);
        new_radiance /= max(new_radiance.w, 1.0f);

        if (radiance.w <= 0.0f)
        {
            radiance = new_radiance;
        }
        else
        {
            radiance = lerp(radiance, new_radiance, 1.0f / sample_count);
        }

        radiance *= sample_count;   // sample count is used as a hint for picking prefiltering amount

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;

        // Clear scratch
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3] = 0;
    }

    // MIP 1
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip1 > 0 && all((group_thread_id % 2) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 1);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance10 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 1][group_thread_id.y + 0];
        uint2 packed_radiance01 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 1];
        uint2 packed_radiance11 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 1][group_thread_id.y + 1];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance10);
        radiance += HashGridCache_UnpackRadiance(packed_radiance01);
        radiance += HashGridCache_UnpackRadiance(packed_radiance11);

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;
    }

    // MIP 2
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip2 > 0 && all((group_thread_id % 4) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 2);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance20 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 2][group_thread_id.y + 0];
        uint2 packed_radiance02 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 2];
        uint2 packed_radiance22 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 2][group_thread_id.y + 2];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance20);
        radiance += HashGridCache_UnpackRadiance(packed_radiance02);
        radiance += HashGridCache_UnpackRadiance(packed_radiance22);

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;
    }

    // MIP 3
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip3 > 0 && all((group_thread_id % 8) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 3);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance40 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 4][group_thread_id.y + 0];
        uint2 packed_radiance04 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 4];
        uint2 packed_radiance44 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 4][group_thread_id.y + 4];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance40);
        radiance += HashGridCache_UnpackRadiance(packed_radiance04);
        radiance += HashGridCache_UnpackRadiance(packed_radiance44);

        // Pack
        g_HashGridCache_ValueBuffer[cell_index] = HashGridCache_PackRadiance(radiance);
    }
}

[numthreads(64, 1, 1)]
void ResolveCells(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    uint visibility_index = g_HashGridCache_VisibilityRayBuffer[did];

    if ((visibility_index >> 31) != 0)
    {
        return; // do not use filtered radiance
    }

    uint cell_index  = g_HashGridCache_VisibilityCellBuffer[visibility_index];
    uint query_index = g_HashGridCache_VisibilityQueryBuffer[visibility_index];

    float4 radiance = HashGridCache_FilteredRadiance(cell_index, false);

    int2 pixel_coords = int2(query_index % g_OutputDimensions.x, query_index / g_OutputDimensions.x);
#ifdef ENABLE_INDIRECT
    g_RWRayRadianceTexture[pixel_coords] = g_RWRayRadianceTexture[pixel_coords] + float4(GIDenoiser_RemoveNaNs(radiance.xyz / max(radiance.w, 1.0f)), 0.f);
#endif
}

[numthreads(8, 8, 1)]
void PrecomputeHiZ (int2 DispatchID : SV_DispatchThreadID) {
    int2 Dimensions;
    g_RWHiZ_Out.GetDimensions(Dimensions.x, Dimensions.y);
    if(any(DispatchID >= Dimensions)) {
        return;
    }
    float X00 = g_RWHiZ_In[int2(2 * DispatchID.x + 0, 2 * DispatchID.y + 0)].x;
    float X01 = g_RWHiZ_In[int2(2 * DispatchID.x + 0, 2 * DispatchID.y + 1)].x;
    float X10 = g_RWHiZ_In[int2(2 * DispatchID.x + 1, 2 * DispatchID.y + 0)].x;
    float X11 = g_RWHiZ_In[int2(2 * DispatchID.x + 1, 2 * DispatchID.y + 1)].x;
#ifdef HIZ_MIN
    float X0 = min(X00, X01);
    float X1 = min(X10, X11);
    float X = min(X0, X1);
#else
    if(X00 == 1.f) X00 = 0.f;
    if(X01 == 1.f) X01 = 0.f;
    if(X10 == 1.f) X10 = 0.f;
    if(X11 == 1.f) X11 = 0.f;
    float X0 = max(X00, X01);
    float X1 = max(X10, X11);
    float X = max(X0, X1);
    if(X == 0.f) X = 1.f;
#endif
    g_RWHiZ_Out[DispatchID] = X;
}

groupshared uint LocalAccessedSG[SSRC_MAX_BASIS_PER_TILE];
// Precompute the cache update
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_PrecomputeCacheUpdate (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID             = GroupID.x + GroupID.y * g_TileDimensions.x;
    int TileBasisCount     = g_RWTileBasisCountBuffer[TileID];
    int TileSlotBaseOffset = g_RWTileBaseSlotOffsetBuffer[TileID];
    int2 TileTextureBaseOffset = int2(GroupID.x * SSRC_TILE_SIZE, GroupID.y * SSRC_TILE_SIZE);

    // Thread local accumulators
    float3 ThreadSumRadiance[SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE];
    float  ThreadSumWeight  [SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE];
    for(int i = 0; i< SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE; i++) {
        ThreadSumRadiance[i] = 0.f.xxx;
        ThreadSumWeight  [i] = 0.f;
    }

    // Omit invalid pixels
    float3 ThreadRayDirection[WAVE_RAY_SIZE];
    float3 ThreadRayRadiance [WAVE_RAY_SIZE];
    float3 ThreadRayOrigin   [WAVE_RAY_SIZE];
    uint   TileUpdateRayOffset = g_RWTileRayOffsetBuffer[TileID];
    uint   TileUpdateRayCount  = g_RWTileRayCountBuffer[TileID];
    const int REPEAT = min(WAVE_RAY_SIZE, (TileUpdateRayCount + WAVE_SIZE - 1) / WAVE_SIZE);
    for(int i = 0; i< REPEAT; i++) {
        int TileRayRank = i * WAVE_SIZE + LocalID;
        if(TileRayRank < TileUpdateRayCount) {
            float3 RayDirection = UnpackNormal(g_RWUpdateRayDirectionBuffer[TileUpdateRayOffset + TileRayRank]);
            uint2 PackedRO = g_RWUpdateRayRadianceOriginBuffer[TileUpdateRayOffset + TileRayRank];
            float3 RayRadiance  = UnpackFp16x3(PackedRO);
            float2 SubTileUV = unpackUnorm2x8(PackedRO.y>>16);
            float2 UV = (float2(GroupID) + SubTileUV) * g_TileDimensionsInv;
            float  Depth = g_DepthTexture.Load(int3(UV * g_OutputDimensions, 0)).x;
            float3 RayOrigin    = InverseProject(g_CameraProjViewInv, UV, Depth);
            ThreadRayDirection[i] = RayDirection;
            ThreadRayRadiance [i] = RayRadiance;
            ThreadRayOrigin   [i] = RayOrigin;
        }
    }

    
    // Iterate over each basis overlapping with this tile
    for(int Slot = 0; Slot < TileBasisCount; Slot ++) {
        bool AccessedSG = false;
        int  BasisIndex = g_RWTileBasisIndexBuffer[TileSlotBaseOffset + Slot];
        SGData SG;
        WData  W;
        FetchBasisData_W(BasisIndex, SG, W);
        float3 BasisWorldPosition;
        FetchBasisLocation(BasisIndex, BasisWorldPosition);
        // Cooperatively iterate over all pixels of the grid
        for(int i = 0; i < REPEAT; i += WAVE_SIZE) {
            int TileRayRank = i * WAVE_SIZE + LocalID;
            if(TileRayRank < TileUpdateRayCount) {
                // There is no bank conflict as the stride is 3 * 4 bytes for float3
                // Loading from shmem is done in 1 cycle per word
                float3 RayDirection = ThreadRayDirection[i];
                float3 RayRadiance  = ThreadRayRadiance [i];

                float3 EvaluatedRadiance = EvaluateSG(SG, RayDirection);
                float3 DeltaPosition     = ThreadRayOrigin[i] - BasisWorldPosition;
                float  EvaluatedW        = EvaluateW(W, DeltaPosition);

                // Use thread local registers to accumulate results
                ThreadSumRadiance[i] += EvaluatedRadiance * EvaluatedW;
                ThreadSumWeight  [i] += EvaluatedW;

                if(EvaluatedW > 0) AccessedSG = true;
            }
        }
        AccessedSG = WaveActiveAnyTrue(AccessedSG);
        if(LocalID == 0) {
            if(AccessedSG) LocalAccessedSG[Slot] = BasisIndex;
            else LocalAccessedSG[Slot] = kGI10_InvalidId;
        }
    }
    // Cooperatively write back the data
    for(int i = 0; i < REPEAT; i += WAVE_SIZE) {
        int TileRayRank = i * WAVE_SIZE + LocalID;
        if(TileRayRank < TileUpdateRayCount) {
            int UpdateRayIndex = TileUpdateRayOffset + TileRayRank;
            float3 RayRadiance = ThreadRayRadiance[i];
            float3 SumRadiance = ThreadSumRadiance[i];
            float  SumWeight   = ThreadSumWeight  [i];
            if(SumWeight != 0) {
                float3 DiffRadiance = RayRadiance - SumRadiance / SumWeight;
                g_RWUpdateRayCacheBuffer[UpdateRayIndex] = float4(DiffRadiance, SumWeight);
            } else 
                g_RWUpdateRayCacheBuffer[UpdateRayIndex] = float4(RayRadiance, 0.f);
        }
    }
    GroupMemoryBarrierWithGroupSync();
    // Update basis decays
    for(int BaseOffset = 0; BaseOffset < TileBasisCount; BaseOffset += WAVE_SIZE) {
        int Slot = BaseOffset + LocalID;
        if(Slot < TileBasisCount) {
            uint BasisIndex = LocalAccessedSG[Slot];
            if(BasisIndex != kGI10_InvalidId) g_RWBasisFlagsBuffer[BasisIndex] = g_FrameIndex;
        }
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_ComputeCacheUpdateStep (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID             = GroupID.x + GroupID.y * g_TileDimensions.x;
    int TileBasisCount     = g_RWTileBasisCountBuffer[TileID];
    int TileSlotBaseOffset = g_RWTileBaseSlotOffsetBuffer[TileID];
    int2 TileTextureBaseOffset = int2(GroupID.x * SSRC_TILE_SIZE, GroupID.y * SSRC_TILE_SIZE);

    uint   TileUpdateRayOffset = g_RWTileRayOffsetBuffer[TileID];
    uint   TileUpdateRayCount  = g_RWTileRayCountBuffer[TileID];
    const int REPEAT = min(WAVE_RAY_SIZE, (TileUpdateRayCount + WAVE_SIZE - 1) / WAVE_SIZE);

    // Omit invalid pixels
    float3 ThreadRayDirection[WAVE_RAY_SIZE];
    float3 ThreadRayRadianceDifference[WAVE_RAY_SIZE];
    float  ThreadSumWeight[WAVE_RAY_SIZE];
    float3 ThreadRayOrigin[WAVE_RAY_SIZE];
    float3 ThreadWeightedSumEvaluatedRadiance[WAVE_RAY_SIZE];
    for(int i = 0; i< REPEAT; i++) {
        int TileRayRank = i * WAVE_SIZE + LocalID;
        if(TileRayRank < TileUpdateRayCount) {
            float3 RayDirection = UnpackNormal(g_RWUpdateRayDirectionBuffer[TileUpdateRayOffset + TileRayRank]);
            float4 RayRadianceDifferenceWSum = g_RWUpdateRayCacheBuffer[TileUpdateRayOffset + TileRayRank];
            uint2  ROPacked                  = g_RWUpdateRayRadianceOriginBuffer[TileUpdateRayOffset + TileRayRank];
            float3 RayRadiance = UnpackFp16x3(ROPacked);
            float2 SubTileUV   = unpackUnorm2x8(ROPacked.y>>16);
            float2 UV          = (float2(GroupID) + SubTileUV) * g_TileDimensionsInv;
            float  Depth       = g_DepthTexture.Load(int3(UV * g_OutputDimensions, 0)).x;
            float3 RayOrigin   = InverseProject(g_CameraProjViewInv, UV, Depth);
            ThreadRayDirection[i]          = RayDirection;
            ThreadRayRadianceDifference[i] = RayRadianceDifferenceWSum.xyz;
            ThreadSumWeight[i]             = RayRadianceDifferenceWSum.w;
            ThreadRayOrigin[i]             = RayOrigin;
            ThreadWeightedSumEvaluatedRadiance[i]  = (RayRadiance - RayRadianceDifferenceWSum.xyz) * RayRadianceDifferenceWSum.w;
        }
    }
    
    // Iterate over each basis overlapping with this tile
    for(int Slot = 0; Slot < TileBasisCount; Slot ++) {
        // Thread local accumulators
        SGGradients SumStepSize   = (SGGradients)0;
        WGradients  SumStepSize_W = (WGradients)0;
        int BasisIndex = g_RWTileBasisIndexBuffer[TileSlotBaseOffset + Slot];
        SGData SG;
        WData  W;
        FetchBasisData_W(BasisIndex, SG, W);
        float3 BasisWorldPosition;
        FetchBasisLocation(BasisIndex, BasisWorldPosition);
#ifdef HEURISTIC_DIRECTION_UPDATE
        float SumContrib = 0.f;
#endif
        // Cooperatively iterate over all pixels of the grid
        for(int i = 0; i< REPEAT; i++) {
            int TileRayRank = i * WAVE_SIZE + LocalID;
            if(TileRayRank < TileUpdateRayCount) {
                // There is no bank conflict as the stride is (1 or 3) * 4 bytes for float3
                // Loading from shmem is done in 1 cycle per word
                float3 RayDirection          = ThreadRayDirection[i];
                float3 RayRadianceDifference = ThreadRayRadianceDifference[i];
                float  SumWeight             = ThreadSumWeight[i];
                float  InvSumWeight          = 1.f / SumWeight;

                float3 SGEvaluatedRadiance   = EvaluateSG(SG, RayDirection);
                float3 DeltaPosition         = ThreadRayOrigin[i] - BasisWorldPosition;
                float  EvaluatedW            = EvaluateW(W, DeltaPosition);

                float  RestWeight             = SumWeight - EvaluatedW;
                float3 WeightedSumEvaluatedRadiance   = ThreadWeightedSumEvaluatedRadiance[i];
                
                // float3 A3 = 
                //     (RestWeight * SGEvaluatedRadiance - (SumEvaluatedRadiance - SGEvaluatedRadiance * EvaluatedW))
                //      / (SumWeight * SumWeight);
                // float  A = dot(A3, 1.f.xxx);
                float3 A3 = (SGEvaluatedRadiance * RestWeight - (WeightedSumEvaluatedRadiance - SGEvaluatedRadiance * EvaluatedW)) * (1.f / (SumWeight * SumWeight));
                float  A  = dot(A3, 1.f.xxx);

                // Compute gradients
                SGGradients Gradients;
                WGradients  Gradients_W;
                float3 dColorExtra;
                EvaluateSG_Gradients(SG, RayDirection, Gradients, dColorExtra);
                Gradients.dColor += dColorExtra;
                float3 DeltaRadiance    = RayRadianceDifference;
                float  DeltaRadianceSum = dot(DeltaRadiance, 1.f.xxx);
                // The weight of SG for the current shading point (SP)
                float  SGWeightForSP    = EvaluatedW * InvSumWeight;
                EvaluateW_Gradients(W, DeltaPosition, Gradients_W);
                // Accumulate and combine gradients for optimal descending
                // TODO adaptive learning rate based on the magnitude of the gradients
                SumStepSize.dColor     += DeltaRadiance    * Gradients.dColor     * SGWeightForSP;
#ifdef HEURISTIC_DIRECTION_UPDATE
                // Approximate direction directly using the radiance difference
                SumStepSize.dDirection += DeltaRadianceSum * RayDirection         * SGWeightForSP;
#else
                SumStepSize.dDirection += DeltaRadianceSum * Gradients.dDirection * SGWeightForSP;
#endif
                SumStepSize.dLambda    += DeltaRadianceSum * Gradients.dLambda    * SGWeightForSP;
                // F = W / (S+W) * f, so the step size of W is calculated by the followings
                SumStepSize_W.dLambda  += DeltaRadianceSum * A * Gradients_W.dLambda;
                SumStepSize_W.dAlpha   += DeltaRadianceSum * A * Gradients_W.dAlpha;
#ifdef HEURISTIC_DIRECTION_UPDATE
                SumContrib += SGWeightForSP;
#endif
            }
        }
        // Wave reduce the gradients
        SumStepSize.dColor     = WaveActiveSum(SumStepSize.dColor);
        SumStepSize.dDirection = WaveActiveSum(SumStepSize.dDirection);
        SumStepSize.dLambda    = WaveActiveSum(SumStepSize.dLambda);
        SumStepSize_W.dLambda  = WaveActiveSum(SumStepSize_W.dLambda);
        SumStepSize_W.dAlpha   = WaveActiveSum(SumStepSize_W.dAlpha);
#ifdef HEURISTIC_DIRECTION_UPDATE
        SumContrib             = WaveActiveSum(SumContrib);
#endif
        if(WaveIsFirstLane()) {
            // Accumulate the gradients with atomic operations.
            // Note: Performance for atomic operations drops drastically when the quantlilized step buffer 
            // for accumulation overflows the L2 GPU cache (8MB for 3090). 
            // (about 1ms for 250000 basis, and 32 random basis for each tile)
            // However, if we kept some locallity in the accumulation (by processing adjacent tiles at one time), 
            // the performance is still acceptable.
            // (No L2 overflow: 200us)
#ifdef HEURISTIC_DIRECTION_UPDATE
            // Divide by total SG contribution to SPs to make adjacent SP more significant
            SumStepSize.dDirection = SumStepSize.dDirection / SumContrib;
#else
            // Here we accumulate the orthogonal gradients for the direction only
            // dColorExtra is already accumulated in the dColor
            SumStepSize.dDirection = SumStepSize.dDirection - dot(SumStepSize.dDirection, SG.Direction) * SG.Direction;
#endif
            ScreenCache_AccumulateStepSize(BasisIndex, SumStepSize, SumStepSize_W);
        }
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_NormalizeCacheUpdate (int DispatchID : SV_DispatchThreadID, int GroupID : SV_GroupID) {
    if(DispatchID >= g_RWActiveBasisCountBuffer[0]) {
        return;
    }
    uint BasisIndex = g_RWActiveBasisIndexBuffer[DispatchID];
    SGGradients Step_SG;
    WGradients  Step_W;
    // Compute the step size
    ScreenCache_GetStepSize(BasisIndex, Step_SG, Step_W);
    float Scale = 0.f;
    if(g_CacheUpdate_SGColor) {
        Scale += dot(Step_SG.dColor, Step_SG.dColor);
    }
    SGData SG;
    WData  W;
    FetchBasisData_W(BasisIndex, SG, W);
#ifndef  HEURISTIC_DIRECTION_UPDATE
    float3 Ortho = Step_SG.dDirection - dot(Step_SG.dDirection, SG.Direction) * SG.Direction;
    if(g_CacheUpdate_SGDirection) {
        Scale += dot(Ortho, Ortho);
    }
#endif
    if(g_CacheUpdate_SGLambda) {
        Scale += dot(Step_SG.dLambda, Step_SG.dLambda);
    }
    if(g_CacheUpdate_WAlpha) {
        Scale += Step_W.dAlpha * Step_W.dAlpha;
    }
    if(g_CacheUpdate_WLambda) {
        Scale += Step_W.dLambda * Step_W.dLambda;
    }
    float ScaleWave = WaveActiveSum(Scale);
    if(WaveIsFirstLane()) {
        g_RWUpdateStepScaleSumsBuffer[GroupID] = ScaleWave;
    }
}

[numthreads(1, 1, 1)]
void SSRC_NormalizeCacheUpdateSetReduceCount () {
    g_RWReduceCountBuffer[0] = (g_RWActiveBasisCountBuffer[0] + WAVE_SIZE - 1) / WAVE_SIZE;
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_ApplyCacheUpdate (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= g_RWActiveBasisCountBuffer[0]) {
        return;
    }
    uint BasisIndex = g_RWActiveBasisIndexBuffer[DispatchID];
    SGData SG;
    WData  W;
    SGGradients Step_SG;
    WGradients  Step_W;
    float3 BasisPosition;
    FetchBasisData_W(BasisIndex, SG, W);
    FetchBasisLocation(BasisIndex, BasisPosition);
    // Compute the step size
    ScreenCache_GetStepSize(BasisIndex, Step_SG, Step_W);
    // TODO global normalization
    float NormalizationFactor = 1000.f / sqrt(max(g_RWUpdateStepScaleBuffer[0], 1e-6f));
    // NormalizationFactor = 1.f;
    float RandomStride = sin(DispatchID * 4.13f + g_FrameIndex * 71838.3f) * 0.5f + 0.5f;
    NormalizationFactor *= RandomStride;
    // Update the basis
    if(g_CacheUpdate_SGDirection) {
#ifndef HEURISTIC_DIRECTION_UPDATE
        float3 Ortho = Step_SG.dDirection - dot(Step_SG.dDirection, SG.Direction) * SG.Direction;
        SG.Direction += Ortho * g_CacheUpdateLearningRate * NormalizationFactor;
        SG.Direction =  lazyNormalize(SG.Direction);
#else
        float DstWeight     = length(Step_SG.dDirection);
        float3 DstDirection = Step_SG.dDirection / DstWeight;
        float SrcWeight     = dot(SG.Color, 1.f.xxx) * 10.f;
        float3 SrcDirection = SG.Direction;
        float3 Direction    = SrcDirection * SrcWeight + DstDirection * DstWeight;
        SG.Direction = lazyNormalize(Direction);
#endif
    }
    if(g_CacheUpdate_SGColor) {
        SG.Color     += Step_SG.dColor     * g_CacheUpdateLearningRate * NormalizationFactor;
        SG.Color     = max(SG.Color, 0.01f.xxx); // Color is in [0.01, inf)
    }
    if(g_CacheUpdate_SGLambda) {
        SG.Lambda    += Step_SG.dLambda    * g_CacheUpdateLearningRate * NormalizationFactor;
        SG.Lambda    = clamp(SG.Lambda, 0.85f, 5.f); // Lambda is in [0.85f, 5.f]
    }
    if(g_CacheUpdate_WAlpha) {
        W.Alpha      += Step_W.dAlpha      * g_CacheUpdateLearningRate * NormalizationFactor;
        W.Alpha      = clamp(W.Alpha, 0.02f, 0.9999f); // Alpha is in [0.02f, 1.f)
    }
    if(g_CacheUpdate_WLambda) {
        W.Lambda     += Step_W.dLambda     * g_CacheUpdateLearningRate * NormalizationFactor;
        W.Lambda     = clamp(W.Lambda, 100.f, 1e6f); // Lambda is in [1e3, 1e7]
    }
    // Write back the data
    WriteBasisData_W(BasisIndex, SG, W);
    // TODO update position
    // WriteBasisLocation(DispatchID, BasisPosition);
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_SpawnNewBasis (int3 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * g_TileDimensions.x;
    int TileBasisCount = g_RWTileBasisCountBuffer[TileID];
    if(TileBasisCount >= SSRC_MAX_BASIS_PER_TILE) {
        // Overflowed
        return ;
    }
    uint TileGlobalID = TileID + g_FrameIndex * g_TileDimensions.x * g_TileDimensions.y;
    // Introduce blue noise spawnning pattern upon raw tiles.
    int2 MinLocation  = BlueNoise_Sample2D(GroupID.xy, g_FrameIndex) * 0.999f * SSRC_TILE_SIZE;
    uint TileMask = (MinLocation.x + MinLocation.y * SSRC_TILE_SIZE) & 0xfffu;
    // Find a pixel with minimum weight coverage
    uint MinCoveragePacked    = 0xffffffffu ^ TileMask;
    // We assume SSRC_TILE_SIZE * SSRC_TILE_SIZE is a multiple of WAVE_SIZE
    for(int Offset = 0; Offset < SSRC_TILE_SIZE * SSRC_TILE_SIZE; Offset += WAVE_SIZE) {
        int PixelIndex = Offset + LocalID;
        int PixelX = PixelIndex % SSRC_TILE_SIZE;
        int PixelY = PixelIndex / SSRC_TILE_SIZE;
        int2 TexCoords = int2(GroupID.x * SSRC_TILE_SIZE + PixelX, GroupID.y * SSRC_TILE_SIZE + PixelY);
        float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
        // Filter valid pixels
        if(Depth < 1.f) {
            float3 ViewDirection = GetCameraRayDirection(TexCoords);
            float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
            float  CorrectionFactor = 1.f / abs(dot(GeometryNormal, ViewDirection));
            float  Coverage3 = g_RWRayRadianceDifferenceWSumTexture[TexCoords].w * CorrectionFactor;
            float Coverage = clamp(Coverage3, 0.f, 0.99f);
            MinCoveragePacked = min(MinCoveragePacked, ((0xfffff & uint(Coverage * 0xfffff)) << 12) | (uint(PixelIndex) ^ TileMask));
        }
    }
    MinCoveragePacked = WaveActiveMin(MinCoveragePacked);
    int BasisIndex = kGI10_InvalidId;
    float3 WorldPosition, SurfaceNormal;
    int2 SpawnTexCoords;
    float WLambda;
    if(WaveIsFirstLane()) {
        int2 BaseTexCoords = int2(GroupID.x * SSRC_TILE_SIZE, GroupID.y * SSRC_TILE_SIZE);
        uint MinPixelIndex = (MinCoveragePacked & 0xfff) ^ TileMask;
        float MinCoverage  = float(MinCoveragePacked >> 12) / 0xfffff;
        // Pad to prevent over spawnning on surfaces perpendicular to view direction.
        float PaddingValue = float(TileBasisCount) / SSRC_MAX_BASIS_PER_TILE;
        // We assume that each basis injects to 8 adjacent tiles
        MinCoverage += PaddingValue * PaddingValue * g_BasisSpawnCoverageThreshold * 8.f;
        bool ShouldSpawn = MinCoverage < g_BasisSpawnCoverageThreshold;
        // FIXME
        ShouldSpawn = TileBasisCount < 16;
        if(ShouldSpawn && MinPixelIndex != 0xfff && !g_FreezeBasisAllocation) {
            // New basis is here!
            int2 PixelCoords = int2(MinPixelIndex % SSRC_TILE_SIZE, MinPixelIndex / SSRC_TILE_SIZE);
            SpawnTexCoords = BaseTexCoords + PixelCoords;
            uint BasisAllocIndex;
            InterlockedAdd(g_RWFreeBasisIndicesCountBuffer[0], -1, BasisAllocIndex);
            BasisAllocIndex = BasisAllocIndex - 1;
            if(BasisAllocIndex < 0x7fffffffu) {
                // Allocation succeeded
                BasisIndex = g_RWFreeBasisIndicesBuffer[BasisAllocIndex];
                // The last slot for each tile is reserved for the newly allocated basis
                // Inject it to the tile basis index
                g_RWTileBasisIndexBuffer[g_RWTileBaseSlotOffsetBuffer[TileID] + TileBasisCount] = BasisIndex;
                g_RWTileBasisCountBuffer[TileID] = TileBasisCount + 1;
                float2 UV = (SpawnTexCoords + 0.5f) / g_OutputDimensions;
                float  PixelDepth = g_DepthTexture.Load(int3(SpawnTexCoords, 0)).x;
                float3 PixelNormal = normalize(2.f * g_ShadingNormalTexture.Load(int3(SpawnTexCoords, 0)).xyz - 1.f);
                WorldPosition = InverseProject(g_CameraProjViewInv, UV, PixelDepth);
                float U = BlueNoise_Sample1D(GroupID.xy + int2(8271, 2983), g_FrameIndex).x;
                // Randomize radius
                float X  = GetLinearDepth(PixelDepth) * g_CameraPixelScale * g_BasisWInitialRadius;
                // FIXME
                X = X;// * lerp(0.8f, 6.5f, U * U * U);
                WLambda = -log(g_MinWeightE) / (X * X);
                SurfaceNormal = PixelNormal;
            }
        }
    }

    BasisIndex = WaveReadLaneFirst(BasisIndex);
    // Quit the wave if no new basis is allocated
    [branch]
    if(BasisIndex == kGI10_InvalidId) return ;

    WorldPosition  = WaveReadLaneFirst(WorldPosition);
    SpawnTexCoords = WaveReadLaneFirst(SpawnTexCoords);
    SurfaceNormal  = WaveReadLaneFirst(SurfaceNormal);
    WData W = (WData)0;
    W.Lambda       = WaveReadLaneFirst(WLambda);
    W.Alpha        = 1.f;

    float  SumInitWeight    = 0.f;
    float3 SumInitRadiance  = 0.f.xxx;
    float3 SumInitDirection = 0.f.xxx;

    // Guess the SG direction with a heuristic
    for(int PixelBaseOffset = 0; 
        PixelBaseOffset < SSRC_TILE_SIZE * SSRC_TILE_SIZE; 
        PixelBaseOffset += WAVE_SIZE) {
        int  PixelIndex  = PixelBaseOffset + LocalID;
        int2 PixelCoords = int2(PixelIndex % SSRC_TILE_SIZE, PixelIndex / SSRC_TILE_SIZE);
        int2 TexCoords   = SpawnTexCoords + PixelCoords - (SSRC_TILE_SIZE / 2).xx;
        if(all(TexCoords >= 0) && all(TexCoords < g_OutputDimensions)) {
            float CurrentPixelDepth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
            if(CurrentPixelDepth < 1.f) {
                float2 CurrentUV = (TexCoords + 0.5f) / g_OutputDimensions; 
                float3 CurrentWorldPos = InverseProject(g_CameraProjViewInv, CurrentUV, CurrentPixelDepth);
                float3 CurrentOutRayDirection  = g_RWRayDirectionTexture[TexCoords].xyz;
                float3 CurrentOutRayDifference = g_RWRayRadianceDifferenceWSumTexture[TexCoords].xyz;
                // Normalize probability for choosing different directions by dividing
                // ray direction pdf in sample weight averaging
                float  InvPdf = g_RWRayDirectionTexture[TexCoords].w;
                float3 DeltaPosition = CurrentWorldPos - WorldPosition;
                // Clamp W to provide enough samples for the initial guess
                float EvaluatedW = EvaluateW(W, DeltaPosition) + 0.01f;
                // Find the direction with maximum difference (no matter positive or negative)
                float DifferenceWeight = dot(abs(CurrentOutRayDifference), 1.f.xxx);
                // Omit the direction with negative dot product with the surface normal
                if(dot(CurrentOutRayDirection, SurfaceNormal) < 0) continue ;
                SumInitDirection += CurrentOutRayDirection * DifferenceWeight * EvaluatedW * InvPdf;
            }
        }
    }
    SumInitDirection = WaveActiveSum(SumInitDirection);
    
    SGData SG;
    if(length(SumInitDirection) != 0.f)
        SG.Direction = normalize(SumInitDirection);
    else SG.Direction = SurfaceNormal;
    // TODO better initialization of lambda
    float M      = BlueNoise_Sample1D(GroupID.xy + int2(3817, 4905), g_FrameIndex).x;
    // FIXME
    SG.Direction = SurfaceNormal;
    SG.Lambda    = 1.85f;//lerp(0.35f, 1.2f, M);
    SG.Color     = 1.f.xxx;

    SumInitWeight = 0.f;
    // Initialize the Color of SG according to ray differences
    for(int PixelBaseOffset = 0; 
        PixelBaseOffset < SSRC_TILE_SIZE * SSRC_TILE_SIZE; 
        PixelBaseOffset += WAVE_SIZE) {
        int  PixelIndex  = PixelBaseOffset + LocalID;
        int2 PixelCoords = int2(PixelIndex % SSRC_TILE_SIZE, PixelIndex / SSRC_TILE_SIZE);
        int2 TexCoords   = SpawnTexCoords + PixelCoords - (SSRC_TILE_SIZE / 2).xx;
        if(all(TexCoords >= 0) && all(TexCoords < g_OutputDimensions)) {
            float CurrentPixelDepth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
            if(CurrentPixelDepth < 1.f) {
                float2 CurrentUV = (TexCoords + 0.5f) / g_OutputDimensions; 
                float3 CurrentWorldPos = InverseProject(g_CameraProjViewInv, CurrentUV, CurrentPixelDepth);
                float3 CurrentOutRayDirection  = g_RWRayDirectionTexture[TexCoords].xyz;
                float3 CurrentOutRayRadiance   = g_RWRayRadianceTexture[TexCoords].xyz;
                float  InvPdf = g_RWRayDirectionTexture[TexCoords].w;
                float3 DeltaPosition = CurrentWorldPos - WorldPosition;
                // Clamp W to provide enough samples for the initial guess
                float EvaluatedW = EvaluateW(W, DeltaPosition) + 0.01f;
                float  F          = EvaluateSG(SG, CurrentOutRayDirection).x;
                float  B          = EvaluatedW * InvPdf;
                float3 T          = CurrentOutRayRadiance;
                // Want minimize \sum B * |F * alpha - T| for alpha
                float3 BestAlpha  = T / F;
                float  DiffAlpha  = B * F;
                // Simply do an average

                SumInitWeight    += DiffAlpha;
                SumInitRadiance  += BestAlpha * DiffAlpha;
            }
        }
    }
    SumInitWeight   = WaveActiveSum(SumInitWeight);
    SumInitRadiance = WaveActiveSum(SumInitRadiance);

    if(LocalID == 0) {
        // Fall back to 1.f.xxx if the guessing provides an invalid color
        if(SumInitWeight != 0.f) {
            SG.Color = SumInitRadiance / SumInitWeight;
        } else SG.Color = float3(1.f, 0.f, 0.f);
        // Write the basis data
        WriteBasisData_W(BasisIndex, SG, W);
        WriteBasisLocation(BasisIndex, WorldPosition);
        // Mark the basis as active
        g_RWBasisFlagsBuffer[BasisIndex] = g_FrameIndex;
    }
}

[numthreads(1, 1, 1)]
void SSRC_ClipOverAllocation () {
    if(g_RWFreeBasisIndicesCountBuffer[0] > 0x7fffffffu) {
        g_RWFreeBasisIndicesCountBuffer[0] = 0;
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_IntegrateASG (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * g_TileDimensions.x;
    int TileBasisCount = g_RWTileBasisCountBuffer[TileID];
    int TileSlotBaseOffset = g_RWTileBaseSlotOffsetBuffer[TileID];
    int2 TileTextureBaseOffset = int2(GroupID.x * SSRC_TILE_SIZE, GroupID.y * SSRC_TILE_SIZE);

    GroupMemoryBarrierWithGroupSync();
    // Thread local compute resources
    float3 ThreadSumRadiance[SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE];
    float  ThreadSumWeight  [SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE];
    float3 ThreadWorldPosition[SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE];
    float3 ThreadGeometryNormal[SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE];
    float3 ThreadShadingNormal [SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE];
    MaterialBRDF ThreadMaterialBRDF[SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE];
    MaterialEmissive ThreadMaterialEmissive[SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE];
    for(int i = 0; i< SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE; i++) {
        int PixelIndex = i * WAVE_SIZE + LocalID;
        int PixelX = PixelIndex % SSRC_TILE_SIZE;
        int PixelY = PixelIndex / SSRC_TILE_SIZE;
        ThreadSumRadiance[i] = 0.f.xxx;
        ThreadSumWeight  [i] = 0.f;
        int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
        float2 UV = (TexCoords + 0.5f) / g_OutputDimensions;
        float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
        if(Depth < 1.f) {
            float3 WorldPosition = InverseProject(g_CameraProjViewInv, UV, Depth);
            float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
            float3 ShadingNormal  = normalize(2.f * g_ShadingNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
            float4 Visbility = g_VisibilityTexture.Load(int3(TexCoords, 0));
            uint InstanceID = asuint(Visbility.z);
            uint PrimitiveID = asuint(Visbility.w);
            Instance InstanceData = g_InstanceBuffer[InstanceID];
            UVs PrimitiveUVs = fetchUVs(g_MeshBuffer[InstanceData.mesh_index], PrimitiveID);
            float2 MeshUV = interpolate(PrimitiveUVs.uv0, PrimitiveUVs.uv1, PrimitiveUVs.uv2, Visbility.xy);
            Material MaterialData = g_MaterialBuffer[InstanceData.material_index];
            MaterialEmissive EmissiveMaterialData = MakeMaterialEmissive(MaterialData, MeshUV);
            MaterialBRDF MaterialBRDFData = MakeMaterialBRDF(MaterialData, MeshUV);
            ThreadWorldPosition [i] = WorldPosition;
            ThreadGeometryNormal[i] = GeometryNormal;
            ThreadShadingNormal [i] = ShadingNormal;
            ThreadMaterialBRDF  [i] = MaterialBRDFData;
            ThreadMaterialEmissive [i] = EmissiveMaterialData;
        }
    }

    // Iterate over each basis overlapping with this tile
    for(int Slot = 0; Slot < TileBasisCount; Slot ++) {
        int BasisIndex = g_RWTileBasisIndexBuffer[TileSlotBaseOffset + Slot];
        SGData SG;
        WData  W;
        FetchBasisData_W(BasisIndex, SG, W);
        float3 BasisWorldPosition;
        FetchBasisLocation(BasisIndex, BasisWorldPosition);
        // Cooperatively iterate over all pixels of the grid
        for(int PixelIndexBase = 0; PixelIndexBase < SSRC_TILE_SIZE * SSRC_TILE_SIZE; PixelIndexBase += WAVE_SIZE) {
            int PixelIndex = PixelIndexBase + LocalID;
            int PixelX = PixelIndex % SSRC_TILE_SIZE;
            int PixelY = PixelIndex / SSRC_TILE_SIZE;
            float3 PixelPosition = ThreadWorldPosition[PixelIndexBase / WAVE_SIZE];
            float3 ShadingNormal = ThreadShadingNormal[PixelIndexBase / WAVE_SIZE];
            float3 GeometryNormal = ThreadGeometryNormal[PixelIndexBase / WAVE_SIZE];
            MaterialBRDF MaterialBRDFData = ThreadMaterialBRDF[PixelIndexBase / WAVE_SIZE];
            float3 ViewDirection = normalize(g_CameraPosition - PixelPosition);
            float DotNV = saturate(dot(ShadingNormal, ViewDirection));
            float3 LightDirection = SG.Direction;
            float3 ReflectionDirection = calculateGGXSpecularDirection(ShadingNormal, ViewDirection, sqrt(MaterialBRDFData.roughnessAlpha));
            float3 HalfVector = normalize(LightDirection + ViewDirection);
            float3 HalfVector_Spec = normalize(ReflectionDirection + ViewDirection);
            float dotNL = saturate(dot(LightDirection, ShadingNormal));
            float dotNV = saturate(dot(ShadingNormal, ViewDirection));
            float dotHV = saturate(dot(HalfVector, ViewDirection));
            float dotSpecHV = saturate(dot(HalfVector_Spec, ViewDirection));
            // Approximate \int D * Li with ASG
            // we use RoughnessAlpha here
            float3 GGX_D_Li_Approx = SpecularTermASGWarp(SG, ShadingNormal, MaterialBRDFData.roughnessAlphaSqr, ViewDirection);
            float3 FresnelTerm = fresnel(MaterialBRDFData.F0, dotHV);
            float  VisibilityTerm   = evaluateVisibilityGGX(MaterialBRDFData.roughnessAlphaSqr, dotNL, dotNV);
            // TODO will it be faster using lut approximation for (FresnelTerm / VisibilityTerm)?
            float3 GGXIntegrationApprox = (FresnelTerm / VisibilityTerm) * GGX_D_Li_Approx ;
            float3 DiffuseCompensation = diffuseCompensationTerm(FresnelTerm, dotSpecHV);
            float3 LambertIntegration = SGDiffuseInnerProduct(SG, ShadingNormal, MaterialBRDFData.albedo) * DiffuseCompensation;
            float3 Jitter = 0.f.xxx;//BlueNoise_Sample2D(RealCoord, g_FrameIndex, 2) * 2.f - 1.f;
            float3 DeltaPosition = PixelPosition - BasisWorldPosition;
            // Pad the weight to make all pixels are shaded
            float EvaluatedW = EvaluateW(W, DeltaPosition + Jitter);
            ThreadSumRadiance[PixelIndexBase / WAVE_SIZE] += (GGXIntegrationApprox + LambertIntegration) * EvaluatedW;
            ThreadSumWeight  [PixelIndexBase / WAVE_SIZE] += EvaluatedW;
        }
    }
    // Write back
    for(int PixelIndexBase = 0; PixelIndexBase < SSRC_TILE_SIZE * SSRC_TILE_SIZE; PixelIndexBase += WAVE_SIZE) {
        int PixelIndex = PixelIndexBase + LocalID;
        int PixelX = PixelIndex % SSRC_TILE_SIZE;
        int PixelY = PixelIndex / SSRC_TILE_SIZE;
        // We assume WAVE_SIZE is a multiple of SSRC_TILE_SIZE, and SSRC_TILE_SIZE^2 is a multiple of WAVE_SIZE
        {
            int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
            float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
            if(Depth < 1.f) {
                float  SumWeight   = ThreadSumWeight  [PixelIndexBase / WAVE_SIZE];
                float3 SumRadiance = ThreadSumRadiance[PixelIndexBase / WAVE_SIZE];
                float3 Emission    = ThreadMaterialEmissive[PixelIndexBase / WAVE_SIZE].emissive;
                g_RWGlobalIlluminationOutput[TexCoords] = 
                    float4(SumRadiance / SumWeight + Emission, 1.0f);
            } else {
                g_RWGlobalIlluminationOutput[TexCoords] = float4(0.f, 0.f, 0.f, 1.0f);
            }
        }
    }
}

[numthreads(8, 8, 1)]
void DebugSSRC_VisualizeCoverage (uint2 DispatchID : SV_DispatchThreadID) {
    if(any(DispatchID >= g_OutputDimensions)) {
        return;
    }
    float Depth = g_DepthTexture.Load(int3(DispatchID, 0)).x;
    if(Depth < 1.f) {
        g_RWDebugOutput[DispatchID] = g_RWRayRadianceDifferenceWSumTexture[DispatchID].w;
    } else {
        g_RWDebugOutput[DispatchID] = 0.f;
    }
}

[numthreads(SSRC_TILE_SIZE, SSRC_TILE_SIZE, 1)]
void DebugSSRC_VisualizeTileOccupancy (uint2 DispatchID : SV_DispatchThreadID, uint2 GroupID : SV_GroupID, uint2 LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * g_TileDimensions.x;
    [branch]
    if(g_DebugVisualizeMode == 0) {
        // Write the color heatmap
        int TileBasisCount = g_RWTileBasisCountBuffer[TileID];
        float h = float(TileBasisCount) / float(SSRC_MAX_BASIS_PER_TILE);
        float3 Color = ColorHeatMap(h);
        // Blinking effect for the overflowed tiles
        if(TileBasisCount >= 64) {
            Color = g_FrameIndex%10 < 5 ? 1.f.xxx : 0.f.xxx;
        }
        g_RWDebugOutput[DispatchID] = float4(Color, 1.f);
    } else if(g_DebugVisualizeMode == 1) {
        int TileBasisCount = g_RWTileBasisCountBuffer[TileID];
        int LocalRank = LocalID.x + LocalID.y * SSRC_TILE_SIZE;
        if(LocalRank < TileBasisCount) {
            int BasisIndex = g_RWTileBasisIndexBuffer[g_RWTileBaseSlotOffsetBuffer[TileID] + LocalRank];
            float3 BasisWorldPosition;
            FetchBasisLocation(BasisIndex, BasisWorldPosition);
            g_RWDebugOutput[DispatchID] = 1.f.xxxx;
        } else {
            g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 1.f);
        }
    } else if(g_DebugVisualizeMode == 2) {
                int TileBasisCount = g_RWTileBasisCountBuffer[TileID];
        int LocalRank = LocalID.x + LocalID.y * SSRC_TILE_SIZE;
        if(LocalRank < TileBasisCount) {
            int BasisIndex = g_RWTileBasisIndexBuffer[g_RWTileBaseSlotOffsetBuffer[TileID] + LocalRank];
            float3 BasisWorldPosition;
            FetchBasisLocation(BasisIndex, BasisWorldPosition);
            g_RWDebugOutput[DispatchID] = float4(BasisWorldPosition, 1.f);
        } else {
            g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 1.f);
        }
    }
}

[numthreads(8, 8, 1)]
void DebugSSRC_AccumulateAndShowDifference (uint2 DispatchID : SV_DispatchThreadID) {
    if(any(DispatchID >= g_OutputDimensions)) {
        return;
    }
    float Depth = g_DepthTexture.Load(int3(DispatchID, 0)).x;
    if(Depth < 1.f) {
        float3 Difference = g_RWRayRadianceDifferenceWSumTexture[DispatchID].xyz;
        float4 PrevDifferenceW = g_RWDifferenceAccumulationTexture[DispatchID];
        if(PrevDifferenceW.w > 127.f) {
            PrevDifferenceW.xyz *= 127.f / PrevDifferenceW.w;
            PrevDifferenceW.w = 127.f;
        }
        float3 Current = PrevDifferenceW.xyz + Difference;
        float  Weight  = PrevDifferenceW.w + 1.f;
        g_RWDifferenceAccumulationTexture[DispatchID] = float4(Current, Weight);
        float Diff = dot(Current / Weight, 1.f.xxx);
        g_RWDebugOutput[DispatchID] = float4(max(Diff, 0.f), abs(Diff) * 0.5f, -min(Diff, 0.f), 1.0f);
    } else {
        g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
    }
}

// ***********************************************
// *                 Misc                        *
// ***********************************************

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_Reset (uint DispatchID : SV_DispatchThreadID) {
    if(DispatchID == 0) {
        g_RWFreeBasisIndicesCountBuffer[0] = g_MaxBasisCount;
    }
    if(DispatchID < g_MaxBasisCount) {
        g_RWFreeBasisIndicesBuffer[DispatchID] = DispatchID;
        g_RWBasisFlagsBuffer[DispatchID] = g_FrameIndex - BASIS_RETIRE_FRAME_COUNT;
    }
}

[numthreads(1, 1, 1)]
void DebugSSRC_GenerateDrawIndexed (uint DispatchID : SV_DispatchThreadID) {
    DrawIndexedCommand draw_command;
    draw_command.index_count_per_instance = 3;
    draw_command.instance_count  = g_RWActiveBasisCountBuffer[0];
    draw_command.index_offset    = 0;
    draw_command.vertex_offset   = 0;
    draw_command.instance_offset = 0;
    g_RWDrawIndexedCommandBuffer[0] = draw_command;
}

// New line required for termination.
