#ifndef USE_INLINE_RT
#define USE_INLINE_RT 1
#endif

#ifndef WAVE_SIZE
// NVIDIA's default warp size
#define WAVE_SIZE 32
#endif

#define MIN_COLOR 0.000001f

// Shared structs among CPU and GPU
#include "../../gpu_shared.h"

// Parameters & Globals & Helper functions
#include "migi_inc.hlsl"

// Library for MIGI
#include "migi_lib.hlsl"
#include "migi_probes.hlsl"
#include "migi_worldcache.hlsl"

// World space ReSTIR library
#include "world_space_restir.hlsl"

#define MAX_HIT_DISTANCE 1e9f

struct MIGI_CacheUpdatePayload
{
    float3 sky_sample;
    float hit_dist;
};

struct PopulateCellsPayload
{
    uint      query_index;
    float3    world;
    float3    normal;
    float3    lighting;
    Reservoir reservoir;
};

struct TraceReflectionsPayload
{
    int2   full_pos;
    float3 radiance;
    float2 s;
    float  hit_distance;
};


// A naive kernel for generating dispatch commands
[numthreads(1, 1, 1)]
void GenerateDispatch()
{
    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = (g_CountBuffer[0] + g_GroupSize - 1) / g_GroupSize;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

[numthreads(1, 1, 1)]
void GenerateDispatchRays()
{
    DispatchRaysCommand dispatch_rays_command;
    dispatch_rays_command.ray_generation_shader_record = g_RTConstants.ray_generation_shader_record;
    dispatch_rays_command.miss_shader_table = g_RTConstants.miss_shader_table;
    dispatch_rays_command.hit_group_table = g_RTConstants.hit_group_table;
    dispatch_rays_command.callable_shader_table = g_RTConstants.callable_shader_table;
    dispatch_rays_command.width = g_CountBuffer[0];
    dispatch_rays_command.height = 1;
    dispatch_rays_command.depth = 1;
    dispatch_rays_command.padding[0] = 0;
    dispatch_rays_command.padding[1] = 0;
    dispatch_rays_command.padding[2] = 0;
    g_RWDispatchRaysCommandBuffer[0] = dispatch_rays_command;
}

[numthreads(WAVE_SIZE, 1, 1)]
void WorldCache_RecycleProbes (uint DispatchID : SV_DispatchIndex) {
    if(DispatchID >= WorldCache_GetActiveProbeCount()) return ;
    int ProbeIndex = g_RWWorldCacheActiveProbeIndexBuffer[DispatchID];
    WorldCacheProbeHeader Header = WorldCache_GetProbeHeader(ProbeIndex);
    Header.Score -= WorldCache.ProbeScoreDecay;
    bool bShouldRecycleProbe = Header.Score <= 0;
    int4 WorldCacheProbeGridCoords = WorldCache_GetProbeGridCoords(Header.Position);
    WorldCacheProbeGrids bShouldRecycleProbe = true;

    if(bShouldRecycleProbe) {
        WorldCache_RecycleProbe(ProbeIndex);
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void WorldCache_SpawnProbes () {

}

// Clear the counters at the begginging of the frame
[numthreads(1, 1, 1)]
void SSRC_ClearCounters() {
    g_RWAdaptiveProbeCountBuffer[0]      = 0;
    g_RWAllocatedProbeSGCountBuffer[0] = 0;
}

float3 GetProbeOffsetAdaptiveNormal (int2 ScreenCoords, float3 GeometryNormal, float3 ViewDirection) {
    float3 AdaptiveNormal = GeometryNormal;//normalize(ViewDirection + GeometryNormal);
#if true
    // Fine-tune the normal to bent normal when close to occluded regions
    float4 BentNormalOcc  = g_BentNormalAndOcclusionTexture.Load(int3(ScreenCoords, 0));
    float  Occlusion      = BentNormalOcc.w;
    float3 BentNormal     = BentNormalOcc.xyz * 2 - 1;
    AdaptiveNormal = normalize(lerp(BentNormal, AdaptiveNormal, saturate(1.5 * Occlusion * Occlusion)));
#endif
    return AdaptiveNormal;
}

float3 RecoverWorldPosition (float2 UV, float LinearDepth) {
    float2 NDC2 = UV2NDC2(UV);
    return LinearDepth * (NDC2.x * MI.CameraRight + NDC2.y * MI.CameraUp + MI.CameraDirection) + MI.CameraPosition;
}

float3 RecoverScreenProbePosition (int2 TileCoords, float LinearDepth, bool bPrevious) {
    // We are using the camera coordinate system to recover probe position, which is placed with G-Buffer samples
    // We need to take care of the jittering as the camera coordinate system is not affected by TAA (but the G-Buffer is). 
    // TODO The way using TAA jitter here may be incorrect (subtraction / addition ?)
    float2 UV = GetUniformScreenProbeScreenUV(TileCoords, bPrevious) + (bPrevious ? MI.PreviousTAAJitterUV : MI.TAAJitterUV);
    float2 NDC2 = UV2NDC2(UV);
    if(!bPrevious) {
        return LinearDepth * (NDC2.x * MI.CameraRight + NDC2.y * MI.CameraUp + MI.CameraDirection) + MI.CameraPosition;
    } else {
        return LinearDepth * (NDC2.x * MI.PreviousCameraRight + NDC2.y * MI.PreviousCameraUp + MI.PreviousCameraDirection) + MI.PreviousCameraPosition;
    }
}

// Allocate fixed uniform probes for current frame
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateUniformProbes (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID > MI.UniformScreenProbeCount) {
        return;
    }
    int2 ProbeIndex = int2(DispatchID % MI.TileDimensions.x, DispatchID / MI.TileDimensions.x);
    ProbeHeader Header;
    Header.ScreenCoords = GetUniformScreenProbeScreenCoords(ProbeIndex);
    float Depth             = g_DepthTexture.Load(int3(Header.ScreenCoords, 0)).x;
    bool  bValid            = Depth < 1.f;
    if(bValid) Header.Class  = ComputeProbeRankFromSplattedError(Header.ScreenCoords);
    int BasisCount      = bValid ? GetProbeBasisCountFromClass(Header.Class) : 0;
    int BasisOffset     = WavePrefixSum(BasisCount);
    int BasisCountSum   = WaveActiveSum(BasisCount);
    int BasisGroupOffset;
    if(WaveIsFirstLane()) {
        InterlockedAdd(g_RWAllocatedProbeSGCountBuffer[0], BasisCountSum, BasisGroupOffset);
    }
    BasisGroupOffset = WaveReadLaneFirst(BasisGroupOffset);
    Header.BasisOffset   = BasisGroupOffset + BasisOffset;
    // Clip over the maximum basis count
    if(Header.BasisOffset + BasisCount > MI.MaxBasisCount) {
        Header.Class = 0;
    }

    // Negative depths stands for invalid probes
    Header.LinearDepth   = (bValid ? 1 : -1) * GetLinearDepth(Depth);
    // High resolution recovery for accurate probe placement (otherwise may cause artifacts because of inaccurate occlusions)
    float3 WorldPosition  = RecoverWorldPositionHiRes(Header.ScreenCoords);
    // Offset the probe along adaptive "normal".
    float3 GeometryNormal = normalize(g_GeometryNormalTexture.Load(int3(Header.ScreenCoords, 0)).xyz * 2.f - 1.f);
    float3 ViewDirection  = normalize(MI.CameraPosition - WorldPosition);
    float3 AdaptiveNormal = GetProbeOffsetAdaptiveNormal(Header.ScreenCoords, GeometryNormal, ViewDirection);
    float3 ProbePositionOffset = AdaptiveNormal * Header.LinearDepth * SSRC_PROBE_NORMAL_OFFSET;
    Header.Position      = WorldPosition + ProbePositionOffset;
    Header.Normal        = GeometryNormal;
    WriteScreenProbeHeader(ProbeIndex, Header);

    // Also, clear the tile adaptive probe count for later adaptive allocation
    g_RWTileAdaptiveProbeCountTexture[ProbeIndex] = 0;
}

void CalculateSSRCSampleWeightsForUniformScreenProbes (
    float2 ScreenPosition,
    float3 Position,
    float  LinearDepth,
    float3 Normal,
    bool bScreenSpaceWeight,
    out int2 TileCoordsX00,
    out float4 Weights,
    bool bPrevious = false
) {
    int2 ScreenCoordsProbeGrid = clamp(ScreenPosition - 0.5f - GetTileJitter(bPrevious), 0, MI.ScreenDimensions - SSRC_TILE_SIZE - 1);
    TileCoordsX00         = min(ScreenCoordsProbeGrid / SSRC_TILE_SIZE, MI.TileDimensions - 2);
    // Pad the bilinear filtering weights
#ifdef DEBUG_FIX_PROBES
    int BilinearExpand = 0;
#else
    // Values larger than 1 causes SG to leak into neighboring probes
    int BilinearExpand = 0;
#endif
    float2 Bilinear    = 
        (ScreenCoordsProbeGrid + 0.5f - TileCoordsX00 * SSRC_TILE_SIZE + BilinearExpand) 
        / (float)(SSRC_TILE_SIZE + 2 * BilinearExpand);
    float4 CornerLinearDepths;
    CornerLinearDepths.x = GetScreenProbeLinearDepth(TileCoordsX00 + int2(0, 0), bPrevious);
    CornerLinearDepths.y = GetScreenProbeLinearDepth(TileCoordsX00 + int2(1, 0), bPrevious);
    CornerLinearDepths.z = GetScreenProbeLinearDepth(TileCoordsX00 + int2(0, 1), bPrevious);
    CornerLinearDepths.w = GetScreenProbeLinearDepth(TileCoordsX00 + int2(1, 1), bPrevious);
    if(bScreenSpaceWeight) Weights = float4(
        (1.f - Bilinear.x) * (1.f - Bilinear.y),
        Bilinear.x * (1.f - Bilinear.y),
        (1.f - Bilinear.x) * Bilinear.y,
        Bilinear.x * Bilinear.y
    );
    else Weights = 1.f.xxxx;
    float4 DepthWeights;
    float4 PixelPlane  = float4(Normal, dot(Position, Normal));
    float3 PositionX00 = RecoverScreenProbePosition(TileCoordsX00 + int2(0, 0), CornerLinearDepths.x, bPrevious);
    float3 PositionX10 = RecoverScreenProbePosition(TileCoordsX00 + int2(1, 0), CornerLinearDepths.y, bPrevious);
    float3 PositionX01 = RecoverScreenProbePosition(TileCoordsX00 + int2(0, 1), CornerLinearDepths.z, bPrevious);
    float3 PositionX11 = RecoverScreenProbePosition(TileCoordsX00 + int2(1, 1), CornerLinearDepths.w, bPrevious);
    float4 PlaneDistances;
    PlaneDistances.x = abs(dot(PixelPlane, float4(PositionX00, -1.f)));
    PlaneDistances.y = abs(dot(PixelPlane, float4(PositionX10, -1.f)));
    PlaneDistances.z = abs(dot(PixelPlane, float4(PositionX01, -1.f)));
    PlaneDistances.w = abs(dot(PixelPlane, float4(PositionX11, -1.f)));
    float4 RelativeDepthDifference = PlaneDistances / LinearDepth;
    // Negative depths stands for invalid probes
    DepthWeights = select(
        CornerLinearDepths > 0, 
        exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference)),
        0.0
    );
    Weights *= DepthWeights;
}

void CalculateSSRCSampleWeights (
    float2 ScreenPosition,
    float3 Position,
    float  LinearDepth,
    float3 Normal,
    bool   bScreenSpaceWeight,
    out SSRC_SampleData Sample,
    bool bPrevious = false
) {
    int2 TileCoordsX00;
    CalculateSSRCSampleWeightsForUniformScreenProbes(
        ScreenPosition,
        Position,
        LinearDepth,
        Normal,
        bScreenSpaceWeight,
        TileCoordsX00,
        Sample.Weights,
        bPrevious
    );
    Sample.Index[0] = TileCoordsX00 + int2(0, 0);
    Sample.Index[1] = TileCoordsX00 + int2(1, 0);
    Sample.Index[2] = TileCoordsX00 + int2(0, 1);
    Sample.Index[3] = TileCoordsX00 + int2(1, 1);
    
    // Weight the adaptive probes and search within the nearest tiles
    {
        float Epsilon = .01f;
		float4 PixelPlane = float4(Normal, dot(Position, Normal));
        for (uint CornerIndex = 0; CornerIndex < 4; CornerIndex++)
		{
			if (Sample.Weights[CornerIndex] <= Epsilon)
			{
				int2 TileCoords = TileCoordsX00 + uint2(CornerIndex % 2, CornerIndex / 2);
				int NumAdaptiveProbes = 
                    bPrevious ? g_RWPreviousTileAdaptiveProbeCountTexture[TileCoords] 
                    : g_RWTileAdaptiveProbeCountTexture[TileCoords];
                [unroll(1 << (SSRC_MAX_ADAPTIVE_PROBE_LAYERS * 2))]
				for (uint AdaptiveProbeListIndex = 0; AdaptiveProbeListIndex < NumAdaptiveProbes; AdaptiveProbeListIndex++)
				{
                    // TODO reconstruct probe data from G-Buffer to reduce VRAM bandwidth when shading
					int  AdaptiveProbeIndex1 = GetAdaptiveProbeIndex(TileCoords, AdaptiveProbeListIndex, bPrevious);
					int  ScreenProbeIndex1   = AdaptiveProbeIndex1 + MI.UniformScreenProbeCount;
                    int2 ScreenProbeIndex    = int2(ScreenProbeIndex1 % MI.TileDimensions.x, ScreenProbeIndex1 / MI.TileDimensions.x);

                    ProbeHeader Header         = GetScreenProbeHeader(ScreenProbeIndex, bPrevious);
					float2 ProbeScreenPosition = Header.ScreenCoords + 0.5f;
					float ProbeLinearDepth     = Header.LinearDepth;
					
					float NewDepthWeight = 0;

                    float3 ProbePosition = Header.Position;
                    float  PlaneDistance = abs(dot(float4(ProbePosition, -1), PixelPlane));
                    float RelativeDepthDifference = PlaneDistance / ProbeLinearDepth;
                    NewDepthWeight = exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference));

					float2 DistanceToScreenProbe = abs(ProbeScreenPosition - ScreenPosition);
					float NewCornerWeight = 1.0f - saturate(min(DistanceToScreenProbe.x, DistanceToScreenProbe.y) / (float)(SSRC_TILE_SIZE));
					float NewInterpolationWeight = NewDepthWeight * (bScreenSpaceWeight ? NewCornerWeight : 1.f);

					if (NewInterpolationWeight > Sample.Weights[CornerIndex])
					{
						Sample.Weights[CornerIndex] = NewInterpolationWeight;
						Sample.Index[CornerIndex] = ScreenProbeIndex;
					}
				}
			}
		}
    }
}


groupshared int  LocalNumProbesToAllocate;
groupshared int  LocalAdaptiveProbeOffset;
groupshared int2 LocalProbeScreenCoordsToAllocate[WAVE_SIZE];
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateAdaptiveProbes (int DispatchID : SV_DispatchThreadID, int LocalID : SV_GroupThreadID) {
    if(MI.NoAdaptiveProbes) return ;
// This macro is passed in by compiler arguments
#ifndef SSRC_ADAPTIVE_PROBE_LAYER
#define SSRC_ADAPTIVE_PROBE_LAYER 0
#endif
    const int AdaptiveProbeDownsampleFactor = SSRC_TILE_SIZE / (2 << SSRC_ADAPTIVE_PROBE_LAYER);
    int2 DownsampledTileDimensions = MI.ScreenDimensions / AdaptiveProbeDownsampleFactor;
    int2 AdaptiveTileCoords = int2(
        DispatchID % DownsampledTileDimensions.x,
        DispatchID / DownsampledTileDimensions.x
    );
    if(WaveIsFirstLane()) {
        LocalNumProbesToAllocate = 0;
    }
    GroupMemoryBarrierWithGroupSync();

    {
        // Omit the adaptive probe that overlaps with the previous layer
        if(any((AdaptiveTileCoords&1) != 0)) {
            // Compute the screen coords for current adaptive probe
            int2 AdaptiveProbeScreenCoords = AdaptiveTileCoords * AdaptiveProbeDownsampleFactor + GetTileJitter();
            if(all(AdaptiveProbeScreenCoords < MI.ScreenDimensions)) {
                float Depth = g_DepthTexture.Load(int3(AdaptiveProbeScreenCoords, 0)).x;
                bool  bValid = Depth < 1.f;
                if(bValid) {
                    float3 WorldPosition  = RecoverWorldPositionHiRes(AdaptiveProbeScreenCoords);
                    float  LinearDepth    = GetLinearDepth(Depth);
                    float3 GeometryNormal = normalize(g_GeometryNormalTexture.Load(int3(AdaptiveProbeScreenCoords, 0)).xyz * 2.f - 1.f);
                    SSRC_SampleData Sample;

                    CalculateSSRCSampleWeights(
                        AdaptiveProbeScreenCoords + 0.5f,
                        WorldPosition,
                        LinearDepth,
                        GeometryNormal,
                        true,
                        Sample
                    );

                    float Epsilon = .01f;
                    Sample.Weights /= max(dot(Sample.Weights, 1), Epsilon);

                    float LightingIsValid = (dot(Sample.Weights, 1) < 1.0f - Epsilon) ? 0.0f : 1.0f;

                    if (!LightingIsValid)
                    {
                        int ListIndex;
                        InterlockedAdd(LocalNumProbesToAllocate, 1, ListIndex);
                        LocalProbeScreenCoordsToAllocate[ListIndex] = AdaptiveProbeScreenCoords;
                    }
                }
            }
        }
    }
    
    GroupMemoryBarrierWithGroupSync();

    // Allocate probes
    if(WaveIsFirstLane()) {
        InterlockedAdd(g_RWAdaptiveProbeCountBuffer[0], LocalNumProbesToAllocate, LocalAdaptiveProbeOffset);
    }

    GroupMemoryBarrierWithGroupSync();
    
    int NumProbeToAllocateClipped = min(max(MI.MaxAdaptiveProbeCount - LocalAdaptiveProbeOffset, 0), LocalNumProbesToAllocate);

    int AdaptiveProbeIndex = LocalAdaptiveProbeOffset + LocalID;

    if(LocalID < NumProbeToAllocateClipped) {
        // Allocate the index slot and record the index of the adaptive probe
        int TileAdaptiveProbeRank;
        // Set the tile coords to the tile that the LocalID th probe belongs to
        int2 TileCoords = (LocalProbeScreenCoordsToAllocate[LocalID] - GetTileJitter()) / SSRC_TILE_SIZE;
        // Make a copy of the tile probe count texture to RW at the same time
        InterlockedAdd(g_RWNextTileAdaptiveProbeCountTexture[TileCoords], 1, TileAdaptiveProbeRank);
        g_RWTileAdaptiveProbeIndexTexture[GetAdaptiveProbeIndexCoords(TileCoords, TileAdaptiveProbeRank)] = AdaptiveProbeIndex;
        // The probe here is guaranteed to be valid upon allocation.
        int ScreenProbeIndex1   = AdaptiveProbeIndex + MI.UniformScreenProbeCount;
        ProbeHeader Header;
        Header.ScreenCoords     = LocalProbeScreenCoordsToAllocate[LocalID];
        Header.Class        = ComputeProbeRankFromSplattedError(Header.ScreenCoords);
        int BasisCount      = GetProbeBasisCountFromClass(Header.Class);
        int BasisOffset     = WavePrefixSum(BasisCount);
        int BasisCountSum   = WaveActiveSum(BasisCount);
        int BasisGroupOffset;
        if(WaveIsFirstLane()) {
            // Allocate basis for the newly allocated tile probes
            InterlockedAdd(g_RWAllocatedProbeSGCountBuffer[0], BasisCountSum, BasisGroupOffset);
        }
        BasisGroupOffset = WaveReadLaneFirst(BasisGroupOffset);
        Header.BasisOffset   = BasisGroupOffset + BasisOffset;
        // Clip over the maximum basis count
        if(Header.BasisOffset + BasisCount > MI.MaxBasisCount) {
            Header.Class = 0;
        }
        float3 GeometryNormal = normalize(g_GeometryNormalTexture.Load(int3(Header.ScreenCoords, 0)).xyz * 2.f - 1.f);
        float Depth          = g_DepthTexture.Load(int3(Header.ScreenCoords, 0)).x;
        Header.LinearDepth   = GetLinearDepth(Depth);
        float2 UV = (Header.ScreenCoords + 0.5f) * MI.ScreenDimensionsInv;
        // High resolution recovery for accurate probe placement (otherwise may cause artifacts because of inaccurate occlusions)
        float3 WorldPosition = RecoverWorldPositionHiRes(Header.ScreenCoords);
        float3 ViewDirection = normalize(MI.CameraPosition - WorldPosition);
        float3 AdaptiveNormal = GetProbeOffsetAdaptiveNormal(Header.ScreenCoords, GeometryNormal, ViewDirection);
        Header.Position      = WorldPosition + AdaptiveNormal * Header.LinearDepth * SSRC_PROBE_NORMAL_OFFSET;
        
        Header.Normal        = GeometryNormal;
        int2 ScreenProbeIndex = int2(ScreenProbeIndex1 % MI.TileDimensions.x, ScreenProbeIndex1 / MI.TileDimensions.x);
        WriteScreenProbeHeader(ScreenProbeIndex, Header);
    }
}

// Write dispatch parameters for SSRC computations
[numthreads(1, 1, 1)]
void SSRC_WriteProbeDispatchParameters () {
    // Clip the number of allocated adaptive probes
    g_RWAdaptiveProbeCountBuffer[0] = min(g_RWAdaptiveProbeCountBuffer[0], MI.MaxAdaptiveProbeCount);

    DispatchCommand Command = (DispatchCommand)0;
    Command.num_groups_x = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0];
    Command.num_groups_y = 1;
    Command.num_groups_z = 1;
    g_RWDispatchCommandBuffer[0] = Command;

    Command.num_groups_x = (MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0] + WAVE_SIZE - 1) / WAVE_SIZE;
    Command.num_groups_y = 1;
    Command.num_groups_z = 1;
    g_RWPerLaneDispatchCommandBuffer[0] = Command;

    // Also, set the reduce count for scan sum update rays
    // Pad 1 for the last element
    g_RWReduceCountBuffer[0] = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0] + 1;

}

void ResetProbe (int GroupID, int LocalID, int2 ProbeIndex, int BasisCount, int BasisOffset, float3 ProbeNormal) {
    for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
        int ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
        int2 ProbeTexelCoords = int2(ProbeTexelIndex % SSRC_PROBE_TEXTURE_SIZE, ProbeTexelIndex / SSRC_PROBE_TEXTURE_SIZE);
        WriteScreenProbeOctahedronRadianceDepth(ProbeIndex, ProbeTexelCoords, float4(0, 0, 0, MI.CameraFar));
    }
    if(LocalID < BasisCount) {
        SGData SG;
        SG.Color     = 0.001f.xxx;
        // TODO better initialization
        SG.Lambda    = InitSGLambda(BasisCount);

        float3 Direction = InitHemiDirections(LocalID, BasisCount);
        float3 Normal    = ProbeNormal;
        float3 Tangent, Bitangent;
        GetOrthoVectors(Normal, Tangent, Bitangent);
        float  Phi       = BlueNoise_Sample1D(int2(GroupID, LocalID), MI.FrameSeed, 2);
        SG.Direction = normalize(Direction.x * Tangent + Direction.y * Bitangent + Direction.z * Normal);

        SG.Depth     = MI.CameraFar;
        WriteBasisData(BasisOffset + LocalID, SG);
    }
    GroupMemoryBarrierWithGroupSync();
}

groupshared float  LocalSGSize4[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
groupshared SGData LocalSGData4[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
groupshared SGData LocalSGData4New[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
groupshared int    LocalSGMaxMatchIndex[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
groupshared int    LocalSGNewIndex[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
// Radiance + Weight (sample count)
groupshared int4   LocalProbeTexelsQuantilized[SSRC_PROBE_TEXTURE_SIZE * SSRC_PROBE_TEXTURE_SIZE];
groupshared int    LocalProbeTexelSampleWeightQuantilized[SSRC_PROBE_TEXTURE_SIZE * SSRC_PROBE_TEXTURE_SIZE];
// Initialize probe cache from the previous frame, one group per probe
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_ReprojectProbeHistory (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {
    int2 ProbeIndex = int2(GroupID % MI.TileDimensions.x, GroupID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    if(MI.ResetCache) {
        if(WaveIsFirstLane()) {
            // Clear probe history
            g_RWProbeHistoryTrustTexture[ProbeIndex] = 0;
        }
        ResetProbe(
            GroupID, LocalID, 
            ProbeIndex, GetProbeBasisCountFromClass(Header.Class),
            Header.BasisOffset, Header.Normal
        );
        return ;
    }
    float3 ProbeTangent, ProbeBitangent;
    GetOrthoVectors(Header.Normal, ProbeTangent, ProbeBitangent);
    float4 PrevHomogeneousW = mul(MI.PrevCameraProjView, float4(Header.Position, 1));
    // The probe is totally out of the screen on the last frame, so we should reset the probe
    if(PrevHomogeneousW.w <= 0) {
        if(WaveIsFirstLane()) {
            // Clear probe history
            g_RWProbeHistoryTrustTexture[ProbeIndex] = 0;
        }
        ResetProbe(
            GroupID, LocalID, 
            ProbeIndex, GetProbeBasisCountFromClass(Header.Class),
            Header.BasisOffset, Header.Normal
        );        
        return ;
    }
    float3 PrevHomogeneous = PrevHomogeneousW.xyz / PrevHomogeneousW.w;
    // TODO TAA should be in place of the noise effect, but it malfunctions
    // (consistent directional biased blur during reprojection).
    float2 NoiseOffset = (BlueNoise_Sample2D(ProbeIndex, MI.FrameSeed) * 2 - 1) * 0.5f;
    float2 PrevScreenPosition = MI.ScreenDimensions * NDC22UV(PrevHomogeneous.xy) + NoiseOffset;
    float2 PrevProbeHistoryDimensionsMin = GetTileJitter(true) + 0.5f;
    float2 PrevProbeHistoryDimensionsMax = MI.ScreenDimensions - SSRC_TILE_SIZE + GetTileJitter(true) + 0.5f;
    float2 PrevScreenPositionClamped = clamp(PrevScreenPosition, PrevProbeHistoryDimensionsMin, PrevProbeHistoryDimensionsMax);
    SSRC_SampleData Sample;
    // ~~~Exclude screen space weight when doing reprojection (which UE told me to do so...)~~~
    // That will introduce too many bias (colors flowing in a fixed direction in screen space)
    // TODO is it okay to use the clamped screen position? 
    CalculateSSRCSampleWeights(
        PrevScreenPositionClamped,
        Header.Position,
        Header.LinearDepth,
        Header.Normal,
        true, // false,
        Sample,
        true
    );
    float2 OutOfRangeDecay2 = max(
        PrevScreenPosition - PrevProbeHistoryDimensionsMax,
        PrevProbeHistoryDimensionsMin - PrevScreenPosition
    );
    OutOfRangeDecay2 = max(OutOfRangeDecay2, 0.f);
    float OutOfRangeDecay  = max(1.f - 2.f * length(OutOfRangeDecay2) / SSRC_TILE_SIZE, 0.f);
    // Stochastic noise for the history trust
    float Noise = BlueNoise_Sample1D(ProbeIndex, MI.FrameSeed, 3);
    // 1.5 ~ 3 probes
    // Noise should not be affecting the trust value... it'll make the cache unstable
    float HistoryTrust = min(dot(Sample.Weights, 1)/* * lerp(0.8f, 1.2f, Noise)*/, 1.f) * OutOfRangeDecay;
    if(WaveIsFirstLane()) {
        g_RWProbeHistoryTrustTexture[ProbeIndex] = HistoryTrust;
    }
    float Epsilon = .01f;
    Sample.Weights /= max(dot(Sample.Weights, 1), Epsilon);

    // Reproject Octahedron
    {
        float Q_Noise = BlueNoise_Sample1D(ProbeIndex, MI.FrameSeed, 4);

#if SSRC_PROBE_TEXTURE_SIZE * SSRC_PROBE_TEXTURE_SIZE % WAVE_SIZE != 0
#error "SSRC_PROBE_TEXTURE_SIZE * SSRC_PROBE_TEXTURE_SIZE must be a multiple of WAVE_SIZE"
#endif
        for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
            int ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
            LocalProbeTexelsQuantilized[ProbeTexelIndex] = 0;
            LocalProbeTexelSampleWeightQuantilized[ProbeTexelIndex] = 0;
        }
        GroupMemoryBarrierWithGroupSync();
        for(int CornerIndex = 0; CornerIndex < 4; CornerIndex++) {
            // A probe with a weight greater than 0 must be valid
            [branch]
            if(Sample.Weights[CornerIndex] > 0) {
                int2 SrcProbeIndex = Sample.Index[CornerIndex];
                ProbeHeader SrcProbeHeader = GetScreenProbeHeader(SrcProbeIndex, true);
                for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
                    int SrcTexelIndex = BaseProbeTexelIndex + LocalID;
                    int2 ProbeTexelCoords = int2(SrcTexelIndex % SSRC_PROBE_TEXTURE_SIZE, SrcTexelIndex / SSRC_PROBE_TEXTURE_SIZE); 
                    float4 RadianceDepth = GetScreenProbeOctahedronRadianceDepth(SrcProbeIndex, ProbeTexelCoords, true);
                    float3 RayRadiance = RadianceDepth.xyz;
                    float RayDepth = RadianceDepth.w;
                    float3 Tangent, Bitangent;
                    GetOrthoVectors(SrcProbeHeader.Normal, Tangent, Bitangent);
                    float3 RayDirection = HemiOctahedron01ToUnitVector((ProbeTexelCoords + 0.5f) / SSRC_PROBE_TEXTURE_SIZE);
                    RayDirection = RayDirection.x * Tangent + RayDirection.y * Bitangent + RayDirection.z * SrcProbeHeader.Normal;
                    float3 RayHitPosition = SrcProbeHeader.Position + RayDirection * RayDepth;
                    float3 ReprojectedRayDirection = normalize(RayHitPosition - Header.Position);
                    float  ReprojectedRayDepth     = length(RayHitPosition - Header.Position);
                    if(dot(ReprojectedRayDirection, Header.Normal) > 0) {
                        // Successful reprojection
                        float3 LocalReprojectedRayDirection = float3(
                            dot(ReprojectedRayDirection, ProbeTangent),
                            dot(ReprojectedRayDirection, ProbeBitangent),
                            dot(ReprojectedRayDirection, Header.Normal)
                        );
                        float2 ReprojectedProbeTexelUV = UnitVectorToHemiOctahedron01(LocalReprojectedRayDirection);
                        int2 ReprojectedProbeTexelCoords = clamp(int2(
                            ReprojectedProbeTexelUV * SSRC_PROBE_TEXTURE_SIZE
                        ), 0, SSRC_PROBE_TEXTURE_SIZE - 1);
                        int  ReprojectedProbeTexelIndex = ReprojectedProbeTexelCoords.y * SSRC_PROBE_TEXTURE_SIZE + ReprojectedProbeTexelCoords.x;
                        float  Weight = Sample.Weights[CornerIndex];
                        float3 WeightedRayRadiance = Weight * RayRadiance;
                        InterlockedAdd(LocalProbeTexelsQuantilized[ReprojectedProbeTexelIndex].x, QuantilizeRadiance(WeightedRayRadiance.x, Q_Noise));
                        InterlockedAdd(LocalProbeTexelsQuantilized[ReprojectedProbeTexelIndex].y, QuantilizeRadiance(WeightedRayRadiance.y, Q_Noise));
                        InterlockedAdd(LocalProbeTexelsQuantilized[ReprojectedProbeTexelIndex].z, QuantilizeRadiance(WeightedRayRadiance.z, Q_Noise));
                        InterlockedAdd(LocalProbeTexelsQuantilized[ReprojectedProbeTexelIndex].w, QuantilizeRadiance(ReprojectedRayDepth * Weight, Q_Noise));
                        InterlockedAdd(LocalProbeTexelSampleWeightQuantilized[ReprojectedProbeTexelIndex], QuantilizeWeight(Weight, Q_Noise));
                    }
                }
            }
        }
        GroupMemoryBarrierWithGroupSync();

        // GI10: Calculate the radiance backup value to be used for unvisited cells
        // Simply average the radiance values among probe samples.
        float4 BackupRadianceSum = 0;
        for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
            int ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
            float Weight = RecoverWeight(LocalProbeTexelSampleWeightQuantilized[ProbeTexelIndex]);
            float V = Weight > 0 ? 1.0f : 0.0f;
            float3 Radiance = RecoverRadiance(LocalProbeTexelsQuantilized[ProbeTexelIndex].xyz) / max(Weight, 1e-4f);
            BackupRadianceSum += float4(Radiance, V);
        }
        BackupRadianceSum = WaveActiveSum(BackupRadianceSum);

        float4 BackupRadianceDepth = 0;
        {
            float3 Radiance      = BackupRadianceSum.xyz / max(BackupRadianceSum.w, 1.0f);
            float  NumEmptyCells = (SSRC_PROBE_TEXTURE_SIZE * SSRC_PROBE_TEXTURE_SIZE - BackupRadianceSum.w);
            // Fill holes if there're only a tiny amount of empty cells
            // Otherwise decay the radiance they received
            BackupRadianceDepth = float4(Radiance / max(NumEmptyCells, 1.0f), MI.CameraFar);
        }
        
        // Write the reprojected probe texel
        for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
            int ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
            int2 ProbeTexelCoords = int2(ProbeTexelIndex % SSRC_PROBE_TEXTURE_SIZE, ProbeTexelIndex / SSRC_PROBE_TEXTURE_SIZE);
            float Weight = RecoverWeight(LocalProbeTexelSampleWeightQuantilized[ProbeTexelIndex]);
            float4 RadianceDepth = RecoverRadiance(LocalProbeTexelsQuantilized[ProbeTexelIndex]);
            if(Weight < 0.01f) RadianceDepth = BackupRadianceDepth;
            else RadianceDepth = RadianceDepth / Weight;
            WriteScreenProbeOctahedronRadianceDepth(ProbeIndex, ProbeTexelCoords, RadianceDepth);
        }
    }

    // Reproject SG

    int BasisOffsets[4];
    BasisOffsets[0] = GetScreenProbeBasisOffset(Sample.Index[0], true);
    BasisOffsets[1] = GetScreenProbeBasisOffset(Sample.Index[1], true);
    BasisOffsets[2] = GetScreenProbeBasisOffset(Sample.Index[2], true);
    BasisOffsets[3] = GetScreenProbeBasisOffset(Sample.Index[3], true);
    
    int BasisCount[4];
    BasisCount[0] = Sample.Weights[0] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[0], true).Class) : 0;
    BasisCount[1] = Sample.Weights[1] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[1], true).Class) : 0;
    BasisCount[2] = Sample.Weights[2] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[2], true).Class) : 0;
    BasisCount[3] = Sample.Weights[3] > 0 ? GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[3], true).Class) : 0;
    int NumBasis0 = BasisCount[0] + BasisCount[1];
    int NumBasis1 = BasisCount[2] + BasisCount[3];
    int NumBasis  = NumBasis0 + NumBasis1;

#if SSRC_MAX_NUM_BASIS_PER_PROBE > 8
#error "SSRC_MAX_NUM_BASIS_PER_PROBE must be less than or equal to 8"
#endif
    // Fetch the basis data from the previous frame
    {
        int BasisRank = LocalID;
        if(BasisRank < NumBasis) {
            int BasisOffset;
            float Weight;
            if(BasisRank < NumBasis0) {
                BasisOffset = BasisOffsets[BasisRank < BasisCount[0] ? 0 : 1] 
                    + BasisRank - (BasisRank < BasisCount[0] ? 0 : BasisCount[0]);
                Weight      = Sample.Weights[BasisRank < BasisCount[0] ? 0 : 1];
            } else {
                int Mid = NumBasis0 + BasisCount[2];
                BasisOffset = BasisOffsets[BasisRank < Mid ? 2 : 3] 
                    + BasisRank - (BasisRank < Mid ? NumBasis0 : Mid);
                Weight      = Sample.Weights[BasisRank < Mid ? 2 : 3];
            }
            SGData SG = FetchBasisData(BasisOffset, true);
            // FIXME directional reprojection is missing

            // Manually reduce the SG weight if it is mostly zero on the new probe's hemisphere
            float NormalProjection = dot(SG.Direction, Header.Normal);
            // TODO correct the SG's direction with heuristic
            float3 HemiDirection = SG.Direction - min(NormalProjection, 0.f) * Header.Normal;
            float HemiDirectionLength = length(HemiDirection);
            if(HemiDirectionLength < 1e-3f) {
                float3 Tangent, Bitangent;
                GetOrthoVectors(Header.Normal, Tangent, Bitangent);
                HemiDirection = Tangent;
                HemiDirectionLength = 1.f;
            } else {
                HemiDirection /= HemiDirectionLength;
            }
            float WeightDecay = saturate(lerp(0.f, 1.f, EvaluateSGRaw(SG, HemiDirection)));
            Weight *= WeightDecay;

            // Scale the color by the weight
            // Clamp to epsilon to always rank the closest SGs first if all SGs have zero weight
            LocalSGSize4[BasisRank] = Weight * (1e-8f + SGIntegrate(SG.Lambda) * dot(SG.Color, 1.f.xxx));
            SG.Color = SG.Color * Weight;
            LocalSGData4[BasisRank] = SG;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    // Simple N^2 Sort
    {
        SGData ThreadSG;
        int    ThreadSGRank;
        int BasisRank = LocalID;
        if(BasisRank < NumBasis) {
            float Weight = LocalSGSize4[BasisRank];
            int SortedRank = 0;
            [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
            for(int i = 0; i < NumBasis; i++) {
                float Opponent = LocalSGSize4[i];
                if(Opponent > Weight || (Opponent == Weight && i < BasisRank)) {
                    SortedRank ++;
                }
            }
            ThreadSGRank = SortedRank;
            ThreadSG = LocalSGData4[BasisRank];
        }
        
        GroupMemoryBarrierWithGroupSync();

        if(BasisRank < NumBasis) {
            LocalSGData4[ThreadSGRank] = ThreadSG;
        }
    }
    GroupMemoryBarrierWithGroupSync();

    int CurrentProbeBasisCount = GetProbeBasisCountFromClass(Header.Class);
    // The number of merges required to reduce the number of SGs
    int MergeCount = max(NumBasis - CurrentProbeBasisCount, 0);
#ifdef  DEBUG_FIX_PROBES
#define MERGE_BASIS_FLAG 0
#else 
#define MERGE_BASIS_FLAG 1
#endif
    // Progressively merges the candidate SGs.
    if(MERGE_BASIS_FLAG && CurrentProbeBasisCount > 0) {
        const int REPEAT = (SSRC_MAX_NUM_BASIS_PER_PROBE * 4 + WAVE_SIZE-1) / WAVE_SIZE;   
        [unroll(4)]
        for(int Iteration = 0; MergeCount > 0 && Iteration < 4; Iteration ++) {
            // Compute the distances between each pair of SGs
            {
                int BasisRank = LocalID;
                if(BasisRank < NumBasis) {
                    int MaxIndex  = -1;
                    float MaxSimilarity = -1.f;
                    SGData CurrentSG = LocalSGData4[BasisRank];
                    [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
                    for (int i = 0; i<NumBasis; i++) {
                        // TODO better similarity computation
                        float X = EvaluateSGRaw(LocalSGData4[i], CurrentSG.Direction);
                        float Y = EvaluateSGRaw(CurrentSG, LocalSGData4[i].Direction);
                        float Similarity = X * Y;
                        if(i != BasisRank && Similarity > MaxSimilarity) {
                            MaxSimilarity = Similarity;
                            MaxIndex = i;
                        }
                    }
                    LocalSGMaxMatchIndex[BasisRank] = MaxIndex;
                }
            }
            GroupMemoryBarrierWithGroupSync();
            int NumNewBasis = 0;
            // Pairing the SGs for merging, single threaded algorithm
            if(WaveIsFirstLane()) {
                // Simple greedy algorithm instead of dfs alike precise algirithm
                [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
                for(int i = 0; i<NumBasis; i++) {
                    int MaxIndex = LocalSGMaxMatchIndex[i];
                    if(MaxIndex >= 0) {
                        // Meet a not matched basis
                        bool AllocateNewSlot = false;
                        // A not matched basis
                        if(MergeCount > 0) {
                            if(MaxIndex > i) {
                                // Try to match the opponent
                                int OpponentMatchIndex = LocalSGMaxMatchIndex[MaxIndex];
                                // Try to match MaxIndex
                                if(OpponentMatchIndex != -1) {
                                    // Matched, so cancel the matching for MaxIndex
                                    LocalSGMaxMatchIndex[MaxIndex] = -1;
                                    MergeCount --;
                                    AllocateNewSlot = true;
                                } else {
                                    // The opponent is already matched by someone else
                                    // Failed, match with myself.
                                    LocalSGMaxMatchIndex[i] = i;
                                    AllocateNewSlot = true;
                                }
                            } else {
                                int OpponentMatchIndex = LocalSGMaxMatchIndex[MaxIndex];
                                // MaxIndex have no match for now, so we match it
                                if(MaxIndex == OpponentMatchIndex) {
                                    // Matched.
                                    LocalSGMaxMatchIndex[MaxIndex] = i;
                                    LocalSGMaxMatchIndex[i] = -1;
                                    MergeCount --;
                                } else {
                                    // Failed, the opponent has already matched.
                                    // Match with myself.
                                    LocalSGMaxMatchIndex[i] = i;
                                    AllocateNewSlot = true;
                                }
                            }
                        } else {
                            // No need for further merging. Match with itself
                            LocalSGMaxMatchIndex[i] = i;
                            AllocateNewSlot = true;
                        }
                        if(AllocateNewSlot) LocalSGNewIndex[i] = NumNewBasis++;
                    }
                }
            }
            GroupMemoryBarrierWithGroupSync();
            NumNewBasis = WaveReadLaneFirst(NumNewBasis);
            MergeCount  = WaveReadLaneFirst(MergeCount);
            // Merge the SGs
            {
                int BasisRank = LocalID;
                if(BasisRank < NumBasis) {
                    int MaxIndex  = LocalSGMaxMatchIndex[BasisRank];
                    if(MaxIndex >= 0) {
                        SGData NewSG;
                        if(MaxIndex != BasisRank) {
                            SGData X = LocalSGData4[BasisRank];
                            SGData Y = LocalSGData4[MaxIndex];
                            NewSG = CombineSG(X, Y);
                        } else NewSG = LocalSGData4[BasisRank];
                        LocalSGData4New[LocalSGNewIndex[BasisRank]] = NewSG;
                    }
                }
            }
            GroupMemoryBarrierWithGroupSync();
            // Swap the data
            {
                int BasisRank = LocalID;
                if(BasisRank < NumNewBasis) {
                    LocalSGData4[BasisRank] = LocalSGData4New[BasisRank];
                }
            }
            NumBasis = NumNewBasis;
            // Barrier the next iteration
            GroupMemoryBarrierWithGroupSync();
        }
    }
    // Write the new SGs to the buffer
    {
#if SSRC_MAX_NUM_BASIS_PER_PROBE > WAVE_SIZE
#error "SSRC_MAX_NUM_BASIS_PER_PROBE must be less than or equal to WAVE_SIZE"
#endif
        int BasisOffset = Header.BasisOffset;
        // TODO: Accumulate SG radiance into irradiance when dropping overflowing SGs 
        if(LocalID < CurrentProbeBasisCount) {
            SGData SG;
            if(LocalID < NumBasis) SG = LocalSGData4[LocalID];
            else {
                // Initialize the basis
                SG.Color = 0.001f;
                SG.Lambda = InitSGLambda(NumBasis);
                SG.Depth  = MI.CameraFar;
                float3 Direction = InitHemiDirections(LocalID, CurrentProbeBasisCount);
                SG.Direction = normalize(Direction.x * ProbeTangent + Direction.y * ProbeBitangent + Direction.z * Header.Normal);
            }
            WriteBasisData(BasisOffset + LocalID, SG);
        }
    }
}

// Initialize screen probes that failed in reprojection with world cache.
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_InitializeFailedProbes (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {
    ...
}

// Allocate update rays for each probe
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateUpdateRays (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0]) {
        return;
    }
    // NOTE: the allocation number must be a multiple of WAVE_SIZE
    // NOTE: and no greater than SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE
    int2 ProbeIndex = int2(DispatchID % MI.TileDimensions.x, DispatchID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    // Invalid probe
    if(Header.LinearDepth <= 0) {
        g_RWProbeUpdateRayCountBuffer[DispatchID] = 0;
        return ;
    }
    // Naive strategy: allocate more rays for probes that failed in reprojection
    float Trust = g_RWProbeHistoryTrustTexture[ProbeIndex];
    int   Bonus = MI.BaseUpdateRayWaves + (1.f - Trust) * (SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE - MI.BaseUpdateRayWaves);
    g_RWProbeUpdateRayCountBuffer[DispatchID] = min(WAVE_SIZE * max(1, Bonus), SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE);
}

// A scan sum is performed to accumulate allocated raycount for each probe

[numthreads(1, 1, 1)]
void SetUpdateRayCount () {
    int ProbeCount = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0];
    g_RWUpdateRayCountBuffer[0] = g_RWProbeUpdateRayOffsetBuffer[ProbeCount] + WorldCache.NumUpdateRayPerProbe * WorldCache_GetActiveProbeCount();
}


// TODO: Should we study from Lumen to use a large number? (Lumen: 0.1)
#define MIN_PDF_TO_TRACE 2e-2f

groupshared float3 LocalOctahedronRadiance[SSRC_PROBE_TEXTURE_TEXEL_COUNT];
groupshared float  LocalOctahedronSampleWeightPrefixSum[SSRC_PROBE_TEXTURE_TEXEL_COUNT];
groupshared SGData LocalSGData[SSRC_MAX_NUM_BASIS_PER_PROBE];
groupshared float LocalSGSize[SSRC_MAX_NUM_BASIS_PER_PROBE];
float RadianceToSampleWeight (float3 Radiance) {
    return dot(Radiance, 1.f.xxx) + 1e-4f;
}
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_SampleUpdateRays (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {
    const float Epsilon = 1e-8f;
    // We assume that ray count is always a multiple of WAVE_SIZE
    int  ProbeIndex1 = GroupID;
    int2 ProbeIndex  = int2(ProbeIndex1 % MI.TileDimensions.x, ProbeIndex1 / MI.TileDimensions.x);
    int  RayCount    = g_RWProbeUpdateRayCountBuffer[ProbeIndex1];
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    int  BasisCount  = GetProbeBasisCountFromClass(Header.Class);
    // Reuse the shmem from reprojection kernel
#if SSRC_MAX_NUM_BASIS_PER_PROBE > WAVE_SIZE
#error "SSRC_MAX_NUM_BASIS_PER_PROBE must be less than or equal to WAVE_SIZE"
#endif
    {
        int BasisRank = LocalID;
        if(BasisRank < BasisCount) {
            SGData SG = FetchBasisData(Header.BasisOffset + BasisRank);
            LocalSGData[BasisRank] = SG;
            float SGSize = SGIntegrate(SG.Lambda) * dot(SG.Color, 1.f.xxx);
            LocalSGSize[BasisRank] = SGSize + Epsilon;
        } else if(BasisRank < SSRC_MAX_NUM_BASIS_PER_PROBE) {
            LocalSGSize[BasisRank] = 0;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    float SumSizeOctahedronOriginal = 0.f;
    // Load octahedron sample weights
    {
        float SavedPrefixSum = 0.f;
        for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
            int  ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
            int2 ProbeTexelCoords = int2(ProbeTexelIndex % SSRC_PROBE_TEXTURE_SIZE, ProbeTexelIndex / SSRC_PROBE_TEXTURE_SIZE);
            float4 RadianceDepth = GetScreenProbeOctahedronRadianceDepth(ProbeIndex, ProbeTexelCoords);
            float3 Radiance = RadianceDepth.xyz;
            LocalOctahedronRadiance[ProbeTexelIndex] = Radiance;
            float PrefixSum = WavePrefixSum(RadianceToSampleWeight(Radiance)) + SavedPrefixSum;
            LocalOctahedronSampleWeightPrefixSum[ProbeTexelIndex] = PrefixSum;
#if SSRC_PROBE_TEXTURE_TEXEL_COUNT % WAVE_SIZE != 0
#error "SSRC_PROBE_TEXTURE_TEXEL_COUNT must be a multiple of WAVE_SIZE"
#endif
            SavedPrefixSum = WaveReadLaneAt(PrefixSum + RadianceToSampleWeight(Radiance), WAVE_SIZE - 1); 
        }
        SumSizeOctahedronOriginal = SavedPrefixSum;
    }
    GroupMemoryBarrierWithGroupSync();
    // Compute the sum of SG sizes
    float ThreadSizeSums[SSRC_MAX_NUM_BASIS_PER_PROBE];
    ThreadSizeSums[0] = 0;
    if(BasisCount > 0) ThreadSizeSums[0] = LocalSGSize[0];
    [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE-1)]
    for(int i = 1; i < BasisCount; i++) {
        ThreadSizeSums[i] = ThreadSizeSums[i-1] + LocalSGSize[i];
    }
    float SumSizeBasis = BasisCount > 0 ? ThreadSizeSums[BasisCount - 1] : 0;

    // Assume that octahedron mapping to sphere is area preserving (ignoring the distortion)
    float SumSizeOctahedron = SumSizeOctahedronOriginal * (TWO_PI / SSRC_PROBE_TEXTURE_TEXEL_COUNT) + Epsilon;

    float SumSize = SumSizeBasis + SumSizeOctahedron;
    
    Random rng = MakeRandom(GroupID * WAVE_SIZE + LocalID, MI.FrameSeed);
#if SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE % WAVE_SIZE != 0
#error "SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE must be a multiple of WAVE_SIZE"
#endif
    // Allocate a number of rays to sample the probe octahedron
    // Round to a multiple of WAVE_SIZE with russian roulette for maximum wave coherence & occupancy
    int NumProbeOctahedronSamples = RayCount * SumSizeOctahedron / SumSize;
    if(WaveIsFirstLane()) {
        int Remainder = NumProbeOctahedronSamples % WAVE_SIZE;
        float P = float(Remainder) / WAVE_SIZE;
        // Lane 0 decides the remainder
        float x = rng.rand();
        bool  b = x < P;
        if(b) NumProbeOctahedronSamples += WAVE_SIZE - Remainder;
        else NumProbeOctahedronSamples -= Remainder;
    }
    // Broadcast to all lanes
    NumProbeOctahedronSamples = WaveReadLaneFirst(NumProbeOctahedronSamples);
    // If there's no basis, we sample the octahedron directly
    if(BasisCount == 0) NumProbeOctahedronSamples = RayCount;
    // Calculate the probability for using octahedron sampling (use RR result)
    float P_SampleOctahedron = NumProbeOctahedronSamples / float(RayCount);
    // Sample probe octahedron
    float3 ProbeTangent, ProbeBitangent;
    GetOrthoVectors(Header.Normal, ProbeTangent, ProbeBitangent);
    [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
    for(int RayRankBase = 0; RayRankBase < NumProbeOctahedronSamples; RayRankBase += WAVE_SIZE) {
        // We assume that ray count is always a multiple of WAVE_SIZE
        int RayRank = RayRankBase + LocalID;
        float  u    = rng.rand();
        float2 u2   = rng.rand2();
        float  U    = u * SumSizeOctahedronOriginal;
        int L = 0, R = SSRC_PROBE_TEXTURE_TEXEL_COUNT;
        for(int i = 0; i<SSRC_PROBE_TEXTURE_TEXEL_COUNT_L2; i++) {
            int Mid = (L + R) / 2;
            if(LocalOctahedronSampleWeightPrefixSum[Mid] <= U) L = Mid;
            else R = Mid;
        }
        float OctPdf = RadianceToSampleWeight(LocalOctahedronRadiance[L]) / SumSizeOctahedronOriginal * SSRC_PROBE_TEXTURE_TEXEL_COUNT;
        float2 TexelUV = u2;
        int2   TexelCoords = int2(L % SSRC_PROBE_TEXTURE_SIZE, L / SSRC_PROBE_TEXTURE_SIZE);
        float2 OctahedronUV = (TexelUV + TexelCoords) * (1.f / SSRC_PROBE_TEXTURE_SIZE);
        float3 RayDirection = HemiOctahedron01ToUnitVector(OctahedronUV);
        RayDirection = RayDirection.x * ProbeTangent + RayDirection.y * ProbeBitangent + RayDirection.z * Header.Normal;
        // Convert from [0, 1]^2 to S^2
        OctPdf = OctPdf * (1.f / TWO_PI);
        // Accumulate pdf from SGs
        float SGPdfSum = 0.f;
        [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE)]
        for(int i = 0; i < BasisCount; i++) {
            SGData SG = LocalSGData[i];
            SGPdfSum += LocalSGSize[i] * SampleSGPDF(SG.Lambda, dot(RayDirection, SG.Direction));
        }
        float RayPdf = OctPdf * P_SampleOctahedron + SGPdfSum / max(SumSizeBasis, Epsilon) * (1.f - P_SampleOctahedron);
        if(MI.NoImportanceSampling) {
            RayPdf = UniformSampleHemispherePdf();
            RayDirection = UniformSampleHemisphere(u2);
            RayDirection = normalize(ProbeTangent * RayDirection.x + ProbeBitangent * RayDirection.y + Header.Normal * RayDirection.z);
        }
        // 0623: This must be checked otherwise there're precision issues
        float bValid = dot(RayDirection, Header.Normal) > 0;
        if(RayPdf >= MIN_PDF_TO_TRACE && bValid) {
            WriteUpdateRay(ProbeIndex, Header.ScreenCoords, RayRank, RayDirection, RayPdf);
        } else {
            // No need to do compressing since there're just a tiny number of rays being canceled
            WriteUpdateRay(ProbeIndex, Header.ScreenCoords, RayRank, 0, 0);
        }
    }
    // Sample SGs
    [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
    for(int RayRankBase = NumProbeOctahedronSamples; RayRankBase < RayCount; RayRankBase += WAVE_SIZE) {
        // We assume that ray count is always a multiple of WAVE_SIZE
        int RayRank = RayRankBase + LocalID;
        float  u    = rng.rand();
        float2 u2   = rng.rand2();
        float U     = u * SumSizeBasis;
        int BasisRank = BasisCount;
        [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE)]
        for(int i = 0; i < BasisCount; i++) {
            if(U < ThreadSizeSums[i]) {
                BasisRank = i;
                break;
            }
        }
        // Clamp to the first basis in case the random number is overflowed (should be rare)
        if(BasisRank == BasisCount) BasisRank = 0;
        float3 RayDirection, SGDirection;
        {
            SGData SG = LocalSGData[BasisRank];
            float RayPdfTmp;
            RayDirection = SampleSG(u2, SG.Lambda, RayPdfTmp);
            SGDirection = SG.Direction;
        }
        float3 Tangent, Bitangent;
        GetOrthoVectors(SGDirection, Tangent, Bitangent);
        RayDirection = normalize(Tangent * RayDirection.x + Bitangent * RayDirection.y + SGDirection * RayDirection.z);
        // Compute ray pdf
        float  RayPdf = 0;
        {
            float SGPdfSum = 0.f;
            [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE)]
            for(int i = 0; i < BasisCount; i++) {
                SGData SG = LocalSGData[i];
                SGPdfSum += LocalSGSize[i] * SampleSGPDF(SG.Lambda, dot(RayDirection, SG.Direction));
            }
            float OctPdf = 0.f;
            if(dot(RayDirection, Header.Normal) > 0) {
                float3 ProbeRayDirection = float3(
                    dot(RayDirection, ProbeTangent),
                    dot(RayDirection, ProbeBitangent),
                    dot(RayDirection, Header.Normal)
                );
                float2 OctahedronUV = UnitVectorToHemiOctahedron01(ProbeRayDirection);
                int2   TexelCoords = int2(OctahedronUV * SSRC_PROBE_TEXTURE_SIZE);
                int    TexelIndex = TexelCoords.y * SSRC_PROBE_TEXTURE_SIZE + TexelCoords.x;
                OctPdf = RadianceToSampleWeight(LocalOctahedronRadiance[TexelIndex]) / SumSizeOctahedronOriginal * SSRC_PROBE_TEXTURE_TEXEL_COUNT;
            }
            RayPdf = OctPdf * P_SampleOctahedron
                + SGPdfSum / max(SumSizeBasis, Epsilon) * (1.f - P_SampleOctahedron);
        }
        if(MI.NoImportanceSampling) {
            RayPdf = UniformSampleHemispherePdf();
            RayDirection = UniformSampleHemisphere(u2);
            RayDirection = normalize(ProbeTangent * RayDirection.x + ProbeBitangent * RayDirection.y + Header.Normal * RayDirection.z);
        }
        // 0623: This must be checked otherwise there're precision issues
        bool bValid = dot(RayDirection, Header.Normal) > 0;
        // Pack the ray
        // TODO jitter the ray origin ? may be useless
        if(RayPdf >= MIN_PDF_TO_TRACE && bValid) {
            WriteUpdateRay(ProbeIndex, Header.ScreenCoords, RayRank, RayDirection, RayPdf);
        } else {
            // No need to do compressing since there're just a tiny number of rays being canceled
            WriteUpdateRay(ProbeIndex, Header.ScreenCoords, RayRank, 0, 0);
        }
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void WorldCache_SampleUpdateRays () {
    ...
}


#define SSRC_DISPATCH_RAYS_GROUP_SIZE 8

[numthreads(1, 1, 1)]
void MIGI_GenerateTraceUpdateRays () {
    int ProbeCount = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0] + g_WorldCacheActiveProbeCount[0];
    int RayCount   = g_RWUpdateRayCountBuffer[0];
    DispatchRaysCommand dispatch_command_rays = (DispatchRaysCommand)0;
    dispatch_command_rays.ray_generation_shader_record = g_RTConstants.ray_generation_shader_record;
    dispatch_command_rays.miss_shader_table = g_RTConstants.miss_shader_table;
    dispatch_command_rays.hit_group_table = g_RTConstants.hit_group_table;
    dispatch_command_rays.callable_shader_table = g_RTConstants.callable_shader_table;
    dispatch_command_rays.width = RayCount;
    dispatch_command_rays.height = 1;
    dispatch_command_rays.depth = 1;
    g_RWDispatchRaysCommandBuffer[0] = dispatch_command_rays;

    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = 
        (RayCount + SSRC_DISPATCH_RAYS_GROUP_SIZE - 1) 
        / SSRC_DISPATCH_RAYS_GROUP_SIZE;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

void MIGI_CacheUpdateHandleHit(uint DispatchID, inout MIGI_CacheUpdatePayload payload, RayDesc ray, HitInfo hit_info)
{
    WorldCacheQuery Query;
    Query.Hit = ray.Origin + payload.hit_dist * ray.Direction;
    Query.Direction   = ray.Direction;
    Query.HitDistance = payload.hit_dist;

    // Record hit distance
    g_RWUpdateRayLinearDepthBuffer[DispatchID] = payload.hit_dist;

    // Enqueue query
    WorldCacheEnqueueQuery(Query);
}

void MIGI_CacheUpdateHandleMiss(inout MIGI_CacheUpdatePayload payload, RayDesc ray)
{
    payload.sky_sample = g_EnvironmentBuffer.SampleLevel(g_TextureSampler, ray.Direction, 0.0f).xyz;
}

void ScreenCacheUpdateTraceRayInline(uint did, inout MIGI_CacheUpdatePayload payload, RayDesc ray)
{
    ClosestRayQuery ray_query = TraceRay<ClosestRayQuery>(ray);

    // If we hit some geometry, we append a new world-space hash-grid cache query
    if(ray_query.CommittedStatus() == COMMITTED_TRIANGLE_HIT)
    {
        payload.hit_dist = ray_query.CommittedRayT();
        MIGI_CacheUpdateHandleHit(did, payload, ray, GetHitInfoRtInlineCommitted(ray_query));
    } else {
        payload.hit_dist = ray_query.CommittedRayT();
        MIGI_CacheUpdateHandleMiss(payload, ray);
    }
}

void ScreenCacheUpdateTraceRayRt(uint did, inout MIGI_CacheUpdatePayload payload, RayDesc ray)
{
    TraceRay(g_Scene, RAY_FLAG_NONE, 0xFFu, 0, 0, 0, ray, payload);
}

void ScreenCacheUpdateTraceRay(uint did, inout MIGI_CacheUpdatePayload payload, RayDesc ray)
{
#if USE_INLINE_RT
    ScreenCacheUpdateTraceRayInline(did, payload, ray);
#else
    ScreenCacheUpdateTraceRayRt(did, payload, ray);
#endif
}

// Trace visibility rays to generate secondary vertices / hits for world cache update 
void MIGI_TraceUpdateRays (uint DispatchID) {
    int ProbeCount = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0];
    int RayCount   = g_RWProbeUpdateRayOffsetBuffer[ProbeCount];
    if(DispatchID >= RayCount) return ;
    
    // Unpack ray data
    int2   ProbeIndex = UnpackUint16x2(g_RWUpdateRayProbeBuffer[DispatchID / WAVE_SIZE]);

    float3 ProbeNormal = GetScreenProbeNormal(ProbeIndex);
    // The probe origin is offseted by adaptive normal (bent - geom mix), so no need to do further offset here
    float3 RayOrigin = GetScreenProbePosition(ProbeIndex);

    float3 RayDirection      = FetchUpdateRayDirection(DispatchID);
    float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[DispatchID]);
    float  InvPdf = RayRadianceInvPdf.w;

    // Early out if the ray is invalid / clipped for too tiny pdf.
    if(InvPdf == 0) return ;

    if(MI.DebugLight != 0) {
        float3 LightPos = MI.DebugLightPosition;
        float  DistSqr  = lengthSqr(LightPos - RayOrigin);
        float  R2       = MI.DebugLightSize * MI.DebugLightSize;
        float  MaxCosTheta = sqrt(DistSqr - R2) / sqrt(DistSqr);
        float  CosTheta = dot(normalize(LightPos - RayOrigin), RayDirection);
        float3 L = (CosTheta > MaxCosTheta) ? MI.DebugLightColor : 0.f;
        g_RWUpdateRayRadianceInvPdfBuffer[DispatchID] = PackFp16x4Safe(float4(L, InvPdf));
        float  RayLenSqr = DistSqr - R2;
        g_RWUpdateRayLinearDepthBuffer[DispatchID] = sqrt(RayLenSqr);
        return ;
    }

    // Trace a visibility ray only.
    RayDesc VisibilityRayDesc;
    VisibilityRayDesc.Origin = RayOrigin;
    VisibilityRayDesc.Direction = RayDirection;
    VisibilityRayDesc.TMin = 0.f;
    VisibilityRayDesc.TMax = MAX_HIT_DISTANCE;

    // Fallback to far plane if no intersection
    g_RWUpdateRayLinearDepthBuffer[DispatchID]    = MI.CameraFar;

    MIGI_CacheUpdatePayload payload;
    payload.sky_sample = float3(0.0f, 0.0f, 0.0f);
    ScreenCacheUpdateTraceRay(
        DispatchID,
        payload, VisibilityRayDesc
    );
    // Fallback to sky sample if no intersection
    g_RWUpdateRayRadianceInvPdfBuffer[DispatchID] = PackFp16x4Safe(float4(payload.sky_sample, InvPdf));
    
}

[numthreads(SSRC_DISPATCH_RAYS_GROUP_SIZE, 1, 1)]
void SSRC_TraceUpdateRaysMain (uint DispatchID : SV_DispatchThreadID) {
    SSRC_TraceUpdateRays(DispatchID);
}


// HiZ required for injection culling
[numthreads(8, 8, 1)]
void PrecomputeHiZ (int2 DispatchID : SV_DispatchThreadID) {
    int2 Dimensions;
    g_RWHiZ_Out.GetDimensions(Dimensions.x, Dimensions.y);
    if(any(DispatchID >= Dimensions)) {
        return;
    }
    float X00 = g_RWHiZ_In[int2(2 * DispatchID.x + 0, 2 * DispatchID.y + 0)].x;
    float X01 = g_RWHiZ_In[int2(2 * DispatchID.x + 0, 2 * DispatchID.y + 1)].x;
    float X10 = g_RWHiZ_In[int2(2 * DispatchID.x + 1, 2 * DispatchID.y + 0)].x;
    float X11 = g_RWHiZ_In[int2(2 * DispatchID.x + 1, 2 * DispatchID.y + 1)].x;
#ifdef HIZ_MIN
    float X0 = min(X00, X01);
    float X1 = min(X10, X11);
    float X = min(X0, X1);
#else
    if(X00 == 1.f) X00 = 0.f;
    if(X01 == 1.f) X01 = 0.f;
    if(X10 == 1.f) X10 = 0.f;
    if(X11 == 1.f) X11 = 0.f;
    float X0 = max(X00, X01);
    float X1 = max(X10, X11);
    float X = max(X0, X1);
    if(X == 0.f) X = 1.f;
#endif
    g_RWHiZ_Out[DispatchID] = X;
}


[numthreads(SSRC_TILE_SIZE, SSRC_TILE_SIZE, 1)]
void SSRC_ReprojectPreviousUpdateError (int2 DispatchID : SV_DispatchThreadID) {
    if(any(DispatchID >= MI.ScreenDimensions)) {
        return;
    }

    float3 NormalPrev = g_GeometryNormalTexture.Load(int3(DispatchID, 0)).xyz;
    bool   IsSkyPixel = (dot(NormalPrev, NormalPrev) == 0.0f ? true : false);

    if (IsSkyPixel)
    {
        g_RWUpdateErrorSplatTexture[DispatchID] = 0.f;
        return;
    }
    float3 Normal = normalize(2.f * NormalPrev - 1.f);

    // Reproject the update error texture from previous frame to current frame
    float4 packed_visibility = g_VisibilityTexture.Load(int3(DispatchID, 0));
    float2 Barycentrics      = packed_visibility.xy;
    int   InstanceIndex      = asint(packed_visibility.z);
    int   PrimitiveIndex      = asint(packed_visibility.w);

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[InstanceIndex];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    TriangleNormUV vertices = fetchVerticesNormUV(mesh, PrimitiveIndex);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);

    vertices.n0 = transformNormal(vertices.n0, transform);
    vertices.n1 = transformNormal(vertices.n1, transform);
    vertices.n2 = transformNormal(vertices.n2, transform);

    float3   world    = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);

    float3 homogeneous = transformPointProjection(world, MI.CameraProjView);

    float2 UV          = 0.5f * float2(homogeneous.x, -homogeneous.y) + 0.5f;
    float  Depth       = homogeneous.z;

    // Severe precision loss here if we use the following reprojection method
    // float2 UV = (float2(DispatchID) + 0.5f) * MI.ScreenDimensionsInv;
    // float Depth = g_DepthTexture.Load(int3(UV, 0)).x;
    // float3 Normal = normalize(2.f * g_GeometryNormalTexture.Load(int3(UV, 0)).xyz - 1.f);
    // float3 homogeneous = float3(UV2NDC2(UV), Depth);

    if (all(UV > 0.0f) && all(UV < 1.0f) && Depth > 0.0f && Depth < 1.0f)
    {
        float2 previous_uv = UV - g_VelocityTexture.SampleLevel(g_NearestSampler, UV, 0.0f).xy;

        if (all(previous_uv > 0.0f) && all(previous_uv < 1.0f))
        {
            float3 homogeneous2 = transformPointProjection(homogeneous, MI.Reprojection);
            homogeneous2.z      = GetLinearDepth(homogeneous2.z);

            float  previous_depth  = GetLinearDepth(g_PreviousDepthTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).x);
            float3 previous_normal = normalize(2.0f * g_PreviousGeometryNormalTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz - 1.0f);

            if (dot(previous_normal, Normal) > 0.5f && abs(previous_depth - homogeneous2.z) / homogeneous2.z < 5e-2f)
            {
                // Using linear sampler in reprojection can significantly increase the reprojected error, why?
                float PreviousError = g_PreviousUpdateErrorSplatTexture.SampleLevel(g_NearestSampler, previous_uv, 0).x;
                g_RWUpdateErrorSplatTexture[DispatchID] = PreviousError;
                return; 
            }
        }
    }
    
    // TODO allocate a initial weight for the update error
    // FIXME
    g_RWUpdateErrorSplatTexture[DispatchID] = 0.f;
}

// UpdateErrorSplatTexture is later mipmapped.

struct MIGI_RayProbeIndex {
    int2 ScreenProbeIndex;
    int  WorldProbeIndex;
    bool IsWorldProbe;
};
MIGI_RayProbeIndex UnpackRayProbeIndex (uint Packed) {
    MIGI_RayProbeIndex Result;
    Result.ScreenProbeIndex = UnpackUint16x2(Packed);
    Result.WorldProbeIndex = Packed & 0x7fffffffu;
    Result.IsWorldProbe = (Packed & 0x80000000u) != 0;
    return Result;
}

// Try to reproject the previous diffuse irradiance to the current frame 
// and bypass world cache shading for possible queries 
[numthreads(WAVE_SIZE, 1, 1)]
void WorldCache_ReuseScreenRadiance(in uint DispatchID : SV_DispatchThreadID)
{
    uint QueryIndex = DispatchID;
    if (QueryIndex >= g_HashGridCache_VisibilityCountBuffer[0])
    {
        return; // out of bounds
    }
    float Q_Noise = BlueNoise_Sample1D(int2(QueryIndex % 1024, QueryIndex / 1024), MI.FrameSeed, 5);

    // Load our visibility sample
    WorldCacheVisibility QueryVisibility = WorldCache_FetchQueryVisibility(QueryIndex);

    // Reconstruct world-space position and normal
    Instance InstanceData  = g_InstanceBuffer[QueryVisibility.instance_index];
    Mesh     mesh      = g_MeshBuffer[InstanceData.mesh_index];
    float3x4 transform = g_TransformBuffer[InstanceData.transform_index];

    TriangleNormUV vertices = fetchVerticesNormUV(mesh, QueryVisibility.primitive_index);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);

    vertices.n0 = transformNormal(vertices.n0, transform);
    vertices.n1 = transformNormal(vertices.n1, transform);
    vertices.n2 = transformNormal(vertices.n2, transform);

    float3   WorldPosition    = interpolate(vertices.v0, vertices.v1, vertices.v2, visibility.barycentrics);
    float3   WorldNormal      = 
        (QueryVisibility.is_front_face ? 1.0f : -1.0f) * 
        normalize(interpolate(vertices.n0, vertices.n1, vertices.n2, visibility.barycentrics));
    Material MaterialData = g_MaterialBuffer[InstanceData.material_index];

    // Recover the ray origin
    float3 RayOrigin = 0;
    {
        MIGI_RayProbeIndex RPI = UnpackRayProbeIndex(g_RWUpdateRayProbeBuffer[QueryIndex / WAVE_SIZE]);
        if(RPI.IsWorldProbe)
            RayOrigin = WorldCache_ProbePosition(RPI.WorldProbeIndex);
        else RayOrigin = GetScreenProbePosition(RPI.ScreenProbeIndex);
    }
    float2 MeshUV = interpolate(vertices.uv0, vertices.uv1, vertices.uv2, QueryVisibility.barycentrics);

    // Bypass the cache if we hit an emitter. Normally emissive materials overwhelm ambient lighting.

    if (QueryVisibility.is_front_face && dot(MaterialData.emissivity.xyz, MaterialData.emissivity.xyz) > 0.0f)
    {
        MaterialEmissive emissive = MakeMaterialEmissive(MaterialData, MeshUV);
        float4 RadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[QueryIndex]);
        RadianceInvPdf.xyz = emissive.emissive;
        g_RWUpdateRayRadianceInvPdfBuffer[QueryIndex] = PackFp16x4Safe(RadianceInvPdf);
        return; // do not continue past an emissive surface
    }

    // Touch the cache to accumulate probe scores
    WorldCache_Touch(WorldPosition, WorldNormal);

    // Bypass diffuse shading if the projection is valid on screen. 
    // Reuse the previous frame's diffuse irradiance for better quality.
    {
        float4 homogeneous_w = mul(MI.CameraProjView, float4(WorldPosition, 1.0f));
        if(homogeneous_w.w > 0) {
            float3 homogeneous = homogeneous_w.xyz / homogeneous_w.w;

            float2 uv    = 0.5f * float2(homogeneous.x, -homogeneous.y) + 0.5f;
            float  depth = homogeneous.z;

            if (all(uv > 0.0f) && all(uv < 1.0f) && depth > 0.0f && depth < 1.0f)
            {
                float2 previous_uv = uv - g_VelocityTexture.SampleLevel(g_NearestSampler, uv, 0.0f).xy;

                if (all(previous_uv > 0.0f) && all(previous_uv < 1.0f))
                {
                    float3 reprojected_homogeneous  = transformPointProjection(homogeneous, MI.Reprojection);
                    float  reprojected_linear_depth = GetLinearDepth(reprojected_homogeneous.z);

                    float  previous_linear_depth  = GetLinearDepth(g_PreviousDepthTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).x);
                    float3 previous_normal = normalize(2.0f * g_PreviousGeometryNormalTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz - 1.0f);
                    // Prevent front-to-back light leaks from thin meshes
                    bool normal_selection = dot(previous_normal, WorldNormal) > 5e-1f;
                    bool depth_selection  = 
                        abs(previous_linear_depth - reprojected_linear_depth) 
                        / max(previous_linear_depth, reprojected_linear_depth) < 5e-2f;
                    if (normal_selection && depth_selection)
                    {
                        // Diffuse only. Glossy / specular lighting may vary significantly according
                        // to the viewing angle, so we cannot reuse them.
                        float3 previous_lighting = LoadPreviousDiffuseLighting(previous_uv);
                        uint  cell_index         = g_HashGridCache_VisibilityCellBuffer[DispatchID];
                        uint4 quantized_radiance = HashGridCache_QuantizeRadiance(previous_lighting, Q_Noise);
    #ifdef ENABLE_INDIRECT
                        float4 RayRadianceInvPdf    = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[query_index]);
                        RayRadianceInvPdf.xyz      += previous_lighting;
                        g_RWUpdateRayRadianceInvPdfBuffer[query_index] = PackFp16x4Safe(RayRadianceInvPdf);
    #endif // ENABLE_INDIRECT
                        if(IsDiffuseMaterial) {
                            // Skip world cache shading for diffuse materials that project well on screen
                            return;
                        }
                    }
                }
            }
        }
    }

    // Group queries to the world cache grids for better memory access concurrency
    WorldCache_GroupQuery(WorldPosition, QueryIndex);
}

// Perform shading for the world cache queries
[numthreads(WAVE_SIZE, 1, 1)]
void WorldCache_ShadeQueries(in uint did : SV_DispatchThreadID)
{
    if (did >= g_Reservoir_HashListCountBuffer[0])
    {
        return; // out of bounds
    }

    {
        float3 Wi = normalize(RayOrigin - WorldPosition);
        MaterialEvaluated MaterialEvaluatedData = MakeMaterialEvaluated(MaterialData, MeshUV);
        MaterialBRDF MaterialBRDFData = MakeMaterialBRDF(MaterialEvaluatedData);
    }
}

// Update world cache
[numthreads(WAVE_SIZE, 1, 1)]
void WorldCache_UpdateProbes () {
    // Update probe location if relocation is enabled

    // Update probe radiance.
}


int GetBasisRankToUpdate (int ProbeBasisCount) {
    return MI.FrameSeed % ProbeBasisCount;
}

float HeuristicSGDirectionBias (float3 SG_Direction, float3 Direction) {
    return 0.6f + dot(SG_Direction, Direction) * 0.4f;
}

void WriteScreenProbeSHCoefficients (int2 ProbeIndex, float3 SHCoefficients[9]) {
    float4 R1 = float4(SHCoefficients[1].x, SHCoefficients[2].x, SHCoefficients[3].x, SHCoefficients[4].x);
    float4 R2 = float4(SHCoefficients[5].x, SHCoefficients[6].x, SHCoefficients[7].x, SHCoefficients[8].x);
    float4 G1 = float4(SHCoefficients[1].y, SHCoefficients[2].y, SHCoefficients[3].y, SHCoefficients[4].y);
    float4 G2 = float4(SHCoefficients[5].y, SHCoefficients[6].y, SHCoefficients[7].y, SHCoefficients[8].y);
    float4 B1 = float4(SHCoefficients[1].z, SHCoefficients[2].z, SHCoefficients[3].z, SHCoefficients[4].z);
    float4 B2 = float4(SHCoefficients[5].z, SHCoefficients[6].z, SHCoefficients[7].z, SHCoefficients[8].z);
    float3 RGB0 = SHCoefficients[0];
    g_RWProbeIrradianceTexture[ProbeIndex].xyz = RGB0;
    g_RWProbeSHCoefficientsRTexture[ProbeIndex] = R1;
    g_RWProbeSHCoefficientsRTexture[ProbeIndex + int2(MI.TileDimensions.x, 0)] = R2;
    g_RWProbeSHCoefficientsBTexture[ProbeIndex] = B1;
    g_RWProbeSHCoefficientsBTexture[ProbeIndex + int2(MI.TileDimensions.x, 0)] = B2;
    g_RWProbeSHCoefficientsGTexture[ProbeIndex] = G1;
    g_RWProbeSHCoefficientsGTexture[ProbeIndex + int2(MI.TileDimensions.x, 0)] = G2;
}

// Update the probe cache
groupshared float3 LocalEvaluatedRadiance[SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE];
groupshared float3 LocalDColorPrefixSum[WAVE_SIZE];
groupshared float3 LocalDDirectionPrefixSum[WAVE_SIZE];
groupshared float  LocalAFactorSum[WAVE_SIZE];
groupshared float  LocalDLambdaPrefixSum[WAVE_SIZE];

groupshared float3 LocalProbeTexels[SSRC_PROBE_TEXTURE_TEXEL_COUNT];
// The coverage of each ray by SGs
groupshared float  LocalRayCoverage[SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE];
groupshared float  LocalSampleWeightPrefixSum[WAVE_SIZE];

// TODO classify the number of update rays to completely unroll many loops
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_UpdateProbes (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {

    const float Epsilon = 1e-7f;

    int2 ProbeIndex = int2(GroupID % MI.TileDimensions.x, GroupID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    // Thread group early out if the probe is not valid
    [branch]
    if(!Header.bValid) return ;

    int  BasisCount = GetProbeBasisCountFromClass(Header.Class);
    int  ProbeRayCount   = g_RWProbeUpdateRayCountBuffer[GroupID];
    int  ProbeRayOffset  = g_RWProbeUpdateRayOffsetBuffer[GroupID];
    
    float  ReprojectionTrust = g_RWProbeHistoryTrustTexture[ProbeIndex].x;

    // Re-initialize the probe if it is not trusted at all
    [branch]
    if(ReprojectionTrust == 0) {
        // TODO heuristic initialization for probe octahedron radiances
        ResetProbe(GroupID, LocalID, ProbeIndex, BasisCount, Header.BasisOffset, Header.Normal);
    }

    if(LocalID < BasisCount) {
        LocalSGData[LocalID] = FetchBasisData(Header.BasisOffset + LocalID);
    }
    GroupMemoryBarrierWithGroupSync();

    // Precomputation, evaluate the radiance of each update ray direction with the SG cache
    float  SumSampleWeight = 0.f;
#if SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE % WAVE_SIZE != 0
#error "SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE must be a multiple of WAVE_SIZE"
#endif
    [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
    for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
        int RayRank  = RayRankBase + LocalID;
        int RayIndex = ProbeRayOffset + RayRank;
        float3 RayDirection      = FetchUpdateRayDirection(RayIndex);
        float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
        float3 RayRadiance       = RayRadianceInvPdf.xyz;
        float  InvPdf            = RayRadianceInvPdf.w;
        if(InvPdf > 0) {
            float3 EvaluatedRadiance = 0.f.xxx;
            float  Coverage = 0;
            [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE)]
            for(int i = 0; i < BasisCount; i++) {
                float Raw = EvaluateSGRaw(LocalSGData[i], RayDirection);
                EvaluatedRadiance += Raw * LocalSGData[i].Color;
                Coverage = max(Coverage, HeuristicSGDirectionBias(LocalSGData[i].Direction, RayDirection));
            }
            LocalEvaluatedRadiance[RayRank] = EvaluatedRadiance;
            LocalRayCoverage[RayRank] = Coverage;
            SumSampleWeight += InvPdf;
        }
    }
    SumSampleWeight         = WaveActiveSum(SumSampleWeight) + Epsilon;
    GroupMemoryBarrierWithGroupSync();

    // Retrieve tangent space for current probe
    float3 ProbeTangent, ProbeBitangent;
    GetOrthoVectors(Header.Normal, ProbeTangent, ProbeBitangent);

    // TODO this must be very unstable
    float3 ImpactFactors = 1.f - ReprojectionTrust;

    // 1. Update probe octahedron radiance
    {
        // Clear accumulation buffer
        for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
            int ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
            LocalProbeTexelsQuantilized[ProbeTexelIndex] = 0.xxxx;
            LocalProbeTexelSampleWeightQuantilized[ProbeTexelIndex] = 0;
        }
        GroupMemoryBarrierWithGroupSync();
        // Noise for quantilization
        float Q_Noise = BlueNoise_Sample1D(uint2(GroupID, LocalID), MI.FrameSeed, 7);
        // Backup radiance value for untraced probe texels in current update
        float3 BackupRadianceSum = 0.f;
        float  BackupRadianceWeightSum = 0.f;
        // Enumerate rays and accumulate
        [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
        for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
            int RayRank  = RayRankBase + LocalID;
            int RayIndex = ProbeRayOffset + RayRank;
            float3 RayDirection      = FetchUpdateRayDirection(RayIndex);
            float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
            float3 RayRadiance       = RayRadianceInvPdf.xyz;
            // RayRadiance = select(RayRadiance > 0.05, 0.05f.xxx, 0.xxx);
            float  InvPdf            = RayRadianceInvPdf.w;
            float  RayDepth          = g_RWUpdateRayLinearDepthBuffer[RayIndex];
            // Check for valid update rays
            if(InvPdf > 0 && dot(RayDirection, Header.Normal) > 0) {
                // Clamp to zero for negative radiance
                float3 TargetRadiance = max(RayRadiance - LocalEvaluatedRadiance[RayRank], 0);
                float  SampleWeight   = InvPdf;
                // Re-weight the importance of each ray within each pixel with the inverse of their pdf
                // to avoid biased estimation of average radiance within the probe octahedron texel.
                float3 WeightedTargetRadiance = TargetRadiance * SampleWeight;
                float  WeightedRayDepth    = RayDepth * SampleWeight;
                // Accumulate the weighted radiance
                float3 ProbeRayDirection = float3(
                    dot(ProbeTangent,   RayDirection),
                    dot(ProbeBitangent, RayDirection),
                    dot(Header.Normal,  RayDirection)
                );
                float2 OctahedronUV = UnitVectorToHemiOctahedron01(ProbeRayDirection);
                int2 OctahedronTexelCoords = clamp(int2(
                    int(OctahedronUV.x * SSRC_PROBE_TEXTURE_SIZE),
                    int(OctahedronUV.y * SSRC_PROBE_TEXTURE_SIZE)
                    ), 0, SSRC_PROBE_TEXTURE_SIZE - 1);
                int  OctahedronTexelIndex = OctahedronTexelCoords.y * SSRC_PROBE_TEXTURE_SIZE + OctahedronTexelCoords.x;
                InterlockedAdd(LocalProbeTexelsQuantilized[OctahedronTexelIndex].x, QuantilizeRadiance(WeightedTargetRadiance.x, Q_Noise));
                InterlockedAdd(LocalProbeTexelsQuantilized[OctahedronTexelIndex].y, QuantilizeRadiance(WeightedTargetRadiance.y, Q_Noise));
                InterlockedAdd(LocalProbeTexelsQuantilized[OctahedronTexelIndex].z, QuantilizeRadiance(WeightedTargetRadiance.z, Q_Noise));
                InterlockedAdd(LocalProbeTexelsQuantilized[OctahedronTexelIndex].w, QuantilizeRadiance(WeightedRayDepth, Q_Noise));
                InterlockedAdd(LocalProbeTexelSampleWeightQuantilized[OctahedronTexelIndex], QuantilizeWeight(SampleWeight, Q_Noise));
                // Accumulate backup radiance
                BackupRadianceSum += WeightedTargetRadiance;
                BackupRadianceWeightSum += SampleWeight;
            }
        }
        BackupRadianceSum = WaveActiveSum(BackupRadianceSum);
        BackupRadianceWeightSum = WaveActiveSum(BackupRadianceWeightSum);
        GroupMemoryBarrierWithGroupSync();
        // Compute the backup radiance
        float3 BackupRadiance = 0.f.xxx;
        {
            // Count untraced probe texels in current update
            int NumUntracedTexels = 0;
            for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
                int ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
                NumUntracedTexels += (LocalProbeTexelSampleWeightQuantilized[ProbeTexelIndex] == 0);
            }
            NumUntracedTexels = WaveActiveSum(NumUntracedTexels);
            // Compute the backup radiance
            BackupRadiance = BackupRadianceSum / max(BackupRadianceWeightSum, 1e-4f);
            float  empty_cell_count = NumUntracedTexels;
            BackupRadiance = BackupRadiance / max(NumUntracedTexels, 1.0f);
        }

        for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
            int  ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
            int2 ProbeTexelCoords = int2(ProbeTexelIndex % SSRC_PROBE_TEXTURE_SIZE, ProbeTexelIndex / SSRC_PROBE_TEXTURE_SIZE);
            int4  Quantilized = LocalProbeTexelsQuantilized[ProbeTexelIndex];
            float4 RadianceDepthSum = RecoverRadiance(Quantilized.xyzw);
            float4 OldRadianceDepth = GetScreenProbeOctahedronRadianceDepth(ProbeIndex, ProbeTexelCoords);
            int    QuantilizedWeight = LocalProbeTexelSampleWeightQuantilized[ProbeTexelIndex];
            float  Weight   = QuantilizedWeight == 0 ? 1.f : RecoverWeight(QuantilizedWeight);
            // Overwrite the radiance depth with backup values if the texel is not traced in current update
            if(QuantilizedWeight == 0) RadianceDepthSum = float4(BackupRadiance, MI.CameraFar);
            float  LumaA = luminance(RadianceDepthSum.xyz);
            float  LumaB = luminance(OldRadianceDepth.xyz);
            // Copy-pasted from GI1.0
            // Shadow-preserving biased temporal hysteresis (inspired by: https://www.youtube.com/watch?v=WzpLWzGvFK4&t=630s)
            // It darkens the scene, while not good enough providing temporal stability as a trade-off.
            float TemporalBlend = squared(clamp(max(LumaA - LumaB - min(LumaA, LumaB), 0.0f) / max(max(LumaA, LumaB), 1e-4f), 0.0f, 0.95f));
            // We overwrite the heuristic with a fixed value for now
            // TemporalBlend = 0.5f;
            // Clamp the lerping factor with impact factors from our pipeline
            TemporalBlend = min(max(1.f - ImpactFactors.x - MI.CacheUpdateLearningRate, 0), TemporalBlend);
            float4 NewValue = lerp(RadianceDepthSum / Weight, OldRadianceDepth, TemporalBlend);
            LocalProbeTexels[ProbeTexelIndex] = NewValue.xyz;
            WriteScreenProbeOctahedronRadianceDepth(ProbeIndex, ProbeTexelCoords, NewValue);
        }
    }
    // Barrier updates on LocalProbeTexels
    GroupMemoryBarrierWithGroupSync();
    for(int BaseUpdateRayRank = 0; BaseUpdateRayRank < ProbeRayCount; BaseUpdateRayRank += WAVE_SIZE) {
        int RayRank = BaseUpdateRayRank + LocalID;
        int UpdateRayIndex = ProbeRayOffset + RayRank;
        float4 RadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[UpdateRayIndex]);
        float3 Radiance = RadianceInvPdf.xyz;
        float  InvPdf   = RadianceInvPdf.w;
        if(InvPdf > 0) {
            float3 RayDirection = FetchUpdateRayDirection(UpdateRayIndex);
            float3 LocalRayDirection = float3(
                dot(ProbeTangent,   RayDirection),
                dot(ProbeBitangent, RayDirection),
                dot(Header.Normal,  RayDirection)
            );
            if(LocalRayDirection.z > 0) {
                float2 OctahedronUV = UnitVectorToHemiOctahedron01(LocalRayDirection);
                int2 OctahedronTexelCoords = clamp(int2(
                    int(OctahedronUV.x * SSRC_PROBE_TEXTURE_SIZE),
                    int(OctahedronUV.y * SSRC_PROBE_TEXTURE_SIZE)
                    ), 0, SSRC_PROBE_TEXTURE_SIZE - 1);
                int  OctahedronTexelIndex = OctahedronTexelCoords.y * SSRC_PROBE_TEXTURE_SIZE + OctahedronTexelCoords.x;
                LocalEvaluatedRadiance[RayRank] += LocalProbeTexels[OctahedronTexelIndex];
            }
        }
    }
    // Barrier updates on LocalEvaluatedRadiance
    GroupMemoryBarrierWithGroupSync();
    // 2.Update the SG direction first 
    [branch]
    if(MI.CacheUpdate_SGDirection) {
        float3 SumDirection = 0.f;
        // Pick one basis to update direction
        int BasisRankToUpdate = GetBasisRankToUpdate(BasisCount);
        SGData SG_D = LocalSGData[BasisRankToUpdate];
        SGData SG_O;
        [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
        for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
            int RayRank = RayRankBase + LocalID;
            int RayIndex = ProbeRayOffset + RayRank;
            float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
            float3 RayDirection      = FetchUpdateRayDirection(RayIndex);
            float3 RayRadiance       = RayRadianceInvPdf.xyz;
            float  InvPdf            = RayRadianceInvPdf.w;
            if(InvPdf > 0) {
                float  SGEvaluatedRaw      = EvaluateSGRaw(SG_D, RayDirection);
                float3 SGEvaluatedRadiance = SGEvaluatedRaw * SG_D.Color;
                // Clamp DiffRadiance to prevent "direction chasing" when the direction of a basis is updated
                // but its color is not converged to the correct result yet.
                float3 DiffRadianceClamped = max(RayRadiance - LocalEvaluatedRadiance[RayRank], 0.f);
                float3 TargetRadiance = DiffRadianceClamped + SGEvaluatedRadiance;
                float  RadianceWeight    = MI.SquaredSGDirectionalRadianceWeight ? dot(TargetRadiance, TargetRadiance) : dot(TargetRadiance, 1.f.xxx);
                // The weight for balancing sample distribution
                float  SampleWeight      = InvPdf;
                // 0529: Add a bias to reserve affection for closer light sources in the same direction
                float DirectionBias = HeuristicSGDirectionBias(SG_D.Direction, RayDirection);
                // Decay if it is closer to other SGs
                float Coverage = max(LocalRayCoverage[RayRank], Epsilon);
                float DirectionDecay =  pow(DirectionBias / Coverage, 6);
                float TotalWeight = RadianceWeight * SampleWeight * DirectionDecay;
                SumDirection  += RayDirection * TotalWeight;
            }
        }
        // Accumulate and normalize
        SumDirection = WaveActiveSum(SumDirection);
        if(dot(SumDirection, SumDirection) > 1e-6f) {
            float3 TargetDirection = normalize(SumDirection);
            // float  SrcWeight = SGIntegrate(SG_D.Lambda) * dot(SG_D.Color, 1.f.xxx) + Epsilon;
            // float  DstWeight = SumTotalWeight + Epsilon;
            // float  T = SrcWeight / (SrcWeight + DstWeight);
            float T = 0.15f;
            SG_O = SG_D;
            SG_D.Direction = normalize(lerp(SG_D.Direction, TargetDirection, T));//InterpolateDirection(SG_D.Direction, TargetDirection, T);
            if(WaveIsFirstLane()) {
                LocalSGData[BasisRankToUpdate] = SG_D;
            }
            // Re-calculate the evaluated radiance for the changed basis
            [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
            for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
                int RayRank  = RayRankBase + LocalID;
                int RayIndex = ProbeRayOffset + RayRank;
                float3 RayDirection      = FetchUpdateRayDirection(RayIndex);
                float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
                float3 RayRadiance       = RayRadianceInvPdf.xyz;
                float  InvPdf            = RayRadianceInvPdf.w;
                if(InvPdf > 0) {
                    float  RawPrevious = EvaluateSGRaw(SG_O, RayDirection);
                    float  Raw         = EvaluateSGRaw(SG_D, RayDirection);
                    float3 Delta = Raw * SG_D.Color - RawPrevious * SG_O.Color;
                    LocalEvaluatedRadiance[RayRank] += Delta;
                }
            }
        }
        GroupMemoryBarrierWithGroupSync();
    }

    // Update Color and Lambda

    int ThreadPerBasis = WAVE_SIZE / BasisCount;
    int BasisRank      = LocalID / ThreadPerBasis;
    int BasisThread    = LocalID % ThreadPerBasis;

    if(BasisRank < BasisCount) {
        SGData SG = LocalSGData[BasisRank];
        SGGradients SumStepSize = (SGGradients)0;
#ifdef OPTIMAL_COLOR_UPDATE
        float  SumAFactor = 0;
#endif
        [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
        for(int RayGroupOffset = 0; RayGroupOffset < ProbeRayCount; RayGroupOffset += ThreadPerBasis) {
            int RayRank = RayGroupOffset + BasisThread;
            if(RayRank < ProbeRayCount) {
                int RayIndex = ProbeRayOffset + RayRank;
                float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
                float  RayLinearDepth    = g_RWUpdateRayLinearDepthBuffer[RayIndex];
                float3 RayDirection      = FetchUpdateRayDirection(RayIndex);
                float3 RayRadiance       = RayRadianceInvPdf.xyz;
                float  InvPdf            = RayRadianceInvPdf.w;
                if(InvPdf > 0) {
                    float  SGEvaluatedRaw      = EvaluateSGRaw(SG, RayDirection);
                    float3 SGEvaluatedRadiance = SGEvaluatedRaw * SG.Color;

                    float3 dColorExtra;
                    SGGradients Gradients;
                    EvaluateSG_Gradients(SG, RayDirection, Gradients, dColorExtra);
                    float3 DiffRadiance   = RayRadiance - LocalEvaluatedRadiance[RayRank];
                    // TODO
                    // This should be done in multi pass actually to avoid explosive radiance update
                    float3 TargetRadiance = DiffRadiance + SGEvaluatedRadiance;
                    float3 X = -2.f * DiffRadiance;
                    float  Y = dot(X, 1.f.xxx);

                    // The weight for balancing sample distribution
                    float  SampleWeight     = InvPdf;
#ifndef OPTIMAL_COLOR_UPDATE
                    SumStepSize.dColor     -= X * Gradients.dColor     * SampleWeight;
#else
                    // least squares method
                    // Clip rays that only evaluates to a tiny value on SG to prevent outflares
                    if(SGEvaluatedRaw > 1e-2f || dot(TargetRadiance, 1.f.xxx) < dot(SGEvaluatedRadiance, 1.f.xxx)) {
                        SumAFactor                += 2.f * SGEvaluatedRaw * SGEvaluatedRaw * SampleWeight;
                        SumStepSize.dColor        += 2.f * TargetRadiance * SGEvaluatedRaw * SampleWeight;
                    }
#endif
                    // 0529: Add a bias to reserve affection for closer light sources in the same direction
                    float  HeuristicBias = HeuristicSGDirectionBias(SG.Direction, RayDirection);
                    float  DirectionalDecay  = 1.f;//pow(HeuristicBias / LocalRayCoverage[RayRank], 6);
                    SumStepSize.dLambda    -= Y * Gradients.dLambda    * SampleWeight * DirectionalDecay;
                }
            }
        }
        // Accumulate weights
#ifdef OPTIMAL_COLOR_UPDATE
        LocalAFactorSum[LocalID] = WavePrefixSum(SumAFactor);
#endif
        LocalDColorPrefixSum[LocalID]     = WavePrefixSum(SumStepSize.dColor);
        LocalDLambdaPrefixSum[LocalID]    = WavePrefixSum(SumStepSize.dLambda);
        GroupMemoryBarrierWithGroupSync();
        // The chosen thread for updating each basis
        if(BasisThread == ThreadPerBasis - 1) {
            // Accumulate and normalize
#ifdef OPTIMAL_COLOR_UPDATE
            SumAFactor = SumAFactor + LocalAFactorSum[LocalID] - LocalAFactorSum[LocalID - ThreadPerBasis + 1];
#endif
            SumStepSize.dColor        = SumStepSize.dColor + LocalDColorPrefixSum[LocalID] - LocalDColorPrefixSum[LocalID - ThreadPerBasis + 1];
            SumStepSize.dLambda       = SumStepSize.dLambda + LocalDLambdaPrefixSum[LocalID] - LocalDLambdaPrefixSum[LocalID - ThreadPerBasis + 1];
#ifdef OPTIMAL_COLOR_UPDATE
            // It's possible for SumAFactor to be very tiny (because of large SG Lambdas), so we clamp it to prevent outflares
            SumStepSize.dColor     /= max(SumAFactor, Epsilon);
#else       
            SumStepSize.dColor     /= ProbeRayCount;
#endif

            if(MI.CacheUpdate_SGColor) {
#ifdef OPTIMAL_COLOR_UPDATE
                // TODO Clamping is not the smartest choice for outflares
                // it relates to lambda and importance sampling
                float Factor =  min(MI.CacheUpdateLearningRate + ImpactFactors.x, 1.f);
                // Allow the color of the SG with updated direction to change violently
                // if(MI.CacheUpdate_SGDirection && BasisRank == GetBasisRankToUpdate(BasisCount)) {
                //     Factor = max(Factor, 0.2f);
                // }
                float3 NewColor = lerp(SG.Color, SumStepSize.dColor, Factor);
                float3 DeltaColor = NewColor - SG.Color;
                SG.Color += DeltaColor;
#else
                SG.Color += SumStepSize.dColor      * MI.CacheUpdateLearningRate * (1 + ImpactFactors.x);
#endif
                SG.Color = max(SG.Color, 0.0001f.xxx); // Color is in [0.001, inf)
            }
            if(MI.CacheUpdate_SGLambda) {
                float Step = SumStepSize.dLambda    * MI.CacheUpdateLearningRate * (1 + ImpactFactors.z);
                // FIXME better lambda update
                // if(Step > 0.f) SG.Lambda *= 1.03f;
                // else if(Step < 0.f) SG.Lambda *= 0.97f;
                SG.Lambda    += Step;
                SG.Lambda    = clamp(SG.Lambda, 5.f, 200.f); // Lambda is in [5.f, 200.f]
            }
            // FIXME SG depth is never updated

            // Write back
            WriteBasisData(Header.BasisOffset + BasisRank, SG);
        }
    }
}

// From Lumen
float GetFilterPositionWeight(float NeighborLinearDepth, float LinearDepth)
{
	float DepthDifference = abs(NeighborLinearDepth - LinearDepth);
	float RelativeDepthDifference = DepthDifference / LinearDepth;
	return exp2(-1000.f * (RelativeDepthDifference * RelativeDepthDifference));
}

void GatherProbeRadiance (
    float3 Position,
    float  LinearDepth,
    float3 HitPosition,
    int2   NeighborProbeIndex,
    inout float3 SumRadiance,
    inout float  SumWeight
) {
    if(all(NeighborProbeIndex >= 0) && all(NeighborProbeIndex < MI.TileDimensions)) {
        float NeighborLinearDepth = GetScreenProbeLinearDepth(NeighborProbeIndex);
        if(NeighborLinearDepth > 0) { // Valid
            float PositionWeight = GetFilterPositionWeight(NeighborLinearDepth, LinearDepth);
            if(PositionWeight > 0) {
                float3 NeighborWorldPosition = GetScreenProbePosition(NeighborProbeIndex);
                float3 ToNeighbor = HitPosition - NeighborWorldPosition;
                float  ToNeighborLength = max(length(ToNeighbor), 1e-3f);
                float3 ToNeighborUnit = ToNeighbor / ToNeighborLength;
                float3 NeighborProbeNormal = GetScreenProbeNormal(NeighborProbeIndex);
                float3 Tangent, Bitangent;
                GetOrthoVectors(NeighborProbeNormal, Tangent, Bitangent);
                float3 NeighborProbeLocalDirection = float3(
                    dot(Tangent,   ToNeighborUnit),
                    dot(Bitangent, ToNeighborUnit),
                    dot(NeighborProbeNormal, ToNeighborUnit)
                );
                if(NeighborProbeLocalDirection.z > 0) {
                    float2 NeighborProbeUV = UnitVectorToHemiOctahedron01(NeighborProbeLocalDirection);
                    int2   NeighborTexelCoords = clamp(NeighborProbeUV * SSRC_PROBE_TEXTURE_SIZE, 0, SSRC_PROBE_TEXTURE_SIZE - 1);
                    float4 NeighborRadianceDepth = GetScreenProbeOctahedronRadianceDepth(NeighborProbeIndex, NeighborTexelCoords);
                    float3 NeighborRadiance = NeighborRadianceDepth.xyz;
                    float  NeighborDepth = NeighborRadianceDepth.w;
                    float  DepthWeight = 1 - abs(NeighborDepth - ToNeighborLength) / max(1e-3f, max(NeighborDepth, ToNeighborLength));
                    DepthWeight = pow(saturate(DepthWeight), 6);
                    float  Weight = PositionWeight * DepthWeight;
                    SumRadiance += NeighborRadiance * Weight;
                    SumWeight   += Weight;
                }
            }
        }
    }
    
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_FilterProbes (int GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {

    int2 ProbeIndex = int2(GroupID % MI.TileDimensions.x, GroupID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    // Thread group early out if the probe is not valid
    [branch]
    if(!Header.bValid) return ;
    
    int2 ProbeScreenCoords  = Header.ScreenCoords;
    int2 TileIndex = int2(ProbeScreenCoords / SSRC_TILE_SIZE);
    float  ReprojectionTrust = g_RWProbeHistoryTrustTexture[ProbeIndex].x;

    float3 Tangent, Bitangent;
    GetOrthoVectors(Header.Normal, Tangent, Bitangent);

    float3 SH_Coefficients[9];
    for(int i = 0; i < 9; i++) {
        SH_Coefficients[i] = 0.f;
    }

    for(int BaseProbeTexelIndex = 0; BaseProbeTexelIndex < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseProbeTexelIndex += WAVE_SIZE) {
        int  ProbeTexelIndex = BaseProbeTexelIndex + LocalID;
        int2 ProbeTexelCoords = int2(ProbeTexelIndex % SSRC_PROBE_TEXTURE_SIZE, ProbeTexelIndex / SSRC_PROBE_TEXTURE_SIZE);
        float2 ProbeTexelUV = (ProbeTexelCoords + 0.5f) / SSRC_PROBE_TEXTURE_SIZE;
        float3 ProbeLocalTexelDirection = HemiOctahedron01ToUnitVector(ProbeTexelUV);
        float3 ProbeWorldTexelDirection = 
            Tangent * ProbeLocalTexelDirection.x 
          + Bitangent * ProbeLocalTexelDirection.y
          + Header.Normal * ProbeLocalTexelDirection.z;
        float4  TexelRadianceDepth = GetScreenProbeOctahedronRadianceDepth(ProbeIndex, ProbeTexelCoords);
        float3 HitPosition = Header.Position + ProbeWorldTexelDirection * TexelRadianceDepth.w;

        float3 SumRadiance = TexelRadianceDepth.xyz;
        float  SumWeight = 1.f;

        if(MI.ProbeFiltering) {
            int2 Offsets[4];
            Offsets[0] = int2(-1, 0);
            Offsets[1] = int2(1, 0);
            Offsets[2] = int2(0, -1);
            Offsets[3] = int2(0, 1);
            for (uint OffsetIndex = 0; OffsetIndex < 4; OffsetIndex++)
            {
                GatherProbeRadiance(
                    Header.Position,
                    Header.LinearDepth,
                    HitPosition,
                    TileIndex + Offsets[OffsetIndex],
                    SumRadiance,
                    SumWeight
                );
            }
        }

        if(MI.ProbeFiltering && ReprojectionTrust < 0.8f) {
            int2 Offsets[8];
            Offsets[0] = int2(-2, 0);
            Offsets[1] = int2(2, 0);
            Offsets[2] = int2(0, -2);
            Offsets[3] = int2(0, 2);
            Offsets[4] = int2(-1, 1);
            Offsets[5] = int2(1, 1);
            Offsets[6] = int2(-1, -1);
            Offsets[7] = int2(1, -1);
            for (uint OffsetIndex = 0; OffsetIndex < 8; OffsetIndex++)
            {
                GatherProbeRadiance(
                    Header.Position,
                    Header.LinearDepth,
                    HitPosition,
                    TileIndex + Offsets[OffsetIndex],
                    SumRadiance,
                    SumWeight
                );
            }
        }
    
        float3 NewRadiance = SumRadiance / SumWeight;
        float4 NewRadianceDepth = float4(NewRadiance, TexelRadianceDepth.w);
        WriteScreenProbeOctahedronRadianceDepth(ProbeIndex, ProbeTexelCoords, NewRadianceDepth, true);

        // Accumulate SH coefficients
        float  Coefficients[9];
        SH_GetCoefficients(ProbeWorldTexelDirection, Coefficients);
        for(int i = 0; i < 9; i++) {
            SH_Coefficients[i] += Coefficients[i] * NewRadiance;
        }
    }

    // Write SH coefficients
    for(int i = 0; i<9; i++) {
        // Multiply by TWO_PI to monte-carlo integrate to retrieve the coefficients
        // (TWO_PI: Hemispherical integration)
        SH_Coefficients[i] = WaveActiveSum(SH_Coefficients[i]) * (1.f / SSRC_PROBE_TEXTURE_TEXEL_COUNT) * TWO_PI;
    }
    if(WaveIsFirstLane()) {
        WriteScreenProbeSHCoefficients(ProbeIndex, SH_Coefficients);
    }
    // TODO filter SG

}


[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_PadProbeTextureEdges (int GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {

    int2 ProbeIndex = int2(GroupID % MI.TileDimensions.x, GroupID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    // Thread group early out if the probe is not valid
    [branch]
    if(!Header.bValid) return ;
    int2 BaseSrcTexCoords = ProbeIndex * SSRC_PROBE_TEXTURE_SIZE;
    int2 BaseDstTexCoords = ProbeIndex * (SSRC_PROBE_TEXTURE_SIZE + 2);
    
    if(LocalID < SSRC_PROBE_TEXTURE_SIZE + 2) {
        g_RWProbeSampleColorTexture[BaseDstTexCoords + int2(LocalID, 0)] = g_RWProbeColorTexture[BaseSrcTexCoords + int2(clamp(LocalID - 1, 0, SSRC_PROBE_TEXTURE_SIZE - 1), 0)];
        g_RWProbeSampleColorTexture[BaseDstTexCoords + int2(LocalID, SSRC_PROBE_TEXTURE_SIZE + 1)] = g_RWProbeColorTexture[BaseSrcTexCoords + int2(clamp(LocalID - 1, 0, SSRC_PROBE_TEXTURE_SIZE - 1), SSRC_PROBE_TEXTURE_SIZE - 1)];
    }
    if(LocalID < SSRC_PROBE_TEXTURE_SIZE) {
        g_RWProbeSampleColorTexture[BaseDstTexCoords + int2(0, LocalID + 1)] = g_RWProbeColorTexture[BaseSrcTexCoords + int2(0, LocalID)];
        g_RWProbeSampleColorTexture[BaseDstTexCoords + int2(SSRC_PROBE_TEXTURE_SIZE + 1, LocalID + 1)] = g_RWProbeColorTexture[BaseSrcTexCoords + int2(SSRC_PROBE_TEXTURE_SIZE - 1, LocalID)];
    }
    for(int BaseTexelRank = 0; BaseTexelRank < SSRC_PROBE_TEXTURE_TEXEL_COUNT; BaseTexelRank += WAVE_SIZE) {
        int TexelRank = BaseTexelRank + LocalID;
        int2 TexelCoords = int2(TexelRank % SSRC_PROBE_TEXTURE_SIZE, TexelRank / SSRC_PROBE_TEXTURE_SIZE);
        int2 SrcTexCoords = BaseSrcTexCoords + TexelCoords;
        int2 DstTexCoords = BaseDstTexCoords + TexelCoords + 1.xx;
        g_RWProbeSampleColorTexture[DstTexCoords] = g_RWProbeColorTexture[SrcTexCoords];
    }
}

void GetScreenProbeSHCoefficients (int2 ProbeIndex, out float3 ProbeSH[9]) {
    float4 R1 = g_RWProbeSHCoefficientsRTexture[ProbeIndex];
    float4 R2 = g_RWProbeSHCoefficientsRTexture[ProbeIndex + int2(MI.TileDimensions.x, 0)];
    float4 G1 = g_RWProbeSHCoefficientsGTexture[ProbeIndex];
    float4 G2 = g_RWProbeSHCoefficientsGTexture[ProbeIndex + int2(MI.TileDimensions.x, 0)];
    float4 B1 = g_RWProbeSHCoefficientsBTexture[ProbeIndex];
    float4 B2 = g_RWProbeSHCoefficientsBTexture[ProbeIndex + int2(MI.TileDimensions.x, 0)];
    float3 RGB0 = g_RWProbeIrradianceTexture[ProbeIndex].xyz;
    ProbeSH[0] = RGB0;
    ProbeSH[1] = float3(R1.x, G1.x, B1.x);
    ProbeSH[2] = float3(R1.y, G1.y, B1.y);
    ProbeSH[3] = float3(R1.z, G1.z, B1.z);
    ProbeSH[4] = float3(R1.w, G1.w, B1.w);
    ProbeSH[5] = float3(R2.x, G2.x, B2.x);
    ProbeSH[6] = float3(R2.y, G2.y, B2.y);
    ProbeSH[7] = float3(R2.z, G2.z, B2.z);
    ProbeSH[8] = float3(R2.w, G2.w, B2.w);
}

// Modified from GI1.0
// Evaluates the irradiance from the probe's SH representation using a bent cone.
float3 ProbeIntegrateBentCone(float3 normal, float ao, int2 ProbeIndex)
{
    float ClampedCosineSH[9];
    SH_GetCoefficients_ClampedCosine_Cone(normal, acos(sqrt(saturate(1.0f - ao))), ClampedCosineSH);

    float3 irradiance = float3(0.0f, 0.0f, 0.0f);
    float3 ProbeSH[9];
    GetScreenProbeSHCoefficients(ProbeIndex, ProbeSH);
    for (uint i = 0; i < 9; ++i)
    {
        irradiance += ClampedCosineSH[i] * ProbeSH[i];
    }

    return max(irradiance, 0.0f);
}

float4 SampleScreenProbeRadianceDepth (int2 ProbeIndex, float3 LocalDirection) {
    float2 TexelPosition = SSRC_PROBE_TEXTURE_SIZE * UnitVectorToHemiOctahedron01(LocalDirection);
    float2 AtlasPosition = TexelPosition + ProbeIndex * (SSRC_PROBE_TEXTURE_SIZE + 2) + 1.xx;
    uint2  Dimensions;
    g_ProbeSampleColorTexture.GetDimensions(Dimensions.x, Dimensions.y);
    float2 AtlasUV = AtlasPosition / Dimensions;
    return g_ProbeSampleColorTexture.SampleLevel(g_LinearSampler, AtlasUV, 0);
}


[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_IntegrateASG (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * MI.TileDimensions.x;
    int2 TileTextureBaseOffset = int2(GroupID) * SSRC_TILE_SIZE;
    const int PIXEL_PER_THREAD = SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE;
    Random rng = MakeRandom(TileID, LocalID);
    for(int i = 0; i< PIXEL_PER_THREAD; i++) {
        int PixelIndex = i * WAVE_SIZE + LocalID;
        // Operate in subtiles (8x8) to get better coherency in loop branching
        // with the more likely the same number of basis to access for each thread
        int SubtileIndex  = PixelIndex / (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int SubPixelIndex = PixelIndex % (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int PixelX = (SSRC_TILE_SIZE/2) * (SubtileIndex % 2) + SubPixelIndex % (SSRC_TILE_SIZE/2);
        int PixelY = (SSRC_TILE_SIZE/2) * (SubtileIndex / 2) + SubPixelIndex / (SSRC_TILE_SIZE/2);
        int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
        float2 UV = (TexCoords + 0.5f) / MI.ScreenDimensions;
        float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
        if(Depth < 1.f) {
            float LinearDepth   = GetLinearDepth(Depth);
            // Texture coordinates
            float4 Visibility   = g_VisibilityTexture[TexCoords];
            float2 Barycentrics = Visibility.xy;
            uint   InstanceID   = asuint(Visibility.z);
            uint   PrimitiveID  = asuint(Visibility.w);

            Instance InstanceData = g_InstanceBuffer[InstanceID];
            Mesh     mesh     = g_MeshBuffer[InstanceData.mesh_index];

            Triangle vertices = fetchVertices(mesh, PrimitiveID);

            // Reconstruct world space position from barycentrics
            float3x4 transform = g_TransformBuffer[InstanceData.transform_index];
            vertices.v0 = transformPoint(vertices.v0, transform);
            vertices.v1 = transformPoint(vertices.v1, transform);
            vertices.v2 = transformPoint(vertices.v2, transform);

            // Frame
            float3 WorldPosition = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);
            float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
            float3 ShadingNormal  = normalize(2.f * g_ShadingNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);

            UVs PrimitiveUVs = fetchUVs(g_MeshBuffer[InstanceData.mesh_index], PrimitiveID);
            float2 MeshUV = interpolate(PrimitiveUVs.uv0, PrimitiveUVs.uv1, PrimitiveUVs.uv2, Barycentrics);
            Material MaterialData = g_MaterialBuffer[InstanceData.material_index];
            MaterialEmissive EmissiveMaterialData = MakeMaterialEmissive(MaterialData, MeshUV);
            MaterialBRDF MaterialBRDFData = MakeMaterialBRDF(MaterialData, MeshUV);
            
            float3 ViewDirection = normalize(MI.CameraPosition - WorldPosition);
            float DotNV = saturate(dot(ShadingNormal, ViewDirection));

            SSRC_SampleData Sample;
            CalculateSSRCSampleWeights(
                TexCoords + 0.5f,
                WorldPosition,
                LinearDepth, 
                GeometryNormal,
                true,
                Sample
            );

            ProbeHeader Headers[4];
            Headers[0] = GetScreenProbeHeader(Sample.Index[0]);
            Headers[1] = GetScreenProbeHeader(Sample.Index[1]);
            Headers[2] = GetScreenProbeHeader(Sample.Index[2]);
            Headers[3] = GetScreenProbeHeader(Sample.Index[3]);
            float3 ProbeTangents[4];
            float3 ProbeBitangents[4];
            for(int i = 0; i < 4; i++) {
                GetOrthoVectors(Headers[i].Normal, ProbeTangents[i], ProbeBitangents[i]);
            }
            int BasisCounts[4];
            BasisCounts[0] = GetProbeBasisCountFromClass(Headers[0].Class);
            BasisCounts[1] = GetProbeBasisCountFromClass(Headers[1].Class);
            BasisCounts[2] = GetProbeBasisCountFromClass(Headers[2].Class);
            BasisCounts[3] = GetProbeBasisCountFromClass(Headers[3].Class);
            int BasisCount0 = BasisCounts[0] + BasisCounts[1];
            int BasisCount1 = BasisCounts[2] + BasisCounts[3];
            int BasisCount  = BasisCount0 + BasisCount1;
            // Normalize weights
            Sample.Weights /= max(dot(Sample.Weights, 1.f.xxxx), 0.01f);
            if(dot(Sample.Weights, 1.f.xxxx) > 0.99f) {
                // Lighting is split into 3 parts:
                // 1. High frequency incident radiance + all frequency BSDF (ASG integration with SG radiance cache)
                // 2. Low frequency incident radiance + diffuse BSDF  (probe octahedron radiance cache)
                // 3. Low frequency incident radiance + specular BSDF (specular ray tracing)

                float  AO = MI.UseAmbientOcclusion 
                    ? g_BentNormalAndOcclusionTexture.Load(int3(TexCoords, 0)).w
                    : 1.f;
                float3 ReflectionDirection = calculateGGXSpecularDirection(ShadingNormal, ViewDirection, sqrt(MaterialBRDFData.roughnessAlpha));
                float3 HalfVector_Spec = normalize(ReflectionDirection + ViewDirection);
                float dotSpecHV = saturate(dot(HalfVector_Spec, ViewDirection));
                // Approximate the Fresnel term with the ReflectionDirection as light direction
                // which is the same approximation used by GI1.0
                float3 FresnelTerm = fresnel(MaterialBRDFData.F0, dotSpecHV);
                float3 DiffuseCompensation = diffuseCompensationTerm(FresnelTerm, dotSpecHV);

                float3 HighFreq_Diffuse = 0.f.xxx;
                float3 HighFreq_Glossy  = 0.f.xxx;
                // HighFreq-AllFreq shading
                [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
                for(int BasisRank = 0; BasisRank < BasisCount; BasisRank++) {
                    int ProbeRank, ProbeBasisIndex;
                    if(BasisRank < BasisCount0) {
                        ProbeRank = BasisRank < BasisCounts[0] ? 0 : 1;
                        ProbeBasisIndex = BasisRank - (BasisRank < BasisCounts[0] ? 0 : BasisCounts[0]);
                    } else {
                        ProbeBasisIndex = BasisRank - BasisCount0;
                        ProbeRank = ProbeBasisIndex < BasisCounts[2] ? 2 : 3;
                        ProbeBasisIndex -= (ProbeBasisIndex < BasisCounts[2] ? 0 : BasisCounts[2]);
                    }
                    int BasisIndex = Headers[ProbeRank].BasisOffset + ProbeBasisIndex;
                    SGData SG = FetchBasisData(BasisIndex);
                    float3 LightDirection = SG.Direction;                    
                    float3 HalfVector = normalize(LightDirection + ViewDirection);
                    float dotNL = saturate(dot(LightDirection, ShadingNormal));
                    float dotNV = saturate(dot(ShadingNormal, ViewDirection));
                    float dotHV = saturate(dot(HalfVector, ViewDirection));
                    // Approximate \int D * Li with ASG
                    // we use RoughnessAlpha here
                    float3 GGX_D_Li_Approx = SpecularTermASGWarp(SG, ShadingNormal, MaterialBRDFData.roughnessAlphaSqr, ViewDirection);
                    float  VisibilityTerm   = evaluateVisibilityGGX(MaterialBRDFData.roughnessAlphaSqr, dotNL, dotNV);
                    float3 GGXIntegrationApprox = (FresnelTerm / VisibilityTerm) * GGX_D_Li_Approx;
                    // Albedo is later applied for diffuse lighting
                    float3 Irradiance = SGIrradianceInnerProduct(SG, ShadingNormal);
                    HighFreq_Diffuse += Irradiance           * Sample.Weights[ProbeRank] * AO;
                    HighFreq_Glossy  += GGXIntegrationApprox * Sample.Weights[ProbeRank] * AO;
                }
                // LowFreq-Diffuse shading
                float3 LowFreq_Diffuse = 0.f.xxx;
                [unroll(4)]
                for(int CornerIndex = 0; CornerIndex < 4; CornerIndex ++) {
                    if(Sample.Weights[CornerIndex] > 0.f) { 
                        float3 Irradiance = ProbeIntegrateBentCone(ShadingNormal, AO, Sample.Index[CornerIndex]);
                        float3 WeightedIrradiance = Irradiance * Sample.Weights[CornerIndex];
                        LowFreq_Diffuse += WeightedIrradiance * AO;
                    }
                }
                
                float3 LowFreq_Specular = 0.f.xxx;
                // Use radiance values from probes directly for low frequency specular
#if false
                float2 LUT = g_LutBuffer.SampleLevel(g_LinearSampler, float2(saturate(dot(ShadingNormal, ViewDirection)), sqrt(MaterialBRDFData.roughnessAlpha)), 0.0f).xy;
                float3 SpecularAlbedo = saturate(MaterialBRDFData.F0 * LUT.x + (1.0f - MaterialBRDFData.F0) * LUT.y);
                
                [unroll(4)]
                for(int SampleIndex = 0; SampleIndex < 4; SampleIndex++) {
                    float2 u2 = rng.rand2();
                    Quaternion LocalRotation = QuaternionRotationZ(ShadingNormal);
                    float3 LocalViewDirection = LocalRotation.transform(ViewDirection);
                    float  ClampedRA = max(0.000001f, MaterialBRDFData.roughnessAlpha);
                    float3 LocalSampleDirection = sampleGGX(ClampedRA, LocalViewDirection, u2);
                    float3 SampleDirection = normalize(LocalRotation.inverse().transform(LocalSampleDirection));
                    for(int CornerIndex = 0; CornerIndex < 4; CornerIndex ++) {
                        if(Sample.Weights[CornerIndex] > 0.f) {
                            convert sample direction!!!
                            float3 Radiance = SampleScreenProbeRadiance(Sample.Index[CornerIndex], SampleDirection);
                            LowFreq_Specular += Radiance * Sample.Weights[CornerIndex];
                        }
                    }
                }
                LowFreq_Specular = SpecularAlbedo * LowFreq_Specular;
#else
                
                float2 LUT = g_LutBuffer.SampleLevel(g_LinearSampler, float2(saturate(dot(ShadingNormal, ViewDirection)), sqrt(MaterialBRDFData.roughnessAlpha)), 0.0f).xy;
                float3 SpecularAlbedo = saturate(MaterialBRDFData.F0 * LUT.x + (1.0f - MaterialBRDFData.F0) * LUT.y);
                
                for(int CornerIndex = 0; CornerIndex < 4; CornerIndex ++) {
                    if(Sample.Weights[CornerIndex] > 0.f) {
                        float3 LocalReflectionDirection = float3(
                            dot(ProbeTangents[CornerIndex],   ReflectionDirection),
                            dot(ProbeBitangents[CornerIndex], ReflectionDirection),
                            dot(Headers[CornerIndex].Normal, ReflectionDirection)
                        );
                        if(LocalReflectionDirection.z > 0.f) {
                            float4 RadianceDepth = SampleScreenProbeRadianceDepth(Sample.Index[CornerIndex], LocalReflectionDirection);
                            // Fade specular radiance near occlusions to give more accurate reflections
                            float  DistanceFade  = RadianceDepth.w / max(1e-3f, Headers[CornerIndex].LinearDepth);
                            DistanceFade = saturate(DistanceFade * DistanceFade);
                            LowFreq_Specular += RadianceDepth.xyz * DistanceFade * Sample.Weights[CornerIndex];
                        }
                    }
                }
                LowFreq_Specular = SpecularAlbedo * LowFreq_Specular;

#endif

                // Composite final lighting
                float3 FarFieldIrradiance  = (HighFreq_Diffuse + LowFreq_Diffuse) * DiffuseCompensation;
                float3 NearFieldIrradiance = MI.UseNearFieldGI 
                    ? g_NearFieldGlobalIlluminationTexture.Load(int3(TexCoords, 0)).xyz
                    : 0.f;
                float3 FarFieldGlossySpecular = (HighFreq_Glossy + LowFreq_Specular) * AO;

                // Write to output                
                g_RWIrradianceTexture[TexCoords] = float4(FarFieldIrradiance + NearFieldIrradiance,  1.f);
                g_RWGlossySpecularTexture[TexCoords] = float4(FarFieldGlossySpecular, 1.f);
            } else {
                g_RWIrradianceTexture[TexCoords] = float4(0.f, 0.f, 0.f, 0.f);
                g_RWGlossySpecularTexture[TexCoords] = float4(0.f, 0.f, 0.f, 0.f);
            }
        } else {
            g_RWIrradianceTexture[TexCoords] = float4(0.f, 0.f, 0.f, 0.f);
            g_RWGlossySpecularTexture[TexCoords] = float4(0.f, 0.f, 0.f, 0.f);
        }
    }
}

#define MAX_TEMPORAL_ACCUMULATION 10

// https://www.gdcvault.com/play/1022970/Temporal-Reprojection-Anti-Aliasing-in
float2 GetClosestVelocity(in float2 uv, in float2 texel_size, out bool is_sky_pixel)
{
    float2 velocity;
    float  closest_depth = 9.9f;

    for (int y = -1; y <= 1; ++y)
    {
        for (int x = -1; x <= 1; ++x)
        {
            float2 st    = uv + float2(x, y) * texel_size;
            float  depth = g_DepthTexture.SampleLevel(g_NearestSampler, st, 0.0f).x;

            if (depth < closest_depth)
            {
                velocity      = g_VelocityTexture.SampleLevel(g_NearestSampler, st, 0.0f).xy;
                closest_depth = depth;
            }
        }
    }

    is_sky_pixel = (closest_depth >= 1.0f);

    return velocity;
}

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_Denoise (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * MI.TileDimensions.x;
    int2 TileTextureBaseOffset = int2(GroupID) * SSRC_TILE_SIZE;
    const int PIXEL_PER_THREAD = SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE;
    for(int i = 0; i< PIXEL_PER_THREAD; i++) {
        int PixelIndex = i * WAVE_SIZE + LocalID;
        // Operate in subtiles (8x8)
        int SubtileIndex  = PixelIndex / (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int SubPixelIndex = PixelIndex % (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int PixelX = (SSRC_TILE_SIZE/2) * (SubtileIndex % 2) + SubPixelIndex % (SSRC_TILE_SIZE/2);
        int PixelY = (SSRC_TILE_SIZE/2) * (SubtileIndex / 2) + SubPixelIndex / (SSRC_TILE_SIZE/2);
        int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
        float2 UV = (TexCoords + 0.5f) / MI.ScreenDimensions;
        float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
        if(Depth < 1.f) {
            float LinearDepth   = GetLinearDepth(Depth);
            // Texture coordinates
            float4 Visibility   = g_VisibilityTexture[TexCoords];
            float2 Barycentrics = Visibility.xy;
            uint   InstanceID   = asuint(Visibility.z);
            uint   PrimitiveID  = asuint(Visibility.w);

            Instance InstanceData = g_InstanceBuffer[InstanceID];
            Mesh     mesh     = g_MeshBuffer[InstanceData.mesh_index];

            Triangle vertices = fetchVertices(mesh, PrimitiveID);

            // Reconstruct world space position from barycentrics
            float3x4 transform = g_TransformBuffer[InstanceData.transform_index];
            vertices.v0 = transformPoint(vertices.v0, transform);
            vertices.v1 = transformPoint(vertices.v1, transform);
            vertices.v2 = transformPoint(vertices.v2, transform);

            // Frame
            float3 WorldPosition = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);
            float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
            float3 ShadingNormal  = normalize(2.f * g_ShadingNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);

            UVs PrimitiveUVs = fetchUVs(g_MeshBuffer[InstanceData.mesh_index], PrimitiveID);
            float2 MeshUV = interpolate(PrimitiveUVs.uv0, PrimitiveUVs.uv1, PrimitiveUVs.uv2, Barycentrics);
            Material MaterialData = g_MaterialBuffer[InstanceData.material_index];
            MaterialEmissive EmissiveMaterialData = MakeMaterialEmissive(MaterialData, MeshUV);
            MaterialBRDF MaterialBRDFData = MakeMaterialBRDF(MaterialData, MeshUV);
            
            float3 ViewDirection = normalize(MI.CameraPosition - WorldPosition);

            
            float4 NewIrradianceW    = g_RWIrradianceTexture[TexCoords];
            float3 NewGlossySpecular = g_RWGlossySpecularTexture[TexCoords].xyz;
            float3 NewIrradiance     = NewIrradianceW.xyz;
            float  NewLightingValid  = NewIrradianceW.w;
            float3 HistoryIrradiance = 0.f;
            float3 HistoryGlossySpecular     = 0.f;
            float3 DenoisedIrradiance = 0.f;
            float3 DenoisedGlossySpecular = 0.f;
            float  Alpha           = NewLightingValid > 0 ? 1.f : 0.f;
            float  TotalSamples    = NewLightingValid > 0 ? 1.f : 0.f;

            // Reproject to previous frame
            bool PreviousIsSkyPixel = false;
            float2 PreviousUV = UV - g_VelocityTexture.SampleLevel(g_NearestSampler, UV, 0).xy;
            //GetClosestVelocity(UV, MI.ScreenDimensionsInv, PreviousIsSkyPixel);

            if (!PreviousIsSkyPixel && all(PreviousUV >= 0.0f) && all(PreviousUV < 1.0f))
            {
                float3 Homogeneous     = float3(UV2NDC2(UV), Depth);
                float3 HomogeneousPrev = transformPointProjection(Homogeneous, MI.Reprojection);
                float  PreviousLinearDepth = GetLinearDepth(HomogeneousPrev.z);

                float2 PixelScale2 = 0.5f / MI.ScreenDimensions;
                float2 PixelScale  = 1.0f / MI.ScreenDimensions;

                // top-left corner pixel index for bilinear interpolation
                float2 PreviousBilinear         = PreviousUV * MI.ScreenDimensions - 0.5;
                float2 PreviousBilinearPixelPos = floor(PreviousBilinear);
                float2 PreviousBilinearSubpixel = frac(PreviousBilinear);
                float2 HistoryGatherUV          = (PreviousBilinearPixelPos + 1) * MI.ScreenDimensionsInv;

                float4 HistoryGBufferDepths  = g_PreviousDepthTexture.GatherRed(g_ClampedPointSampler, HistoryGatherUV).wzxy;
                float4 HistoryLinearDepths   = float4(
                    GetLinearDepth(HistoryGBufferDepths.x),
                    GetLinearDepth(HistoryGBufferDepths.y),
                    GetLinearDepth(HistoryGBufferDepths.z),
                    GetLinearDepth(HistoryGBufferDepths.w)
                );
                // Lumen alike method, jitter disocclusion threshold
                float Noise = BlueNoise_Sample1D(uint2(PixelX, PixelY), MI.FrameSeed, 8);
                float HistoryDistanceThreshold = 0.005f;
                float DisocclusionDistanceThreshold = HistoryDistanceThreshold * lerp(0.5f, 1.5f, Noise);
                DisocclusionDistanceThreshold /= clamp(saturate(dot(ViewDirection, GeometryNormal)), .1f, 1.0f); 
                float4 DepthDistances    = abs(HistoryLinearDepths - PreviousLinearDepth);
                float4 OcclusionWeights  = select(DepthDistances >= PreviousLinearDepth * DisocclusionDistanceThreshold, 1.f, 0.f);
                float4 VisibilityWeights = saturate(1.f - OcclusionWeights);
                float4 BilinearWeights   = float4(
                    (1.f - PreviousBilinearSubpixel.x) * (1.f - PreviousBilinearSubpixel.y),
                    PreviousBilinearSubpixel.x * (1.f - PreviousBilinearSubpixel.y),
                    (1.f - PreviousBilinearSubpixel.x) * PreviousBilinearSubpixel.y,
                    PreviousBilinearSubpixel.x * PreviousBilinearSubpixel.y
                );
                float4 NormalWeights = 1.f.xxxx;
#if false
                // Normal rejection
                {
                    float2 BaseUV = (PreviousBilinearPixelPos + 0.5f) * MI.ScreenDimensionsInv;
                    float3 HistoryNormalX00 = normalize(g_PreviousGeometryNormalTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV, 0.f
                    ).xyz * 2.f - 1.f);
                    float3 HistoryNormalX10 = normalize(g_PreviousGeometryNormalTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(PixelScale.x, 0), 0.f
                    ).xyz * 2.f - 1.f);
                    float3 HistoryNormalX01 = normalize(g_PreviousGeometryNormalTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(0,  PixelScale.y), 0.f
                    ).xyz * 2.f - 1.f);
                    float3 HistoryNormalX11 = normalize(g_PreviousGeometryNormalTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(PixelScale.x,  PixelScale.y), 0.f
                    ).xyz * 2.f - 1.f);
                    NormalWeights = float4(
                        saturate(dot(HistoryNormalX00, GeometryNormal)),
                        saturate(dot(HistoryNormalX10, GeometryNormal)),
                        saturate(dot(HistoryNormalX01, GeometryNormal)),
                        saturate(dot(HistoryNormalX11, GeometryNormal))
                    );
                    NormalWeights = select(NormalWeights < 0.5 + 0.5f * Noise, 0.f, 1.f);
                }
#endif
                float4 FinalWeights = BilinearWeights * VisibilityWeights * NormalWeights;

                FinalWeights = FinalWeights / max(dot(FinalWeights, 1.f.xxxx), 1e-5f);

                float4 HistorySamples    = 
                    g_PreviousHistoryAccumulationTexture.GatherRed(g_ClampedPointSampler, HistoryGatherUV).wzxy
                    * MAX_TEMPORAL_ACCUMULATION;
                TotalSamples = dot(min(HistorySamples + NewLightingValid, MAX_TEMPORAL_ACCUMULATION) * FinalWeights, 1.f.xxxx);
                TotalSamples = min(TotalSamples, MAX_TEMPORAL_ACCUMULATION);
                
                Alpha = NewLightingValid / max(TotalSamples, 1.f);
                
                {
                    // Note: PrevCombinedGlobalIllumination includes the skybox, so we manually keep a copy of ours
                    float2 BaseUV = (PreviousBilinearPixelPos + 0.5f) * MI.ScreenDimensionsInv;
                    float3 HistoryIrradianceX00 = g_PreviousIrradianceTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV, 0.f
                    ).xyz;
                    float3 HistoryIrradianceX10 = g_PreviousIrradianceTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(PixelScale.x, 0), 0.f
                    ).xyz;
                    float3 HistoryIrradianceX01 = g_PreviousIrradianceTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(0,  PixelScale.y), 0.f
                    ).xyz;
                    float3 HistoryIrradianceX11 = g_PreviousIrradianceTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(PixelScale.x,  PixelScale.y), 0.f
                    ).xyz;
                    HistoryIrradiance = 
                        HistoryIrradianceX00 * FinalWeights.x + 
                        HistoryIrradianceX10 * FinalWeights.y + 
                        HistoryIrradianceX01 * FinalWeights.z + 
                        HistoryIrradianceX11 * FinalWeights.w;
                    
                    float3 HistoryGlossySpecularX00 = g_PreviousGlossySpecularTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV, 0.f
                    ).xyz;
                    float3 HistoryGlossySpecularX10 = g_PreviousGlossySpecularTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(PixelScale.x, 0), 0.f
                    ).xyz;
                    float3 HistoryGlossySpecularX01 = g_PreviousGlossySpecularTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(0,  PixelScale.y), 0.f
                    ).xyz;
                    float3 HistoryGlossySpecularX11 = g_PreviousGlossySpecularTexture.SampleLevel(
                        g_ClampedPointSampler, BaseUV + float2(PixelScale.x,  PixelScale.y), 0.f
                    ).xyz;
                    HistoryGlossySpecular = 
                        HistoryGlossySpecularX00 * FinalWeights.x + 
                        HistoryGlossySpecularX10 * FinalWeights.y + 
                        HistoryGlossySpecularX01 * FinalWeights.z + 
                        HistoryGlossySpecularX11 * FinalWeights.w;

                }
            }
            if(MI.NoDenoiser) {
                Alpha = NewLightingValid > 0 ? 1.f : 0.f;
            }
            DenoisedIrradiance = lerp(HistoryIrradiance, NewIrradiance, Alpha);
            DenoisedGlossySpecular     = lerp(HistoryGlossySpecular, NewGlossySpecular, Alpha);
            g_RWIrradianceTexture[TexCoords] = float4(DenoisedIrradiance, 1.0f);
            g_RWGlossySpecularTexture[TexCoords] = float4(DenoisedGlossySpecular, 1.0f);
            g_RWHistoryAccumulationTexture[TexCoords] = TotalSamples / MAX_TEMPORAL_ACCUMULATION;

            // Shade
            float3 Albedo = MaterialBRDFData.albedo;
            g_RWGlobalIlluminationOutput[TexCoords] = float4(
                DenoisedIrradiance * evaluateLambert(Albedo) + DenoisedGlossySpecular + EmissiveMaterialData.emissive,
                1.0f
            );
        } else{
            // Sky
            g_RWHistoryAccumulationTexture[TexCoords] = 0.f;
            g_RWGlobalIlluminationOutput[TexCoords] = 0.f.xxxx;
        }        
    }
}

// [numthreads(WAVE_SIZE, 1, 1)]
// void SSRC_AccumulateUpdateError (int DispatchID : SV_DispatchThreadID) {
//     // >= 96 registers for each thread (meanwhile < 128)
//     // anyway that's not big deal
//     float ThreadErrorAccumulation[SSRC_TILE_SIZE][SSRC_TILE_SIZE];
//     float ThreadErrorAccumulationWeight[SSRC_TILE_SIZE][SSRC_TILE_SIZE];
//     for(int i = 0; i<SSRC_TILE_SIZE; i++) 
//         for(int j = 0; j<SSRC_TILE_SIZE; j++) {
//             ThreadErrorAccumulation[i][j] = 0;
//         }
//     for(int i = 0; i<SSRC_TILE_SIZE; i++) 
//         for(int j = 0; j<SSRC_TILE_SIZE; j++) {
//             ThreadErrorAccumulationWeight[i][j] = 0;
//         }
//     int2 TileCoords = int2(DispatchID % g_TileDimensions.x, DispatchID / g_TileDimensions.x);
//     int2 TexOffset = TileCoords * SSRC_TILE_SIZE;
//     int TileID = DispatchID;
//     int TileRayCount = g_RWTileRayCountBuffer[TileID];
//     int TileRayOffset = g_RWTileRayOffsetBuffer[TileID];
//     for(int TileRayRank = 0; TileRayRank < TileRayCount; TileRayRank++) {
//         int RayIndex = TileRayOffset + TileRayRank;
//         int2 TexCoords  = UnpackUint16x2(g_RWUpdateRayOriginBuffer[RayIndex]);
//         float4 RadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
//         if(RadianceInvPdf.w > 0) {
//             float3 Error    = RadianceInvPdf.xyz;
//             float  InvPdf   = RadianceInvPdf.w;

//             float  Contrib  = (dot(Error, Error) ) * InvPdf;

//             // Accumulate the error
//             int2  PixelCoords = TexCoords - TexOffset;
//             ThreadErrorAccumulation[PixelCoords.y][PixelCoords.x] += Contrib;
//             ThreadErrorAccumulationWeight[PixelCoords.y][PixelCoords.x] += InvPdf;
//         }
//     }
//     for(int j = 0; j<SSRC_TILE_SIZE; j++) {
//         for(int i = 0; i<SSRC_TILE_SIZE; i++) {
//             int2 TexCoords = TexOffset + int2(i, j);
//             float Error  = ThreadErrorAccumulation[j][i];
//             float Weight = ThreadErrorAccumulationWeight[j][i];
//             float PrevError = g_RWUpdateErrorSplatTexture[TexCoords];
//             if(Weight > 0) {
//                 g_RWUpdateErrorSplatTexture[TexCoords] = lerp(PrevError, Error / Weight, 0.005f);
//             } else {
//                 g_RWUpdateErrorSplatTexture[TexCoords] = lerp(PrevError, 0.f,  0.005f);
//             }
//         }
//     }
// }

// [numthreads(8, 8, 1)]
// void DebugSSRC_ShowDifference (uint2 DispatchID : SV_DispatchThreadID) {
//     if(any(DispatchID >= MI.ScreenDimensions)) {
//         return;
//     }
//     if(g_DebugVisualizeMode == 0) {
//         float Depth = g_DepthTexture.Load(int3(DispatchID, 0)).x;
//         if(Depth < 1.f) {
//             float2 UV = (DispatchID + 0.5f.xx) / MI.ScreenDimensions;
//             float Difference = g_UpdateErrorSplatTexture.SampleLevel(g_LinearSampler, UV, ERROR_BLUR_LOD).x;
//             g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(Difference * g_DebugTonemapExposure), 1.f);
//         } else {
//             g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
//         }
//     } else if(g_DebugVisualizeMode == 1) {
//         int2 TileCoords = DispatchID / SSRC_TILE_SIZE;
//         int TileID = TileCoords.x + TileCoords.y * g_TileDimensions.x;
//         int TileRayCount = g_RWTileRayCountBuffer[TileID];
//         if(TileRayCount == 0) {
//             g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
//         } else {
//             g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(TileRayCount / 128.f), 1.f);
//         }
//     } else if(g_DebugVisualizeMode == 2) {
//         float Depth = g_DepthTexture.Load(int3(DispatchID, 0)).x;
//         if(Depth < 1.f) {
//             float Difference = g_UpdateErrorSplatTexture.Load(int3(DispatchID, 0)).x;
//             g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(Difference * g_DebugTonemapExposure), 1.f);
//         } else {
//             g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
//         }
//     }
// }

// ***********************************************
// *                 Misc                        *
// ***********************************************


// [numthreads(1, 1, 1)]
// void DebugSSRC_GenerateDrawIndexed (uint DispatchID : SV_DispatchThreadID) {
//     DrawIndexedCommand draw_command;
//     draw_command.index_count_per_instance = 3;
//     draw_command.instance_count  = g_RWActiveBasisCountBuffer[0];
//     draw_command.index_offset    = 0;
//     draw_command.vertex_offset   = 0;
//     draw_command.instance_offset = 0;
//     g_RWDrawIndexedCommandBuffer[0] = draw_command;
// }

[numthreads(1, 1, 1)]
void DebugSSRC_FetchCursorPos (uint DipspatchID : SV_DispatchThreadID) {
    float4 Visibility = g_VisibilityTexture.Load(int3(MI.DebugCursorPixelCoords, 0));
    float2 Barycentrics = Visibility.xy;
    uint InstanceID = asuint(Visibility.z);
    uint PrimitiveID = asuint(Visibility.w);
    Instance InstanceData = g_InstanceBuffer[InstanceID];
    Mesh mesh = g_MeshBuffer[InstanceData.mesh_index];
    Triangle vertices = fetchVertices(mesh, PrimitiveID);
    float3x4 transform = g_TransformBuffer[InstanceData.transform_index];
    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);
    float3 WorldPosition = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);
    g_RWDebugCursorWorldPosBuffer[0] = WorldPosition;
}

[numthreads(WAVE_SIZE, 1, 1)]
void DebugSSRC_VisualizeProbePlacement (int DispatchID : SV_DispatchThreadID) {
    int2 ProbeIndex = int2(DispatchID % MI.TileDimensions.x, DispatchID / MI.TileDimensions.x);
    if(ProbeIndex.x >= MI.TileDimensions.x || ProbeIndex.y >= MI.TileDimensions.y) {
        return;
    }
    int2 UniformProbeScreenCoords = GetUniformScreenProbeScreenCoords(ProbeIndex);

    if(all(UniformProbeScreenCoords >= 0) && all(UniformProbeScreenCoords < MI.ScreenDimensions)
    && IsScreenProbeValid(ProbeIndex))
        g_RWDebugOutput[UniformProbeScreenCoords] = float4(10.f.xxx, 1.f);
    // Visualize adaptive probes
    int  AdaptiveProbeCount = g_RWTileAdaptiveProbeCountTexture[ProbeIndex];
    for(int i = 0; i < AdaptiveProbeCount; i++) {
        int  ScreenProbeIndex1 = GetAdaptiveProbeIndex(ProbeIndex, i) + MI.UniformScreenProbeCount;
        int2 AdaptiveProbeIndex = int2(ScreenProbeIndex1 % MI.TileDimensions.x, ScreenProbeIndex1 / MI.TileDimensions.x);
        ProbeHeader Header = GetScreenProbeHeader(AdaptiveProbeIndex);
        int2 AdaptiveProbeScreenCoords = Header.ScreenCoords;
        g_RWDebugOutput[AdaptiveProbeScreenCoords] = float4(10.f.xxx, 1.f);
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void DebugSSRC_PrepareProbeIncidentRadiance (uint DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= MI.DebugVisualizeIncidentRadianceNumPoints) {
        return;
    }
    if(DispatchID == 0) {
        // 3 channel sum
        g_RWReduceCountBuffer[0] = MI.DebugVisualizeIncidentRadianceNumPoints * 3;
    }
    float3 Direction      = FibonacciSphere(DispatchID, MI.DebugVisualizeIncidentRadianceNumPoints);
    float3 DebugWorldPos  = g_RWDebugCursorWorldPosBuffer[0];
    float3 Homogeneous    = transformPointProjection(DebugWorldPos, MI.CameraProjView);
    float2 UV             = NDC22UV(Homogeneous.xy);
    int2   TexCoords      = int2(UV * MI.ScreenDimensions);
    
    int2   TileIndex       = int2(TexCoords.x / SSRC_TILE_SIZE, TexCoords.y / SSRC_TILE_SIZE);
    int2   ProbeIndex      = TileIndex;
    ProbeHeader Header     = GetScreenProbeHeader(ProbeIndex);
    float  MinScreenDistance = Header.bValid ? length(UV - Header.ScreenCoords - 0.5) : 1e6f;
    int AdaptiveProbeCount = g_RWTileAdaptiveProbeCountTexture[TileIndex];
    for(int AdaptiveProbeRank = 0; AdaptiveProbeRank < AdaptiveProbeCount; AdaptiveProbeRank++) {
        int ScreenProbeIndex1 = GetAdaptiveProbeIndex(ProbeIndex, AdaptiveProbeRank) + MI.UniformScreenProbeCount;
        int2 ScreenProbeIndex = int2(ScreenProbeIndex1 % MI.TileDimensions.x, ScreenProbeIndex1 / MI.TileDimensions.x);
        ProbeHeader AdaptiveHeader = GetScreenProbeHeader(ScreenProbeIndex);
        float ScreenDistance  = length(UV - AdaptiveHeader.ScreenCoords - 0.5);
        if(!Header.bValid || ScreenDistance < MinScreenDistance) {
            ProbeIndex = ScreenProbeIndex;
            Header = AdaptiveHeader;
            MinScreenDistance = ScreenDistance;
        }
    }

    if(DispatchID == 0) {
        g_RWDebugProbeWorldPositionBuffer[0] = Header.Position;
        g_RWDebugProbeIndexBuffer[0]         = ProbeIndex;
    }
    
    int BasisCount = GetProbeBasisCountFromClass(Header.Class);

    float3 SumRadiance = 0.f.xxx;
    for(int i = 0; i < BasisCount; i++) {
        int BasisIndex = Header.BasisOffset + i;
        SGData SG = FetchBasisData(BasisIndex);
        float3 EvaluatedSG   = EvaluateSG(SG, Direction);
        SumRadiance += EvaluatedSG;
    }
    float3 SHCoefficients[9];
    float  SH9[9];
    GetScreenProbeSHCoefficients(ProbeIndex, SHCoefficients);
    SH_GetCoefficients(Direction, SH9);
    float3 SHEvaluated = 0.f;
    for(int i = 0; i < 9; i++) {
        SHEvaluated += SHCoefficients[i] * SH9[i];
    }
    g_RWDebugVisualizeIncidentRadianceBuffer[DispatchID] = SumRadiance + SHEvaluated;
}

[numthreads(1, 1, 1)]
void DebugSSRC_PrepareUpdateRays () {
    int2   TexCoords      = MI.DebugCursorPixelCoords;
    float  Depth          = g_DepthTexture.Load(int3(TexCoords, 0)).x;
    if(Depth < 1.f) {
        float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
        SSRC_SampleData Sample;
        CalculateSSRCSampleWeights(
            TexCoords + 0.5f,
            g_RWDebugCursorWorldPosBuffer[0],
            GetLinearDepth(Depth),
            GeometryNormal,
            true,
            Sample
        );
        int MaxIndex;
        if(Sample.Weights[0] > Sample.Weights[1]) {
            MaxIndex = 0;
        } else {
            MaxIndex = 1;
        }
        if(Sample.Weights[2] > Sample.Weights[MaxIndex]) {
            MaxIndex = 2;
        }
        if(Sample.Weights[3] > Sample.Weights[MaxIndex]) {
            MaxIndex = 3;
        }
        if(Sample.Weights[MaxIndex] != 0) {
            int2 ProbeIndex  = Sample.Index[MaxIndex];
            g_RWDebugProbeIndexBuffer[0] = ProbeIndex;
            int  ProbeIndex1 = ProbeIndex.x + ProbeIndex.y * MI.TileDimensions.x;
            int  ProbeRayCount = g_RWProbeUpdateRayCountBuffer[ProbeIndex1];
            DrawCommand draw_command = (DrawCommand)0;
            draw_command.vertex_count_per_instance = 2;
            draw_command.instance_count  = ProbeRayCount;
            draw_command.vertex_offset   = 0;
            draw_command.instance_offset = 0;
            g_RWDrawCommandBuffer[0] = draw_command;
        } else {
            DrawCommand draw_command = (DrawCommand)0;
            draw_command.vertex_count_per_instance = 0;
            draw_command.instance_count  = 0;
            draw_command.vertex_offset   = 0;
            draw_command.instance_offset = 0;
            g_RWDrawCommandBuffer[0] = draw_command;
        }
    } else {
        DrawCommand draw_command = (DrawCommand)0;
        draw_command.vertex_count_per_instance = 0;
        draw_command.instance_count  = 0;
        draw_command.vertex_offset   = 0;
        draw_command.instance_offset = 0;
        g_RWDrawCommandBuffer[0] = draw_command;
    }
}


[numthreads(SSRC_TILE_SIZE, SSRC_TILE_SIZE, 1)]
void DebugSSRC_VisualizeReprojectionTrust (int2 DispatchID : SV_DispatchThreadID) {
    float  Depth          = g_DepthTexture.Load(int3(DispatchID, 0)).x;
    if(Depth < 1.f) {
        float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(DispatchID, 0)).xyz - 1.f);
        SSRC_SampleData Sample;
        float3 Position = RecoverWorldPositionHiRes(DispatchID);
        CalculateSSRCSampleWeights(
            DispatchID + 0.5f,
            Position,
            GetLinearDepth(Depth),
            GeometryNormal,
            true,
            Sample
        );
        int MaxIndex;
        if(Sample.Weights[0] > Sample.Weights[1]) {
            MaxIndex = 0;
        } else {
            MaxIndex = 1;
        }
        if(Sample.Weights[2] > Sample.Weights[MaxIndex]) {
            MaxIndex = 2;
        }
        if(Sample.Weights[3] > Sample.Weights[MaxIndex]) {
            MaxIndex = 3;
        }
        int2 ProbeIndex = Sample.Index[MaxIndex];
        ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
        if(Header.bValid) {
            float Trust = g_RWProbeHistoryTrustTexture[ProbeIndex];
            g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(Trust), 1.f);
        }
    }
}

[numthreads(SSRC_TILE_SIZE, SSRC_TILE_SIZE, 1)]
void DebugSSRC_VisualizeProbeColor (int2 DispatchID : SV_DispatchThreadID) {
    float  Depth          = g_DepthTexture.Load(int3(DispatchID, 0)).x;
#if SSRC_TILE_SIZE < SSRC_PROBE_TEXTURE_SIZE || SSRC_TILE_SIZE % SSRC_PROBE_TEXTURE_SIZE != 0
    #error "SSRC_TILE_SIZE must be a multiple of SSRC_PROBE_TEXTURE_SIZE"
#endif 
    int Scale = SSRC_TILE_SIZE / SSRC_PROBE_TEXTURE_SIZE;
    int2 TexCoords = DispatchID / Scale;
    if(all(TexCoords < MI.TileDimensions * SSRC_PROBE_TEXTURE_SIZE)) {
        float4 Color          = g_RWProbeColorTexture[TexCoords];
        float3 Normal         = GetScreenProbeNormal(TexCoords/SSRC_PROBE_TEXTURE_SIZE);
        if(MI.DebugVisualizeChannel == 0) 
            g_RWDebugOutput[DispatchID] = float4(Color.xyz, 1.f);
        else g_RWDebugOutput[DispatchID] = float4(Color.w, 0.f, 0.f, 1.f);
    }
}


// New line required for termination.
