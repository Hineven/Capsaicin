#ifndef USE_INLINE_RT
#define USE_INLINE_RT 1
#endif

#ifndef WAVE_SIZE
// NVIDIA's default warp size
#define WAVE_SIZE 32
#endif

#define MIN_COLOR 0.000001f

// Shared structs among CPU and GPU
#include "../../gpu_shared.h"

// Parameters & Globals & Helper functions
#include "migi_inc.hlsl"

// Library for MIGI
#include "migi_lib.hlsl"
#include "migi_probes.hlsl"

// Hash grid cache library
#include "hash_grid_cache.hlsl"
// World space ReSTIR library
#include "world_space_restir.hlsl"

#define MAX_HIT_DISTANCE 1e9f

struct ScreenCacheUpdatePayload
{
    float3 sky_sample;
    float hit_dist;
};

struct PopulateCellsPayload
{
    uint      query_index;
    float3    world;
    float3    normal;
    float3    lighting;
    Reservoir reservoir;
};

struct TraceReflectionsPayload
{
    int2   full_pos;
    float3 radiance;
    float2 s;
    float  hit_distance;
};


// A naive kernel for generating dispatch commands
[numthreads(1, 1, 1)]
void GenerateDispatch()
{
    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = (g_CountBuffer[0] + g_GroupSize - 1) / g_GroupSize;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

[numthreads(1, 1, 1)]
void GenerateDispatchRays()
{
    DispatchRaysCommand dispatch_rays_command;
    dispatch_rays_command.ray_generation_shader_record = g_RTConstants.ray_generation_shader_record;
    dispatch_rays_command.miss_shader_table = g_RTConstants.miss_shader_table;
    dispatch_rays_command.hit_group_table = g_RTConstants.hit_group_table;
    dispatch_rays_command.callable_shader_table = g_RTConstants.callable_shader_table;
    dispatch_rays_command.width = g_CountBuffer[0];
    dispatch_rays_command.height = 1;
    dispatch_rays_command.depth = 1;
    dispatch_rays_command.padding[0] = 0;
    dispatch_rays_command.padding[1] = 0;
    dispatch_rays_command.padding[2] = 0;
    g_RWDispatchRaysCommandBuffer[0] = dispatch_rays_command;
}

[numthreads(64, 1, 1)]
void PurgeTiles(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_PreviousPackedTileCountBuffer[0])
    {
        return; // out of bounds
    }

    // We opt for calculating the decay of each tile from the
    // current frame index, as it saves many writes per frame
    // and is quite a bit faster than having to decrement all
    // cell's decay values.
    uint tile_index = g_HashGridCache_PreviousPackedTileIndexBuffer[did];
    uint tile_decay = g_HashGridCache_DecayTileBuffer[tile_index];

    if (MI.FrameIndex < tile_decay)   // account for integer wraparound case
    {
        tile_decay = ((0xFFFFFFFFu - tile_decay) + MI.FrameIndex + 1);
    }
    else
    {
        tile_decay = (MI.FrameIndex - tile_decay);
    }

    if (tile_decay >= kHashGridCache_TileDecay)
    {
        g_HashGridCache_HashBuffer[tile_index] = 0;

#ifdef DEBUG_HASH_CELLS
        // Clear all mipmaps
        for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile; ++cell_offset)
        {
            uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
            g_HashGridCache_DecayCellBuffer[cell_index] = 0xFFFFFFFFu;
        }
#endif // DEBUG_HASH_CELLS

        return; // kill the tile
    }

    uint packed_tile_index;
    InterlockedAdd(g_HashGridCache_PackedTileCountBuffer[0], 1, packed_tile_index);
    g_HashGridCache_PackedTileIndexBuffer[packed_tile_index] = tile_index;
}

[numthreads(1, 1, 1)]
void ClearCounters()
{
    g_Reservoir_HashListCountBuffer[0] = 0; // reset counters

    g_HashGridCache_PackedTileCountBuffer[0]    = 0;
    g_HashGridCache_UpdateTileCountBuffer[0]    = 0;
    g_HashGridCache_VisibilityCountBuffer[0]    = 0;
    g_HashGridCache_VisibilityRayCountBuffer[0] = 0;
    
}

// Clear the counters at the begginging of the frame
[numthreads(1, 1, 1)]
void SSRC_ClearCounters() {
    g_RWAdaptiveProbeCountBuffer[0]      = 0;
    g_RWAllocatedProbeSGCountBuffer[0] = 0;
}

// Allocate fixed uniform probes for current frame
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateUniformProbes (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID > MI.UniformScreenProbeCount) {
        return;
    }
    int2 ProbeIndex = int2(DispatchID % MI.TileDimensions.x, DispatchID / MI.TileDimensions.x);
    ProbeHeader Header;
    Header.ScreenCoords = GetUniformScreenProbeScreenCoords(ProbeIndex);
    float Depth             = g_DepthTexture.Load(int3(Header.ScreenCoords, 0)).x;
    bool  bValid            = Depth < 1.f;
    if(bValid) Header.Class  = ComputeProbeRankFromSplattedError(Header.ScreenCoords);
    int BasisCount      = bValid ? GetProbeBasisCountFromClass(Header.Class) : 0;
    int BasisOffset     = WavePrefixSum(BasisCount);
    int BasisCountSum   = WaveActiveSum(BasisCount);
    int BasisGroupOffset;
    if(WaveIsFirstLane()) {
        InterlockedAdd(g_RWAllocatedProbeSGCountBuffer[0], BasisCountSum, BasisGroupOffset);
    }
    BasisGroupOffset = WaveReadLaneFirst(BasisGroupOffset);
    Header.BasisOffset   = BasisGroupOffset + BasisOffset;
    // Clip over the maximum basis count
    if(Header.BasisOffset + BasisCount > MI.MaxBasisCount) {
        Header.Class = 0;
    }

    // Negative depths stands for invalid probes
    Header.LinearDepth   = (bValid ? 1 : -1) * GetLinearDepth(Depth);
    Header.Position      = RecoverWorldPositionHiRes(Header.ScreenCoords);
    Header.Normal        = normalize(g_GeometryNormalTexture.Load(int3(Header.ScreenCoords, 0)).xyz * 2.f - 1.f);
    Header.Irradiance    = 0.f;
    WriteScreenProbeHeader(ProbeIndex, Header);

    // Also, clear the tile adaptive probe count for later adaptive allocation
    g_RWTileAdaptiveProbeCountTexture[ProbeIndex] = 0;
}

float3 RecoverScreenProbePosition (int2 TileCoords, float LinearDepth, bool bPrevious) {
    // We are using the camera coordinate system to recover probe position, which is placed with G-Buffer samples
    // We need to take care of the jittering as the camera coordinate system is not affected by TAA (but the G-Buffer is). 
    // TODO The way using TAA jitter here may be incorrect (subtraction / addition ?)
    float2 UV = GetUniformScreenProbeScreenUV(TileCoords, bPrevious) + (bPrevious ? MI.PreviousTAAJitterUV : MI.TAAJitterUV);
    float2 NDC2 = UV2NDC2(UV);
    if(!bPrevious) {
        return LinearDepth * (NDC2.x * MI.CameraRight + NDC2.y * MI.CameraUp + MI.CameraDirection) + MI.CameraPosition;
    } else {
        return LinearDepth * (NDC2.x * MI.PreviousCameraRight + NDC2.y * MI.PreviousCameraUp + MI.PreviousCameraDirection) + MI.PreviousCameraPosition;
    }
}

void CalculateSSRCSampleWeightsForUniformScreenProbes (
    float2 ScreenPosition,
    float3 Position,
    float  LinearDepth,
    float3 Normal,
    out int2 TileCoordsX00,
    out float4 Weights,
    bool bPrevious = false
) {
    int2 ScreenCoordsProbeGrid = clamp(ScreenPosition - 0.5f - GetTileJitter(bPrevious), 0, MI.ScreenDimensions - 1);
    TileCoordsX00         = min(ScreenCoordsProbeGrid / SSRC_TILE_SIZE, MI.TileDimensions - 2);
    // Pad the bilinear filtering weights
#ifdef DEBUG_FIX_PROBES
    int BilinearExpand = 0;
#else
    int BilinearExpand = 1;
#endif
    float2 Bilinear    = 
        (ScreenCoordsProbeGrid - TileCoordsX00 * SSRC_TILE_SIZE + BilinearExpand) 
        / (float)(SSRC_TILE_SIZE + 2 * BilinearExpand);
    float4 CornerLinearDepths;
    CornerLinearDepths.x = GetScreenProbeLinearDepth(TileCoordsX00 + int2(0, 0), bPrevious);
    CornerLinearDepths.y = GetScreenProbeLinearDepth(TileCoordsX00 + int2(1, 0), bPrevious);
    CornerLinearDepths.z = GetScreenProbeLinearDepth(TileCoordsX00 + int2(0, 1), bPrevious);
    CornerLinearDepths.w = GetScreenProbeLinearDepth(TileCoordsX00 + int2(1, 1), bPrevious);
    Weights = float4(
        (1.f - Bilinear.x) * (1.f - Bilinear.y),
        Bilinear.x * (1.f - Bilinear.y),
        (1.f - Bilinear.x) * Bilinear.y,
        Bilinear.x * Bilinear.y
    );
    float4 DepthWeights;
    float4 PixelPlane  = float4(Normal, dot(Position, Normal));
    float3 PositionX00 = RecoverScreenProbePosition(TileCoordsX00 + int2(0, 0), CornerLinearDepths.x, bPrevious);
    float3 PositionX10 = RecoverScreenProbePosition(TileCoordsX00 + int2(1, 0), CornerLinearDepths.y, bPrevious);
    float3 PositionX01 = RecoverScreenProbePosition(TileCoordsX00 + int2(0, 1), CornerLinearDepths.z, bPrevious);
    float3 PositionX11 = RecoverScreenProbePosition(TileCoordsX00 + int2(1, 1), CornerLinearDepths.w, bPrevious);
    float4 PlaneDistances;
    PlaneDistances.x = abs(dot(PixelPlane, float4(PositionX00, -1.f)));
    PlaneDistances.y = abs(dot(PixelPlane, float4(PositionX10, -1.f)));
    PlaneDistances.z = abs(dot(PixelPlane, float4(PositionX01, -1.f)));
    PlaneDistances.w = abs(dot(PixelPlane, float4(PositionX11, -1.f)));
    float4 RelativeDepthDifference = PlaneDistances / LinearDepth;
    // Negative depths stands for invalid probes
    DepthWeights = select(
        CornerLinearDepths > 0, 
        exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference)),
        0.0
    );
    Weights *= DepthWeights;
}

void CalculateSSRCSampleWeights (
    float2 ScreenPosition,
    float3 Position,
    float  LinearDepth,
    float3 Normal,
    out SSRC_SampleData Sample,
    bool bPrevious = false
) {
    int2 TileCoordsX00;
    CalculateSSRCSampleWeightsForUniformScreenProbes(
        ScreenPosition,
        Position,
        LinearDepth,
        Normal,
        TileCoordsX00,
        Sample.Weights,
        bPrevious
    );
    Sample.Index[0] = TileCoordsX00 + int2(0, 0);
    Sample.Index[1] = TileCoordsX00 + int2(1, 0);
    Sample.Index[2] = TileCoordsX00 + int2(0, 1);
    Sample.Index[3] = TileCoordsX00 + int2(1, 1);
    
    // Weight the adaptive probes and search within the nearest tiles
    {
        float Epsilon = .01f;
		float4 PixelPlane = float4(Normal, dot(Position, Normal));
        for (uint CornerIndex = 0; CornerIndex < 4; CornerIndex++)
		{
			if (Sample.Weights[CornerIndex] <= Epsilon)
			{
				int2 TileCoords = TileCoordsX00 + uint2(CornerIndex % 2, CornerIndex / 2);
				int NumAdaptiveProbes = 
                    bPrevious ? g_RWPreviousTileAdaptiveProbeCountTexture[TileCoords] 
                    : g_RWTileAdaptiveProbeCountTexture[TileCoords];
                [unroll(1 << (SSRC_MAX_ADAPTIVE_PROBE_LAYERS * 2))]
				for (uint AdaptiveProbeListIndex = 0; AdaptiveProbeListIndex < NumAdaptiveProbes; AdaptiveProbeListIndex++)
				{
                    // TODO reconstruct probe data from G-Buffer to reduce VRAM bandwidth when shading
					int  AdaptiveProbeIndex1 = GetAdaptiveProbeIndex(TileCoords, AdaptiveProbeListIndex, bPrevious);
					int  ScreenProbeIndex1   = AdaptiveProbeIndex1 + MI.UniformScreenProbeCount;
                    int2 ScreenProbeIndex    = int2(ScreenProbeIndex1 % MI.TileDimensions.x, ScreenProbeIndex1 / MI.TileDimensions.x);

                    ProbeHeader Header         = GetScreenProbeHeader(ScreenProbeIndex, bPrevious);
					float2 ProbeScreenPosition = Header.ScreenCoords + 0.5f;
					float ProbeLinearDepth     = Header.LinearDepth;
					
					float NewDepthWeight = 0;

                    float3 ProbePosition = Header.Position;
                    float  PlaneDistance = abs(dot(float4(ProbePosition, -1), PixelPlane));
                    float RelativeDepthDifference = PlaneDistance / LinearDepth;
                    NewDepthWeight = exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference));

					float2 DistanceToScreenProbe = abs(ProbeScreenPosition - ScreenPosition);
					float NewCornerWeight = 1.0f - saturate(min(DistanceToScreenProbe.x, DistanceToScreenProbe.y) / (float)(SSRC_TILE_SIZE));
					float NewInterpolationWeight = NewDepthWeight * NewCornerWeight;

					if (NewInterpolationWeight > Sample.Weights[CornerIndex])
					{
						Sample.Weights[CornerIndex] = NewInterpolationWeight;
						Sample.Index[CornerIndex] = ScreenProbeIndex;
					}
				}
			}
		}
    }
}


groupshared int  LocalNumProbesToAllocate;
groupshared int  LocalAdaptiveProbeOffset;
groupshared int2 LocalProbeScreenCoordsToAllocate[WAVE_SIZE];
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateAdaptiveProbes (int DispatchID : SV_DispatchThreadID, int LocalID : SV_GroupThreadID) {
    if(MI.NoAdaptiveProbes) return ;
// This macro is passed in by compiler arguments
#ifndef SSRC_ADAPTIVE_PROBE_LAYER
#define SSRC_ADAPTIVE_PROBE_LAYER 0
#endif
    const int AdaptiveProbeDownsampleFactor = SSRC_TILE_SIZE / (2 << SSRC_ADAPTIVE_PROBE_LAYER);
    int2 DownsampledTileDimensions = MI.ScreenDimensions / AdaptiveProbeDownsampleFactor;
    int2 AdaptiveTileCoords = int2(
        DispatchID % DownsampledTileDimensions.x,
        DispatchID / DownsampledTileDimensions.x
    );
    if(WaveIsFirstLane()) {
        LocalNumProbesToAllocate = 0;
    }
    GroupMemoryBarrierWithGroupSync();

    {
        // Omit the adaptive probe that overlaps with the previous layer
        if(any((AdaptiveTileCoords&1) != 0)) {
            // Compute the screen coords for current adaptive probe
            int2 AdaptiveProbeScreenCoords = AdaptiveTileCoords * AdaptiveProbeDownsampleFactor + GetTileJitter();
            if(all(AdaptiveProbeScreenCoords < MI.ScreenDimensions)) {
                float Depth = g_DepthTexture.Load(int3(AdaptiveProbeScreenCoords, 0)).x;
                bool  bValid = Depth < 1.f;
                if(bValid) {
                    float3 WorldPosition  = RecoverWorldPositionHiRes(AdaptiveProbeScreenCoords);
                    float  LinearDepth    = GetLinearDepth(Depth);
                    float3 GeometryNormal = normalize(g_GeometryNormalTexture.Load(int3(AdaptiveProbeScreenCoords, 0)).xyz * 2.f - 1.f);
                    SSRC_SampleData Sample;

                    CalculateSSRCSampleWeights(
                        AdaptiveProbeScreenCoords + 0.5f,
                        WorldPosition,
                        LinearDepth,
                        GeometryNormal,
                        Sample
                    );

                    float Epsilon = .01f;
                    Sample.Weights /= max(dot(Sample.Weights, 1), Epsilon);

                    float LightingIsValid = (dot(Sample.Weights, 1) < 1.0f - Epsilon) ? 0.0f : 1.0f;

                    if (!LightingIsValid)
                    {
                        // g_RWDebugOutput[AdaptiveTileCoords] = 1.f.xxxx;
                        int ListIndex;
                        InterlockedAdd(LocalNumProbesToAllocate, 1, ListIndex);
                        LocalProbeScreenCoordsToAllocate[ListIndex] = AdaptiveProbeScreenCoords;
                    }
                }
            }
        }
    }
    
    GroupMemoryBarrierWithGroupSync();

    // Allocate probes
    if(WaveIsFirstLane()) {
        InterlockedAdd(g_RWAdaptiveProbeCountBuffer[0], LocalNumProbesToAllocate, LocalAdaptiveProbeOffset);
    }

    GroupMemoryBarrierWithGroupSync();
    
    int NumProbeToAllocateClipped = min(max(MI.MaxAdaptiveProbeCount - LocalAdaptiveProbeOffset, 0), LocalNumProbesToAllocate);

    int AdaptiveProbeIndex = LocalAdaptiveProbeOffset + LocalID;

    if(LocalID < NumProbeToAllocateClipped) {
        // Allocate the index slot and record the index of the adaptive probe
        int TileAdaptiveProbeRank;
        // Set the tile coords to the tile that the LocalID th probe belongs to
        int2 TileCoords = (LocalProbeScreenCoordsToAllocate[LocalID] - GetTileJitter()) / SSRC_TILE_SIZE;
        // Make a copy of the tile probe count texture to RW at the same time
        InterlockedAdd(g_RWNextTileAdaptiveProbeCountTexture[TileCoords], 1, TileAdaptiveProbeRank);
        g_RWTileAdaptiveProbeIndexTexture[GetAdaptiveProbeIndexCoords(TileCoords, TileAdaptiveProbeRank)] = AdaptiveProbeIndex;
        // The probe here is guaranteed to be valid upon allocation.
        int ScreenProbeIndex1   = AdaptiveProbeIndex + MI.UniformScreenProbeCount;
        ProbeHeader Header;
        Header.ScreenCoords     = LocalProbeScreenCoordsToAllocate[LocalID];
        float Depth             = g_DepthTexture.Load(int3(Header.ScreenCoords, 0)).x;
        Header.Class        = ComputeProbeRankFromSplattedError(Header.ScreenCoords);
        int BasisCount      = GetProbeBasisCountFromClass(Header.Class);
        int BasisOffset     = WavePrefixSum(BasisCount);
        int BasisCountSum   = WaveActiveSum(BasisCount);
        int BasisGroupOffset;
        if(WaveIsFirstLane()) {
            // Allocate basis for the newly allocated tile probes
            InterlockedAdd(g_RWAllocatedProbeSGCountBuffer[0], BasisCountSum, BasisGroupOffset);
        }
        BasisGroupOffset = WaveReadLaneFirst(BasisGroupOffset);
        Header.BasisOffset   = BasisGroupOffset + BasisOffset;
        // Clip over the maximum basis count
        if(Header.BasisOffset + BasisCount > MI.MaxBasisCount) {
            Header.Class = 0;
        }
        Header.LinearDepth   = GetLinearDepth(Depth);
        Header.Position      = RecoverWorldPositionHiRes(Header.ScreenCoords);
        Header.Normal        = normalize(g_GeometryNormalTexture.Load(int3(Header.ScreenCoords, 0)).xyz * 2.f - 1.f);
        Header.Irradiance    = 0.f;
        int2 ScreenProbeIndex = int2(ScreenProbeIndex1 % MI.TileDimensions.x, ScreenProbeIndex1 / MI.TileDimensions.x);
        WriteScreenProbeHeader(ScreenProbeIndex, Header);
    }
}

// Write dispatch parameters for SSRC computations
[numthreads(1, 1, 1)]
void SSRC_WriteProbeDispatchParameters () {
    // Clip the number of allocated adaptive probes
    g_RWAdaptiveProbeCountBuffer[0] = min(g_RWAdaptiveProbeCountBuffer[0], MI.MaxAdaptiveProbeCount);

    DispatchCommand Command = (DispatchCommand)0;
    Command.num_groups_x = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0];
    Command.num_groups_y = 1;
    Command.num_groups_z = 1;
    g_RWDispatchCommandBuffer[0] = Command;

    Command.num_groups_x = (MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0] + WAVE_SIZE - 1) / WAVE_SIZE;
    Command.num_groups_y = 1;
    Command.num_groups_z = 1;
    g_RWPerLaneDispatchCommandBuffer[0] = Command;

    // Also, set the reduce count for scan sum update rays
    // Pad 1 for the last element
    g_RWReduceCountBuffer[0] = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0] + 1;

}

SGData GetIrradianceSG (float3 Normal, float3 Color) {
    SGData SG;
    SG.Color = Color;
    SG.Direction = Normal;
    SG.Depth = 0.f;
    // Similar to the cosine lobe
    SG.Lambda = 0.85f;
    return SG;
}

groupshared float  LocalSGSize4[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
groupshared SGData LocalSGData4[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
groupshared SGData LocalSGData4New[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
groupshared int    LocalSGMaxMatchIndex[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
groupshared int    LocalSGNewIndex[SSRC_MAX_NUM_BASIS_PER_PROBE * 4];
// Initialize probe cache from the previous frame, one group per probe
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_ReprojectProbeHistory (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {
    int2 ProbeIndex = int2(GroupID % MI.TileDimensions.x, GroupID / MI.TileDimensions.x);
    if(MI.ResetCache) {
        if(WaveIsFirstLane()) {
            // Clear probe history
            g_RWProbeHistoryTrustTexture[ProbeIndex] = 0;
        }
        return ;
    }
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    float4 PrevHomogeneousW = mul(MI.PrevCameraProjView, float4(Header.Position, 1));
    if(PrevHomogeneousW.w <= 0) {
        if(WaveIsFirstLane()) {
            // Clear probe history
            g_RWProbeHistoryTrustTexture[ProbeIndex] = 0;
        }
        return ;
    }
    float3 PrevHomogeneous = PrevHomogeneousW.xyz / PrevHomogeneousW.w;
    // TODO TAA should be in place of the noise effect, but it malfunctions
    // (consistent directional biased blur during reprojection).
    float2 NoiseOffset = (BlueNoise_Sample2D(ProbeIndex, MI.FrameSeed) * 2 - 1) * MI.ScreenDimensionsInv;
    float2 PrevScreenPosition = MI.ScreenDimensions * NDC22UV(PrevHomogeneous.xy + NoiseOffset);
    float2 PrevProbeHistoryDimensionsMin = GetTileJitter(true) + 0.5f;
    float2 PrevProbeHistoryDimensionsMax = MI.ScreenDimensions - SSRC_TILE_SIZE + GetTileJitter(true) + 0.5f;
    float2 PrevScreenPositionClamped = clamp(PrevScreenPosition, PrevProbeHistoryDimensionsMin, PrevProbeHistoryDimensionsMax);
    // TODO use the previous camera parameters to recover linear depth
    float  PrevLinearDepth    = GetLinearDepth(PrevHomogeneous.z);
    SSRC_SampleData Sample;
    // TODO is it okay to use the clamped screen position? 
    CalculateSSRCSampleWeights(
        PrevScreenPositionClamped,
        Header.Position,
        PrevLinearDepth,
        Header.Normal,
        Sample,
        true
    );
    float2 OutOfRangeDecay2 = max(
        PrevScreenPosition - PrevProbeHistoryDimensionsMax,
        PrevProbeHistoryDimensionsMin - PrevScreenPosition
    );
    OutOfRangeDecay2 = max(OutOfRangeDecay2, 0.f);
    float  OutOfRangeDecay  = max(1.f - 2.f * length(OutOfRangeDecay2) / SSRC_TILE_SIZE, 0.f);
    float HistoryTrust = min(dot(Sample.Weights, 1), 1.f) * OutOfRangeDecay;
    if(WaveIsFirstLane()) {
        g_RWProbeHistoryTrustTexture[ProbeIndex] = HistoryTrust;
    }
    float Epsilon = .01f;
    Sample.Weights /= max(dot(Sample.Weights, 1), Epsilon);

    // Reproject SG

    int BasisOffsets[4];
    BasisOffsets[0] = GetScreenProbeBasisOffset(Sample.Index[0], true);
    BasisOffsets[1] = GetScreenProbeBasisOffset(Sample.Index[1], true);
    BasisOffsets[2] = GetScreenProbeBasisOffset(Sample.Index[2], true);
    BasisOffsets[3] = GetScreenProbeBasisOffset(Sample.Index[3], true);
    
    int BasisCount[4];
    BasisCount[0] = GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[0], true).Class);
    BasisCount[1] = GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[1], true).Class);
    BasisCount[2] = GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[2], true).Class);
    BasisCount[3] = GetProbeBasisCountFromClass(GetScreenProbeHeader(Sample.Index[3], true).Class);
    int NumBasis0 = BasisCount[0] + BasisCount[1];
    int NumBasis1 = BasisCount[2] + BasisCount[3];
    int NumBasis  = NumBasis0 + NumBasis1;

#if SSRC_MAX_NUM_BASIS_PER_PROBE > 8
#error "SSRC_MAX_NUM_BASIS_PER_PROBE must be less than or equal to 8"
#endif
    // Fetch the basis data from the previous frame
    {
        int BasisRank = LocalID;
        if(BasisRank < NumBasis) {
            int BasisOffset;
            float Weight;
            if(BasisRank < NumBasis0) {
                BasisOffset = BasisOffsets[BasisRank < BasisCount[0] ? 0 : 1] 
                    + BasisRank - (BasisRank < BasisCount[0] ? 0 : BasisCount[0]);
                Weight      = Sample.Weights[BasisRank < BasisCount[0] ? 0 : 1];
            } else {
                int Mid = NumBasis0 + BasisCount[2];
                BasisOffset = BasisOffsets[BasisRank < Mid ? 2 : 3] 
                    + BasisRank - (BasisRank < Mid ? NumBasis0 : Mid);
                Weight      = Sample.Weights[BasisRank < Mid ? 2 : 3];
            }
            SGData SG = FetchBasisData(BasisOffset, true);
            // FIXME directional reprojection is missing

            // Scale the color by the weight
            // Clamp to epsilon to always rank the closest SGs first if all SGs have zero weight
            LocalSGSize4[BasisRank] = Weight * (1e-6f + SGIntegrate(SG.Lambda) * dot(SG.Color, 1.f.xxx));
            SG.Color = SG.Color * Weight;
            LocalSGData4[BasisRank] = SG;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    // Simple N^2 Sort
    {
        SGData ThreadSG;
        int    ThreadSGRank;
        int BasisRank = LocalID;
        if(BasisRank < NumBasis) {
            float Weight = LocalSGSize4[BasisRank];
            int SortedRank = 0;
            [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
            for(int i = 0; i < NumBasis; i++) {
                float Opponent = LocalSGSize4[i];
                if(Opponent > Weight || (Opponent == Weight && i < BasisRank)) {
                    SortedRank ++;
                }
            }
            ThreadSGRank = SortedRank;
            ThreadSG = LocalSGData4[BasisRank];
        }
        
        GroupMemoryBarrierWithGroupSync();

        if(BasisRank < NumBasis) {
            LocalSGData4[ThreadSGRank] = ThreadSG;
        }
    }
    GroupMemoryBarrierWithGroupSync();

    int CurrentProbeBasisCount = GetProbeBasisCountFromClass(Header.Class);
    // The number of merges required to reduce the number of SGs
    int MergeCount = max(NumBasis - CurrentProbeBasisCount, 0);
#ifdef  DEBUG_FIX_PROBES
#define MERGE_BASIS_FLAG 0
#else 
#define MERGE_BASIS_FLAG 1
#endif
    // Progressively merges the candidate SGs.
    if(MERGE_BASIS_FLAG && CurrentProbeBasisCount > 0) {
        const int REPEAT = (SSRC_MAX_NUM_BASIS_PER_PROBE * 4 + WAVE_SIZE-1) / WAVE_SIZE;   
        [unroll(4)]
        for(int Iteration = 0; MergeCount > 0 && Iteration < 4; Iteration ++) {
            // Compute the distances between each pair of SGs
            {
                int BasisRank = LocalID;
                if(BasisRank < NumBasis) {
                    int MaxIndex  = -1;
                    float MaxSimilarity = -1.f;
                    SGData CurrentSG = LocalSGData4[BasisRank];
                    [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
                    for (int i = 0; i<NumBasis; i++) {
                        // TODO better similarity computation
                        float X = EvaluateSGRaw(LocalSGData4[BasisRank], CurrentSG.Direction);
                        float Y = EvaluateSGRaw(CurrentSG, LocalSGData4[i].Direction);
                        float Similarity = X * Y;
                        if(i != BasisRank && Similarity > MaxSimilarity) {
                            MaxSimilarity = Similarity;
                            MaxIndex = i;
                        }
                    }
                    LocalSGMaxMatchIndex[BasisRank] = MaxIndex;
                }
            }
            GroupMemoryBarrierWithGroupSync();
            int NumNewBasis = 0;
            // Pairing the SGs for merging, single threaded algorithm
            if(WaveIsFirstLane()) {
                // Simple greedy algorithm instead of dfs alike precise algirithm
                [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
                for(int i = 0; i<NumBasis; i++) {
                    int MaxIndex = LocalSGMaxMatchIndex[i];
                    if(MaxIndex >= 0) {
                        bool AllocateNewSlot = false;
                        // A not matched basis
                        if(MergeCount > 0) {
                            if(MaxIndex > i) {
                                // Matched, so cancel the matching for MaxIndex
                                LocalSGMaxMatchIndex[MaxIndex] = -1;
                                MergeCount --;
                                AllocateNewSlot = true;
                            } else {
                                int OpponentMatchIndex = LocalSGMaxMatchIndex[MaxIndex];
                                if(MaxIndex == OpponentMatchIndex) {
                                    // Matched.
                                    LocalSGMaxMatchIndex[MaxIndex] = i;
                                    LocalSGMaxMatchIndex[i] = -1;
                                    MergeCount --;
                                } else {
                                    // Failed, the opponent has already matched.
                                    // Match with itself.
                                    LocalSGMaxMatchIndex[i] = i;
                                    AllocateNewSlot = true;
                                }
                            }
                        } else {
                            // No need for further merging. Match with itself
                            LocalSGMaxMatchIndex[i] = i;
                            AllocateNewSlot = true;
                        }
                        if(AllocateNewSlot) LocalSGNewIndex[i] = NumNewBasis++;
                    }
                }
            }
            GroupMemoryBarrierWithGroupSync();
            NumNewBasis = WaveReadLaneFirst(NumNewBasis);
            MergeCount  = WaveReadLaneFirst(MergeCount);
            // Merge the SGs
            {
                int BasisRank = LocalID;
                if(BasisRank < NumBasis) {
                    int MaxIndex  = LocalSGMaxMatchIndex[BasisRank];
                    if(MaxIndex >= 0) {
                        SGData NewSG;
                        if(MaxIndex != BasisRank) {
                            SGData X = LocalSGData4[BasisRank];
                            SGData Y = LocalSGData4[MaxIndex];
                            NewSG = CombineSG(X, Y);
                        } else NewSG = LocalSGData4[BasisRank];
                        LocalSGData4New[LocalSGNewIndex[BasisRank]] = NewSG;
                    }
                }
            }
            GroupMemoryBarrierWithGroupSync();
            // Swap the data
            {
                int BasisRank = LocalID;
                if(BasisRank < NumNewBasis) {
                    LocalSGData4[BasisRank] = LocalSGData4New[BasisRank];
                }
            }
            NumBasis = NumNewBasis;
            // Barrier the next iteration
            GroupMemoryBarrierWithGroupSync();
        }
    }
    // Write the new SGs to the buffer
    {
#if SSRC_MAX_NUM_BASIS_PER_PROBE > WAVE_SIZE
#error "SSRC_MAX_NUM_BASIS_PER_PROBE must be less than or equal to WAVE_SIZE"
#endif
        // Reproject irradiance
        if(WaveIsFirstLane()) {
            float3 SumIrradiance = 0;
            for(int CornerIndex = 0; CornerIndex < 4; CornerIndex ++) {
                if(Sample.Weights[CornerIndex] > 0.f) {
                    SGData IrradianceSG = GetIrradianceSG(
                        GetScreenProbeNormal(Sample.Index[CornerIndex], true),
                        GetScreenProbeIrradiance(Sample.Index[CornerIndex], true)
                    );
                    SumIrradiance += Sample.Weights[CornerIndex] * EvaluateSG(IrradianceSG, Header.Normal);
                }
            }
            float  NormalizationFactor = 1.f / EvaluateSGRaw(GetIrradianceSG(float3(0.f, 0.f, 1.f), 1.f), float3(0.f, 0.f, 1.f));
            float3 Irradiance = SumIrradiance * NormalizationFactor;
            WriteScreenProbeIrradiance(ProbeIndex, Irradiance);
        }
        int BasisOffset = Header.BasisOffset;
        // TODO: Accumulate SG radiance into irradiance when dropping overflowing SGs 
        if(LocalID < CurrentProbeBasisCount) {
            SGData SG;
            if(LocalID < NumBasis) SG = LocalSGData4[LocalID];
            else {
                // Initialize the basis
                SG.Color = 1e-4f;
                SG.Lambda = 0.65f + 0.2f * NumBasis;
                SG.Depth  = 1.f;
                float3 Direction = InitHemiDirections(LocalID, CurrentProbeBasisCount);
                float3 Tangent, Bitangent;
                GetOrthoVectors(Header.Normal, Tangent, Bitangent);
                SG.Direction = normalize(Direction.x * Tangent + Direction.y * Bitangent + Direction.z * Header.Normal);
            }
            WriteBasisData(BasisOffset + LocalID, SG);
        }
    }
}

// Allocate update rays for each probe
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_AllocateUpdateRays (int DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0]) {
        return;
    }
    // NOTE: the allocation number must be a multiple of WAVE_SIZE
    // NOTE: and no greater than SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE
    int2 ProbeIndex = int2(DispatchID % MI.TileDimensions.x, DispatchID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    // Invalid probe
    if(Header.LinearDepth <= 0) {
        g_RWProbeUpdateRayCountBuffer[DispatchID] = 0;
        return ;
    }
    // Naive strategy: allocate more rays for probes that failed in reprojection
    float Trust = g_RWProbeHistoryTrustTexture[ProbeIndex];
    int   Bonus = (1.f - Trust) * 3;
    g_RWProbeUpdateRayCountBuffer[DispatchID] = min(WAVE_SIZE * max(1, Bonus), SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE);
}

// A scan sum is performed to accumulate allocated raycount for each probe

[numthreads(1, 1, 1)]
void SSRC_SetUpdateRayCount () {
    int ProbeCount = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0];
    g_RWUpdateRayCountBuffer[0] = g_RWProbeUpdateRayOffsetBuffer[ProbeCount];
}


// TODO: Should we study from Lumen to use a large number?
#define MIN_PDF_TO_TRACE 2e-3f //1e-1f

groupshared SGData LocalSGData[SSRC_MAX_NUM_BASIS_PER_PROBE];
groupshared float LocalSGSize[SSRC_MAX_NUM_BASIS_PER_PROBE];
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_SampleUpdateRays (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {

    const float Epsilon = 1e-6f;

    // We assume that ray count is always a multiple of WAVE_SIZE
    int  ProbeIndex1 = GroupID;
    int2 ProbeIndex  = int2(ProbeIndex1 % MI.TileDimensions.x, ProbeIndex1 / MI.TileDimensions.x);
    int  RayCount    = g_RWProbeUpdateRayCountBuffer[ProbeIndex1];
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    int  BasisCount  = GetProbeBasisCountFromClass(Header.Class);
    // Reuse the shmem from reprojection kernel
#if SSRC_MAX_NUM_BASIS_PER_PROBE > WAVE_SIZE
#error "SSRC_MAX_NUM_BASIS_PER_PROBE must be less than or equal to WAVE_SIZE"
#endif
    {
        int BasisRank = LocalID;
        if(BasisRank < BasisCount) {
            SGData SG = FetchBasisData(Header.BasisOffset + BasisRank);
            LocalSGData[BasisRank] = SG;
            float SGSize = SGIntegrate(SG.Lambda) * dot(SG.Color, 1.f.xxx);
            LocalSGSize[BasisRank] = SGSize + Epsilon;
        } else if(BasisRank < SSRC_MAX_NUM_BASIS_PER_PROBE) {
            LocalSGSize[BasisRank] = 0;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    SGData IrradianceSG = GetIrradianceSG(Header.Normal, GetScreenProbeIrradiance(ProbeIndex));
    float IrradianceSize = SGIntegrate(IrradianceSG.Lambda) * dot(IrradianceSG.Color, 1.f.xxx) + Epsilon;
    float ThreadSizeSums[SSRC_MAX_NUM_BASIS_PER_PROBE];
    ThreadSizeSums[0] = 0;
    if(BasisCount > 0) ThreadSizeSums[0] = LocalSGSize[0];
    [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE-1)]
    for(int i = 1; i < BasisCount; i++) {
        ThreadSizeSums[i] = ThreadSizeSums[i-1] + LocalSGSize[i];
    }
    float SumSizeBasis = BasisCount > 0 ? ThreadSizeSums[BasisCount - 1] : 0;
    float SumSize = SumSizeBasis + IrradianceSize;
    
    Random rng = MakeRandom(GroupID * WAVE_SIZE + LocalID, MI.FrameSeed);
    // Sample ray SG
#if SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE % WAVE_SIZE != 0
#error "SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE must be a multiple of WAVE_SIZE"
#endif
    [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
    for(int RayRankBase = 0; RayRankBase < RayCount; RayRankBase += WAVE_SIZE) {
        // We assume that ray count is always a multiple of WAVE_SIZE
        int RayRank = RayRankBase + LocalID;
        float u    = rng.rand();
        float U    = u * SumSize;
        int BasisRank = BasisCount;
        [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE)]
        for(int i = 0; i<BasisCount; i++) {
            if(U < ThreadSizeSums[i]) {
                BasisRank = i;
                break;
            }
        }
        // TODO: weight the cosine term when sampling
        // Really necessary? Lumen may not be doing that.
        float3 RayDirection, SampleNormal;
        float2 u2 = rng.rand2();
        if(BasisRank == BasisCount) {
            // Sample from the irradiance (uniform hemisphere)
            RayDirection  = CosineWeightedSampleHemisphere(u2);//UniformSampleHemisphere(u2);
            SampleNormal  = Header.Normal;
        } else {
            SGData SG = LocalSGData[BasisRank];
            float RayPdfTmp;
            RayDirection = SampleSG(u2, SG.Lambda, RayPdfTmp);
            SampleNormal = SG.Direction;
        }
        float3 Tangent, Bitangent;
        GetOrthoVectors(SampleNormal, Tangent, Bitangent);
        RayDirection = normalize(Tangent * RayDirection.x + Bitangent * RayDirection.y + SampleNormal * RayDirection.z);
        // Compute ray pdf
        float  RayPdf = 0;
        {
            [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE)]
            for(int i = 0; i < BasisCount; i++) {
                SGData SG = LocalSGData[i];
                RayPdf += LocalSGSize[i] * SampleSGPDF(SG.Lambda, dot(RayDirection, SG.Direction));
            }
            if(dot(RayDirection, Header.Normal) > 0) {
                RayPdf += CosineWeightedSampleHemispherePDF(RayDirection, Header.Normal) * IrradianceSize;
            }
            RayPdf = RayPdf / max(SumSize, Epsilon);
        }
        if(MI.NoImportanceSampling) {
            RayPdf = UniformSampleHemispherePdf();
            RayDirection = UniformSampleHemisphere(u2);
            float3 Tangent, Bitangent;
            GetOrthoVectors(Header.Normal, Tangent, Bitangent);
            RayDirection = normalize(Tangent * RayDirection.x + Bitangent * RayDirection.y + Header.Normal * RayDirection.z);
        }
        // Pack the ray
        // TODO jitter the ray origin ? may be useless
        if(RayPdf >= MIN_PDF_TO_TRACE) {
            WriteUpdateRay(ProbeIndex, Header.ScreenCoords, RayRank, RayDirection, RayPdf);
        } else {
            // No need to do compressing since there're just a tiny number of rays being canceled
            WriteUpdateRay(ProbeIndex, Header.ScreenCoords, RayRank, 0, 0);
        }
    }
}


#define SSRC_DISPATCH_RAYS_GROUP_SIZE 8

[numthreads(1, 1, 1)]
void SSRC_GenerateTraceUpdateRays () {
    int ProbeCount = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0];
    int RayCount   = g_RWUpdateRayCountBuffer[0];
    DispatchRaysCommand dispatch_command_rays = (DispatchRaysCommand)0;
    dispatch_command_rays.ray_generation_shader_record = g_RTConstants.ray_generation_shader_record;
    dispatch_command_rays.miss_shader_table = g_RTConstants.miss_shader_table;
    dispatch_command_rays.hit_group_table = g_RTConstants.hit_group_table;
    dispatch_command_rays.callable_shader_table = g_RTConstants.callable_shader_table;
    dispatch_command_rays.width = RayCount;
    dispatch_command_rays.height = 1;
    dispatch_command_rays.depth = 1;
    g_RWDispatchRaysCommandBuffer[0] = dispatch_command_rays;

    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = 
        (RayCount + SSRC_DISPATCH_RAYS_GROUP_SIZE - 1) 
        / SSRC_DISPATCH_RAYS_GROUP_SIZE;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

void ScreenCacheUpdateHandleHit(uint DispatchID, inout ScreenCacheUpdatePayload payload, RayDesc ray, HitInfo hit_info)
{
    HashGridCache_Data data;
    data.eye_position = MI.CameraPosition;
    data.hit_position = ray.Origin + payload.hit_dist * ray.Direction;
    data.direction    = ray.Direction;
    data.hit_distance = payload.hit_dist;

    // Record hit distance
    g_RWUpdateRayLinearDepthBuffer[DispatchID] = data.hit_distance;

    uint tile_index;
    bool is_new_tile;
    uint cell_index = HashGridCache_InsertCell(data, tile_index, is_new_tile);

    if (cell_index != kGI10_InvalidId)
    {
        // Bump the cell's decay to the max. now that it's been 'touched'
        uint previous_tile_decay;
        InterlockedExchange(g_HashGridCache_DecayTileBuffer[tile_index], MI.FrameIndex, previous_tile_decay);

        HashGridCache_Visibility visibility;
        visibility.is_front_face   = hit_info.frontFace;
        visibility.instance_index  = hit_info.instanceIndex;
        visibility.geometry_index  = hit_info.geometryIndex;
        visibility.primitive_index = hit_info.primitiveIndex;
        visibility.barycentrics    = hit_info.barycentrics;

        // We update the cell index for later passes
        uint visibility_index;
        InterlockedAdd(g_HashGridCache_VisibilityCountBuffer[0], 1, visibility_index);
        g_HashGridCache_VisibilityBuffer[visibility_index]      = HashGridCache_PackVisibility(visibility);
        g_HashGridCache_VisibilityCellBuffer[visibility_index]  = cell_index;
        g_HashGridCache_VisibilityQueryBuffer[visibility_index] = DispatchID;

        // Write out bounds of visibility
        requestLightSampleLocation(data.hit_position);

        // If this cell is inside a new tile, we need to add the tile to the packed storage and clear its cells.
        if (is_new_tile)
        {
            uint packed_tile_index;
            InterlockedAdd(g_HashGridCache_PackedTileCountBuffer[0], 1, packed_tile_index);
            g_HashGridCache_PackedTileIndexBuffer[packed_tile_index] = tile_index;

            // Clear mip0 cells (others will be reset anyways by UpdateTiles)
            for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile_mip0; ++cell_offset)
            {
                uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
                g_HashGridCache_ValueBuffer[cell_index] = uint2(0, 0);
            }
        }

        // If we're the 1st invocation touching this cell (this frame), we want to clear the
        // scratch storage that'll be used for atomically updating the radiance.
        // The accumulation will be resolved in the 'UpdateTiles()' kernel to
        // avoid integer overflow.
        if (is_new_tile || previous_tile_decay != MI.FrameIndex)
        {
            uint update_tile_index;
            InterlockedAdd(g_HashGridCache_UpdateTileCountBuffer[0], 1, update_tile_index);
            g_HashGridCache_UpdateTileBuffer[update_tile_index] = tile_index;
        }

#ifdef DEBUG_HASH_CELLS
        // For debugging purposes, we need to be able to retrieve the position
        // & orientation of cells as we iterate the content of the cache.
        // So, write the packed cell descriptor out to memory in this case.
        if (is_new_tile)
        {
            // Clear debug cells (all mips)
            for (int cell_offset = 0; cell_offset < g_HashGridCacheConstants.num_cells_per_tile; ++cell_offset)
            {
                uint cell_index = HashGridCache_CellIndex(cell_offset, tile_index);
                g_HashGridCache_DebugCellBuffer[cell_index] = HashGridCache_ClearDebugCell();
            }
        }

        float4 packed_debug_cell;
        uint debug_cell_index = HashGridCache_PackDebugCell(data, tile_index, packed_debug_cell);

        // BE CAREFUL: writing to g_HashGridCache_DebugCellBuffer isn't atomic and several writings could occur
        uint previous_cell_decay;
        InterlockedExchange(g_HashGridCache_DecayCellBuffer[debug_cell_index], g_FrameIndex, previous_cell_decay);
        if (previous_cell_decay != g_FrameIndex)
        {
            g_HashGridCache_DebugCellBuffer[debug_cell_index] = packed_debug_cell;
        }
#endif // DEBUG_HASH_CELLS
    }
}

void ScreenCacheUpdateHandleMiss(inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    payload.sky_sample = g_EnvironmentBuffer.SampleLevel(g_TextureSampler, ray.Direction, 0.0f).xyz;
}

void ScreenCacheUpdateTraceRayInline(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    ClosestRayQuery ray_query = TraceRay<ClosestRayQuery>(ray);

    // If we hit some geometry, we append a new world-space hash-grid cache query
    if (ray_query.CommittedStatus() == COMMITTED_NOTHING)
    {
        payload.hit_dist = ray_query.CommittedRayT();
        ScreenCacheUpdateHandleMiss(payload, ray);
    }
    else
    {
        payload.hit_dist = ray_query.CommittedRayT();
        ScreenCacheUpdateHandleHit(did, payload, ray, GetHitInfoRtInlineCommitted(ray_query));
    }
}

void ScreenCacheUpdateTraceRayRt(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
    TraceRay(g_Scene, RAY_FLAG_NONE, 0xFFu, 0, 0, 0, ray, payload);
}

void ScreenCacheUpdateTraceRay(uint did, inout ScreenCacheUpdatePayload payload, RayDesc ray)
{
#if USE_INLINE_RT
    ScreenCacheUpdateTraceRayInline(did, payload, ray);
#else
    ScreenCacheUpdateTraceRayRt(did, payload, ray);
#endif
}

// Trace visibility rays to generate intersections for secondary vertices
void SSRC_TraceUpdateRays (uint DispatchID) {
    int ProbeCount = MI.UniformScreenProbeCount + g_RWAdaptiveProbeCountBuffer[0];
    int RayCount   = g_RWProbeUpdateRayOffsetBuffer[ProbeCount];
    if(DispatchID >= RayCount) return ;
    
    // Unpack ray data
    int2   ProbeIndex = UnpackUint16x2(g_RWUpdateRayProbeBuffer[DispatchID / WAVE_SIZE]);

    float3 GeometryNormal = GetScreenProbeNormal(ProbeIndex);
    float3 RayOrigin = offsetPosition(GetScreenProbePosition(ProbeIndex), GeometryNormal);

    float3 RayDirection      = OctahedronToUnitVector(unpackUnorm2x16(g_RWUpdateRayDirectionBuffer[DispatchID]) * 2 - 1);
    float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[DispatchID]);
    float  InvPdf = RayRadianceInvPdf.w;

    // Early out if the ray is invalid / clipped for too tiny pdf.
    if(InvPdf == 0) return ;

    if(dot(RayDirection, GeometryNormal) < 0.0f) {
        // Learn negative samples.
        g_RWUpdateRayRadianceInvPdfBuffer[DispatchID] = PackFp16x4Safe(float4(0.0f.xxx, InvPdf));
        g_RWUpdateRayLinearDepthBuffer[DispatchID]    = 0.f;
        return ;
    }
    if(MI.DebugLight != 0) {
        float3 LightPos = MI.DebugLightPosition;
        float  DistSqr  = lengthSqr(LightPos - RayOrigin);
        float  R2       = MI.DebugLightSize * MI.DebugLightSize;
        float  MaxCosTheta = sqrt(DistSqr - R2) / sqrt(DistSqr);
        float  CosTheta = dot(normalize(LightPos - RayOrigin), RayDirection);
        float3 L = (CosTheta > MaxCosTheta) ? MI.DebugLightColor : 0.f;
        g_RWUpdateRayRadianceInvPdfBuffer[DispatchID] = PackFp16x4Safe(float4(L, InvPdf));
        float  RayLenSqr = DistSqr - R2;
        g_RWUpdateRayLinearDepthBuffer[DispatchID] = sqrt(RayLenSqr);
        return ;
    }

    // Trace a visibility ray only.
    RayDesc VisibilityRayDesc;
    VisibilityRayDesc.Origin = RayOrigin;
    VisibilityRayDesc.Direction = RayDirection;
    VisibilityRayDesc.TMin = 0.f;
    VisibilityRayDesc.TMax = MAX_HIT_DISTANCE;

    // Fallback to far plane if no intersection
    g_RWUpdateRayLinearDepthBuffer[DispatchID]    = MI.CameraFar;

    ScreenCacheUpdatePayload payload;
    payload.sky_sample = float3(0.0f, 0.0f, 0.0f);
    ScreenCacheUpdateTraceRay(
        DispatchID,
        payload, VisibilityRayDesc
    );
    // Fallback to sky sample if no intersection
    g_RWUpdateRayRadianceInvPdfBuffer[DispatchID] = PackFp16x4Safe(float4(payload.sky_sample, InvPdf));
    
}

[numthreads(SSRC_DISPATCH_RAYS_GROUP_SIZE, 1, 1)]
void SSRC_TraceUpdateRaysMain (uint DispatchID : SV_DispatchThreadID) {
    SSRC_TraceUpdateRays(DispatchID);
}


// HiZ required for injection culling
[numthreads(8, 8, 1)]
void PrecomputeHiZ (int2 DispatchID : SV_DispatchThreadID) {
    int2 Dimensions;
    g_RWHiZ_Out.GetDimensions(Dimensions.x, Dimensions.y);
    if(any(DispatchID >= Dimensions)) {
        return;
    }
    float X00 = g_RWHiZ_In[int2(2 * DispatchID.x + 0, 2 * DispatchID.y + 0)].x;
    float X01 = g_RWHiZ_In[int2(2 * DispatchID.x + 0, 2 * DispatchID.y + 1)].x;
    float X10 = g_RWHiZ_In[int2(2 * DispatchID.x + 1, 2 * DispatchID.y + 0)].x;
    float X11 = g_RWHiZ_In[int2(2 * DispatchID.x + 1, 2 * DispatchID.y + 1)].x;
#ifdef HIZ_MIN
    float X0 = min(X00, X01);
    float X1 = min(X10, X11);
    float X = min(X0, X1);
#else
    if(X00 == 1.f) X00 = 0.f;
    if(X01 == 1.f) X01 = 0.f;
    if(X10 == 1.f) X10 = 0.f;
    if(X11 == 1.f) X11 = 0.f;
    float X0 = max(X00, X01);
    float X1 = max(X10, X11);
    float X = max(X0, X1);
    if(X == 0.f) X = 1.f;
#endif
    g_RWHiZ_Out[DispatchID] = X;
}


[numthreads(SSRC_TILE_SIZE, SSRC_TILE_SIZE, 1)]
void SSRC_ReprojectPreviousUpdateError (int2 DispatchID : SV_DispatchThreadID) {
    if(any(DispatchID >= MI.ScreenDimensions)) {
        return;
    }

    float3 NormalPrev = g_GeometryNormalTexture.Load(int3(DispatchID, 0)).xyz;
    bool   IsSkyPixel = (dot(NormalPrev, NormalPrev) == 0.0f ? true : false);

    if (IsSkyPixel)
    {
        g_RWUpdateErrorSplatTexture[DispatchID] = 0.f;
        return;
    }
    float3 Normal = normalize(2.f * NormalPrev - 1.f);

    // Reproject the update error texture from previous frame to current frame
    float4 packed_visibility = g_VisibilityTexture.Load(int3(DispatchID, 0));
    float2 Barycentrics      = packed_visibility.xy;
    int   InstanceIndex      = asint(packed_visibility.z);
    int   PrimitiveIndex      = asint(packed_visibility.w);

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[InstanceIndex];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    TriangleNormUV vertices = fetchVerticesNormUV(mesh, PrimitiveIndex);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);

    vertices.n0 = transformNormal(vertices.n0, transform);
    vertices.n1 = transformNormal(vertices.n1, transform);
    vertices.n2 = transformNormal(vertices.n2, transform);

    float3   world    = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);

    float3 homogeneous = transformPointProjection(world, MI.CameraProjView);

    float2 UV          = 0.5f * float2(homogeneous.x, -homogeneous.y) + 0.5f;
    float  Depth       = homogeneous.z;

    // Severe precision loss here if we use the following reprojection method
    // float2 UV = (float2(DispatchID) + 0.5f) * MI.ScreenDimensionsInv;
    // float Depth = g_DepthTexture.Load(int3(UV, 0)).x;
    // float3 Normal = normalize(2.f * g_GeometryNormalTexture.Load(int3(UV, 0)).xyz - 1.f);
    // float3 homogeneous = float3(UV2NDC2(UV), Depth);

    if (all(UV > 0.0f) && all(UV < 1.0f) && Depth > 0.0f && Depth < 1.0f)
    {
        float2 previous_uv = UV - g_VelocityTexture.SampleLevel(g_NearestSampler, UV, 0.0f).xy;

        if (all(previous_uv > 0.0f) && all(previous_uv < 1.0f))
        {
            float3 homogeneous2 = transformPointProjection(homogeneous, MI.Reprojection);
            homogeneous2.z      = GetLinearDepth(homogeneous2.z);

            float  previous_depth  = GetLinearDepth(g_PreviousDepthTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).x);
            float3 previous_normal = normalize(2.0f * g_PreviousGeometryNormalTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz - 1.0f);

            if (dot(previous_normal, Normal) > 0.5f && abs(previous_depth - homogeneous2.z) / homogeneous2.z < 5e-2f)
            {
                // Using linear sampler in reprojection can significantly increase the reprojected error, why?
                float PreviousError = g_PreviousUpdateErrorSplatTexture.SampleLevel(g_NearestSampler, previous_uv, 0).x;
                g_RWUpdateErrorSplatTexture[DispatchID] = PreviousError;
                return; 
            }
        }
    }
    
    // TODO allocate a initial weight for the update error
    // FIXME
    g_RWUpdateErrorSplatTexture[DispatchID] = 0.f;
}

// UpdateErrorSplatTexture is later mipmapped.

[numthreads(WAVE_SIZE, 1, 1)]
void ClearReservoirs(in uint did : SV_DispatchThreadID)
{
    g_Reservoir_HashBuffer[did]      = 0;
    g_Reservoir_HashCountBuffer[did] = 0;
}


[numthreads(WAVE_SIZE, 1, 1)]
void GenerateReservoirs(in uint DispatchID : SV_DispatchThreadID)
{
    if (DispatchID >= g_HashGridCache_VisibilityCountBuffer[0])
    {
        return; // out of bounds
    }

    // Load our visibility sample
    float4                   packed_visibility = g_HashGridCache_VisibilityBuffer[DispatchID];
    HashGridCache_Visibility visibility        = HashGridCache_UnpackVisibility(packed_visibility);

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[visibility.instance_index];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index + visibility.geometry_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    TriangleNormUV vertices = fetchVerticesNormUV(mesh, visibility.primitive_index);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);

    vertices.n0 = transformNormal(vertices.n0, transform);
    vertices.n1 = transformNormal(vertices.n1, transform);
    vertices.n2 = transformNormal(vertices.n2, transform);

    float3   world    =                                                       interpolate(vertices.v0, vertices.v1, vertices.v2, visibility.barycentrics);
    float3   normal   = (visibility.is_front_face ? 1.0f : -1.0f) * normalize(interpolate(vertices.n0, vertices.n1, vertices.n2, visibility.barycentrics));
    Material material = g_MaterialBuffer[instance.material_index];

    // Recover the ray origin
    uint query_index = g_HashGridCache_VisibilityQueryBuffer[DispatchID];
    // Queries are indexed with ray index
    int2 ProbeIndex = UnpackUint16x2(g_RWUpdateRayProbeBuffer[query_index / WAVE_SIZE]);
    float3 origin = GetScreenProbePosition(ProbeIndex);
    float2 mesh_uv = interpolate(vertices.uv0, vertices.uv1, vertices.uv2, visibility.barycentrics);

    // Patch the screen space cache with some emissivity information:
    // We bypass the hash-grid cache entirely here, as adding emissive information to the cells
    // effectively enlarges the area light (due to the spatial nature of the grid) and leads to
    // light leaks and generally poorer visuals.

    // always assume 2-sided emissive surfaces
    if (/*visibility.is_front_face &&*/ dot(material.emissivity.xyz, material.emissivity.xyz) > 0.0f)
    {
        MaterialEmissive emissive = MakeMaterialEmissive(material, mesh_uv);
        float4 RadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[query_index]);
        RadianceInvPdf.xyz = emissive.emissive;
        g_RWUpdateRayRadianceInvPdfBuffer[query_index] = PackFp16x4Safe(RadianceInvPdf);
        return; // do not continue past an emissive surface
    }

    // We can perform some temporal radiance feedback from last frame if direct lighting was
    // evaluated.
    // If successful, we inject the reprojected radiance into the cache so it can be re-used
    // by neighbor vertices but bypass the filtered readback as the sample is already denoised.
    {
        float3 homogeneous = transformPointProjection(world, MI.CameraProjView);

        float2 uv    = 0.5f * float2(homogeneous.x, -homogeneous.y) + 0.5f;
        float  depth = homogeneous.z;

        if (all(uv > 0.0f) && all(uv < 1.0f) && depth > 0.0f && depth < 1.0f)
        {
            float2 previous_uv = uv - g_VelocityTexture.SampleLevel(g_NearestSampler, uv, 0.0f).xy;

            if (all(previous_uv > 0.0f) && all(previous_uv < 1.0f))
            {
                float3 homogeneous2 = transformPointProjection(float3(2.0f * float2(uv.x, 1.0f - uv.y) - 1.0f, depth), MI.Reprojection);
                homogeneous2.z      = GetLinearDepth(homogeneous2.z);

                float  previous_depth  = GetLinearDepth(g_PreviousDepthTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).x);
                float3 previous_normal = normalize(2.0f * g_PreviousGeometryNormalTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz - 1.0f);

                if (dot(previous_normal, normal) > 5e-1f && abs(previous_depth - homogeneous2.z) / homogeneous2.z < 5e-2f)
                {

                    float3 previous_lighting = g_PrevCombinedIlluminationTexture.SampleLevel(g_NearestSampler, previous_uv, 0.0f).xyz;

                    uint  cell_index         = g_HashGridCache_VisibilityCellBuffer[DispatchID];
                    uint4 quantized_radiance = HashGridCache_QuantizeRadiance(previous_lighting);
#ifdef ENABLE_INDIRECT
                    float4 RayRadianceInvPdf    = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[query_index]);
                    RayRadianceInvPdf.xyz      += previous_lighting;
                    g_RWUpdateRayRadianceInvPdfBuffer[query_index] = PackFp16x4Safe(RayRadianceInvPdf);
#endif // ENABLE_INDIRECT
                    if (dot(previous_lighting, previous_lighting) > 0.0f)
                    {
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0], quantized_radiance.x);
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1], quantized_radiance.y);
                        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2], quantized_radiance.z);
                    }
                    InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3], quantized_radiance.w);

                    return; // we can skip the shadow ray for this sample :)
                }
            }
        }
    }

    float3 view_direction = normalize(origin - world);

    // Sample new lights
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 1.5f);
    MaterialEvaluated material2 = MakeMaterialEvaluated(material, mesh_uv);
    MaterialBRDF materialBRDF = MakeMaterialBRDF(material2);
    // Make the seed different from the one used in TraceUpdateRays
    Random random = MakeRandom(DispatchID ^ 0x8a197727, MI.FrameSeed);
    LightSampler lightSampler = MakeLightSampler(random);
    Reservoir reservoir = lightSampler.sampleLightListCone<kReservoir_SampleCount>(world, normal, view_direction, solid_angle, materialBRDF);

    if (!reservoir.isValid())
    {
        return;
    }

    // Append our resampled shadow ray, generate a ray index for later tracing and updates
    uint ray_index;
    InterlockedAdd(g_HashGridCache_VisibilityRayCountBuffer[0], 1, ray_index);

    g_HashGridCache_VisibilityRayBuffer[ray_index] = DispatchID;   // compact the surviving shadow rays

    // Here, we check that the ray has traversed at least a full hash cell
    // before hitting something.
    // If it hasn't, we bypass the filtering from the cache (although we
    // still accumulate the contribution into the cell).
    //
    // This avoids possible light leaks in the following configuration:
    //
    //    bright area   +--------------+
    //                  |    dark area |
    //                  | |            |
    //                  | x            |
    //                  |/|            |
    //                 /|\             |
    //                / | eye          |
    // bright radiance  +--------------+
    //
    // Here the point 'x' is reached after bouncing from the first vertex.
    // (i.e., it is a 2nd vertex, the ones filtered through the hash grid)
    // Because it is close to the wall and has a similar direction to the
    // 'bright radiance' event, both vertices will share the same hash cell
    // leading to a light leak on the bounced lighting from the inner wall.
    //
    // Such a scenario mostly occurs if the length of the ray connecting
    // the 2nd vertex is less than the size of the hash cell being used.
    // So, we detect this case and flag a bypass of the filtered readback.
    float cell_size  = HashGridCache_GetCellSize(world);
    float ray_length = distance(origin, world);

    if (ray_length < cell_size)
    {
        g_HashGridCache_VisibilityRayBuffer[ray_index] |= 0x80000000u;
    }

    // Insert the reservoir into the hash table
#ifdef USE_RESAMPLING
    float3 b1, b2;
    GetOrthoVectors(normal, b1, b2);
    float2 jitter = 2.0f * random.rand2() - 1.0f;
    jitter *= Reservoir_GetCellSize(world) * kReservoir_SpatialJitter;
    Reservoir_InsertEntry(ray_index, world + jitter.x * b1 + jitter.y * b2);

    g_Reservoir_IndirectSampleBuffer[ray_index]       = Reservoir_PackIndirectSample(origin, world);
    g_Reservoir_IndirectSampleNormalBuffer[ray_index] = packNormal(normal);
#endif // USE_RESAMPLING

    // Write the results out to memory
    g_Reservoir_IndirectSampleMaterialBuffer[ray_index]  = packMaterial(material2);  // cannot afford to re-fetch the full material each time, so we need to approximate it...
    g_Reservoir_IndirectSampleReservoirBuffer[ray_index] = packReservoir(reservoir);
}


[numthreads(WAVE_SIZE, 1, 1)]
void CompactReservoirs(in uint did : SV_DispatchThreadID)
{
    if (did >= g_Reservoir_HashListCountBuffer[0])
    {
        return; // out of bounds
    }

    uint4 list_element = g_Reservoir_HashListBuffer[did];
    uint  value_index  = g_Reservoir_HashIndexBuffer[list_element.y] + list_element.z;

    g_Reservoir_HashValueBuffer[value_index] = list_element.x;
}

// Temporal resampling only
[numthreads(WAVE_SIZE, 1, 1)]
void ResampleReservoirs(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    // Load our shading information
    float3 origin, world;
    Reservoir_UnpackIndirectSample(g_Reservoir_IndirectSampleBuffer[did], origin, world);

    float3       normal    = unpackNormal(g_Reservoir_IndirectSampleNormalBuffer[did]);
    MaterialBRDF material  = unpackMaterial(g_Reservoir_IndirectSampleMaterialBuffer[did]);
    Reservoir    reservoir = unpackReservoir(g_Reservoir_IndirectSampleReservoirBuffer[did]);

    // Normalize the sample count M (a.k.a. confidence weight) with the initial sample count for simplicity.
    reservoir.M = 1.0f;

    // Make the random numbers different from previous samples
    Random random = MakeRandom(did + MI.ScreenDimensions.x * MI.ScreenDimensions.y, MI.FrameSeed);

    // Locate our hash table cell
    float3 b1, b2;
    GetOrthoVectors(normal, b1, b2);
    float2 jitter = 2.0f * random.rand2() - 1.0f;
    jitter *= Reservoir_GetCellSize(world) * kReservoir_SpatialJitter;
    uint entry_index = Reservoir_FindPreviousEntry(world + jitter.x * b1 + jitter.y * b2);

    if (entry_index == kGI10_InvalidId)
    {
        return; // no previous reservoir cell - temporal resampling failed :'(
    }

    uint index = g_Reservoir_PreviousHashIndexBuffer[entry_index];
    uint count = g_Reservoir_PreviousHashCountBuffer[entry_index];

    // Stochastically iterate the cell content
    uint max_count = 4;
    uint increment = (count + max_count - 1) / max_count;
    uint offset    = random.randInt(increment);

    // And combine the reservoirs
    float3 view_direction = normalize(origin - world);
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 12000.0f);
    ReservoirUpdater updater = MakeReservoirUpdater();
    mergeReservoirsCone(updater, reservoir, random, material, world, normal, view_direction, solid_angle);
    for (uint i = 0; i < count; i += increment)
    {
        // Load up the iterated reservoir
        uint      reservoir_index = g_Reservoir_PreviousHashValueBuffer[index + ((i + offset) % count)];
        Reservoir reservoir2      = unpackReservoir(g_Reservoir_PreviousIndirectSampleReservoirBuffer[reservoir_index]);
        float3    filter_normal   = unpackNormal(g_Reservoir_PreviousIndirectSampleNormalBuffer[reservoir_index]);

        if (!reservoir2.isValid())
        {
            continue;   // skip invalid reservoir(s)
        }

        // Bilaterally filter the neighbor reservoir
        float bilateral_weight = max(dot(normal, filter_normal), 0.0f);
        bilateral_weight = squared(squared(bilateral_weight)); // make it steep
        if (bilateral_weight < kReservoir_BilateralThreshold) continue;

        // And combine it with our current reservoir
        Reservoir_ClampPrevious(reservoir2);
        mergeReservoirsCone(updater, reservoir2, random, material, world, normal, view_direction, solid_angle);
    }

    if (!updater.reservoir.M)
    {
        return; // reprojection failed
    }

    // Finalize our reservoir
    reservoir = updater.reservoir;

    // And write it out to memory
    g_Reservoir_IndirectSampleReservoirBuffer[did] = packReservoir(reservoir);
}

void PopulateCellsHandleHit(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    payload.lighting    = float3(0.0f, 0.0f, 0.0f);

    Reservoir reservoir = payload.reservoir;
    // Update our reservoir cache for next frame's temporal resampling
#ifdef USE_RESAMPLING
    reservoir.W = 0.0f; // invalidate the reservoir

    g_Reservoir_IndirectSampleReservoirBuffer[did] = packReservoir(reservoir);
#endif // USE_RESAMPLING
}

void PopulateCellsHandleMiss(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    float3       light_radiance = payload.lighting;
    float        light_weight   = payload.reservoir.W;
    int2         ProbeIndex     = UnpackUint16x2(g_RWUpdateRayProbeBuffer[payload.query_index]);
    MaterialBRDF material       = unpackMaterial(g_Reservoir_IndirectSampleMaterialBuffer[did]);

    // Recover the ray origin
    float3       origin = GetScreenProbePosition(ProbeIndex);

    // And evaluate our lighting
    payload.lighting =
        evaluateBRDF(material, payload.normal, normalize(origin - payload.world), ray.Direction)
        * light_radiance * light_weight;
}

void PopulateCellsTraceRayInline(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    ShadowRayQuery ray_query = TraceRay<ShadowRayQuery>(ray);

    if (ray_query.CommittedStatus() == COMMITTED_NOTHING)
    {
        PopulateCellsHandleMiss(did, payload, ray);
    }
    else
    {
        PopulateCellsHandleHit(did, payload, ray);
    }
}

void PopulateCellsTraceRayRt(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
    TraceRay(g_Scene, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH, 0xFFu, 0, 0, 0, ray, payload);
}

void PopulateCellsTraceRay(uint did, inout PopulateCellsPayload payload, RayDesc ray)
{
#if USE_INLINE_RT
    return PopulateCellsTraceRayInline(did, payload, ray);
#else
    return PopulateCellsTraceRayRt(did, payload, ray);
#endif
}

// Light sampling completed, actually trace a shadow ray for each hash grid cache query.
void PopulateCells(uint did)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    uint                     visibility_index = (g_HashGridCache_VisibilityRayBuffer[did] & ~0x80000000u);
    HashGridCache_Visibility visibility       = HashGridCache_UnpackVisibility(g_HashGridCache_VisibilityBuffer[visibility_index]);

    uint query_index = g_HashGridCache_VisibilityQueryBuffer[visibility_index];

    // Reconstruct world-space position and normal
    Instance instance  = g_InstanceBuffer[visibility.instance_index];
    Mesh     mesh      = g_MeshBuffer[instance.mesh_index + visibility.geometry_index];
    float3x4 transform = g_TransformBuffer[instance.transform_index];

    Triangle vertices = fetchVertices(mesh, visibility.primitive_index);

    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);
    float3 world = interpolate(vertices.v0, vertices.v1, vertices.v2, visibility.barycentrics);
    float3 edge10 = vertices.v1 - vertices.v0;
    float3 edge20 = vertices.v2 - vertices.v0;
    float3 normal = normalize(transformNormal(cross(edge10, edge20) * (visibility.is_front_face ? 1.0f : -1.0f), transform));

    // Retrieve the light sample that we should use for our shadow ray
    Reservoir reservoir    = unpackReservoir(g_Reservoir_IndirectSampleReservoirBuffer[did]);

    // Decode the light sample from our reservoir
    float3 direction, light_position;
    // Approximate visible light surface based on number of samples being used
    const float solid_angle = FOUR_PI / (kReservoir_SampleCount * 12000.0f);
    Light selected_light = getLight(reservoir.lightSample.index);
    float3 light_radiance = evaluateLightConeSampled(selected_light, world, reservoir.lightSample.sampleParams, solid_angle, direction, light_position);

    // Traverse the BVH
    RayDesc ray_desc;
    ray_desc.Direction = direction;
    ray_desc.Origin    = offsetPosition(world, normal);
    ray_desc.TMin      = 0.0f;
    ray_desc.TMax      = hasLightPosition(selected_light) ? length(light_position - ray_desc.Origin) : FLT_MAX;

    PopulateCellsPayload payload;
    payload.query_index = query_index;
    payload.world       = world;
    payload.normal      = normal;
    payload.lighting    = light_radiance;
    payload.reservoir   = reservoir;
    PopulateCellsTraceRay(did, payload, ray_desc);

    // And update the hash-grid cell payload
    uint  cell_index         = g_HashGridCache_VisibilityCellBuffer[visibility_index];
    uint4 quantized_radiance = HashGridCache_QuantizeRadiance(payload.lighting);

    if (dot(payload.lighting, payload.lighting) > 0.0f)
    {
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0], quantized_radiance.x);
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1], quantized_radiance.y);
        InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2], quantized_radiance.z);
    }
    InterlockedAdd(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3], quantized_radiance.w);

    // In some cases, we want to bypass the cache to avoid light leaks;
    // so we simply patch the screen probes directly and invalidate the
    // cache connection.
    bool is_bypass_cache = ((g_HashGridCache_VisibilityRayBuffer[did] >> 31) != 0);

    if (is_bypass_cache)
    {
        float4 RadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[query_index]);
        RadianceInvPdf.xyz   += payload.lighting;
        g_RWUpdateRayRadianceInvPdfBuffer[query_index] = PackFp16x4Safe(RadianceInvPdf);
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void PopulateCellsMain(in uint did : SV_DispatchThreadID)
{
    PopulateCells(did);
}

// BE CAREFUL: we assume
//             UPDATE_TILES_NOT_SLICED_GROUP_* >= g_HashGridCacheConstants.size_tile_mip0
//             UPDATE_TILES_NOT_SLICED_GROUP_*  % g_HashGridCacheConstants.size_tile_mip0 == 0
//
#define UPDATE_TILES_GROUP_X 8
#define UPDATE_TILES_GROUP_Y 8
#define UPDATE_TILES_GROUP_SIZE (UPDATE_TILES_GROUP_X * UPDATE_TILES_GROUP_Y)

groupshared uint2 lds_UpdateTiles_ValueBuffer[UPDATE_TILES_GROUP_X][UPDATE_TILES_GROUP_Y];

[numthreads(1, 1, 1)]
void GenerateUpdateTilesDispatch()
{
    uint num_tiles_by_group = UPDATE_TILES_GROUP_SIZE / g_HashGridCacheConstants.num_cells_per_tile_mip0;

    DispatchCommand dispatch_command;
    dispatch_command.num_groups_x = (g_HashGridCache_UpdateTileCountBuffer[0] + num_tiles_by_group - 1) / num_tiles_by_group;
    dispatch_command.num_groups_y = 1;
    dispatch_command.num_groups_z = 1;
    dispatch_command.padding = 0;
    g_RWDispatchCommandBuffer[0] = dispatch_command;
}

[numthreads(UPDATE_TILES_GROUP_X, UPDATE_TILES_GROUP_Y, 1)]
void UpdateTiles(in uint group_id : SV_GroupID, in uint2 group_thread_id : SV_GroupThreadID)
{
    // A group cover from 1 tile/subgroup (8x8) to 64 tiles/subgroups (1x1)
    uint2 subgroup_id        = group_thread_id / g_HashGridCacheConstants.size_tile_mip0;
    uint2 subgroup_thread_id = group_thread_id % g_HashGridCacheConstants.size_tile_mip0;
    uint2 subgroup_size      = uint2(UPDATE_TILES_GROUP_X, UPDATE_TILES_GROUP_Y) / g_HashGridCacheConstants.size_tile_mip0;
    uint  update_tile_index  = group_id * subgroup_size.x * subgroup_size.y +
                               subgroup_id.y * subgroup_size.x +
                               subgroup_id.x;

    if (update_tile_index >= g_HashGridCache_UpdateTileCountBuffer[0])
    {
        return;
    }

    uint tile_index = g_HashGridCache_UpdateTileBuffer[update_tile_index];

    // MIP 0
    {
        uint cell_index  = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 0);

        // Temporal accumulation
        float4 radiance     = HashGridCache_UnpackRadiance(g_HashGridCache_ValueBuffer[cell_index]);
        float4 new_radiance = HashGridCache_RecoverRadiance(uint4(g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2],
                                                                  g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3]));

        float sample_count = min(radiance.w + new_radiance.w, g_HashGridCacheConstants.max_sample_count);

        radiance     /= max(radiance.w, 1.0f);
        new_radiance /= max(new_radiance.w, 1.0f);

        if (radiance.w <= 0.0f)
        {
            radiance = new_radiance;
        }
        else
        {
            radiance = lerp(radiance, new_radiance, 1.0f / sample_count);
        }

        radiance *= sample_count;   // sample count is used as a hint for picking prefiltering amount

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;

        // Clear scratch
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 0] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 1] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 2] = 0;
        g_HashGridCache_UpdateCellValueBuffer[4 * cell_index + 3] = 0;
    }

    // MIP 1
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip1 > 0 && all((group_thread_id % 2) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 1);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance10 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 1][group_thread_id.y + 0];
        uint2 packed_radiance01 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 1];
        uint2 packed_radiance11 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 1][group_thread_id.y + 1];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance10);
        radiance += HashGridCache_UnpackRadiance(packed_radiance01);
        radiance += HashGridCache_UnpackRadiance(packed_radiance11);

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;
    }

    // MIP 2
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip2 > 0 && all((group_thread_id % 4) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 2);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance20 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 2][group_thread_id.y + 0];
        uint2 packed_radiance02 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 2];
        uint2 packed_radiance22 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 2][group_thread_id.y + 2];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance20);
        radiance += HashGridCache_UnpackRadiance(packed_radiance02);
        radiance += HashGridCache_UnpackRadiance(packed_radiance22);

        // Pack
        uint2 packed_radiance = HashGridCache_PackRadiance(radiance);
        lds_UpdateTiles_ValueBuffer[group_thread_id.x][group_thread_id.y] = packed_radiance;
        g_HashGridCache_ValueBuffer[cell_index] = packed_radiance;
    }

    // MIP 3
    GroupMemoryBarrierWithGroupSync();
    [branch]
    if(g_HashGridCacheConstants.size_tile_mip3 > 0 && all((group_thread_id % 8) == 0))
    {
        uint cell_index = HashGridCache_CellIndex(subgroup_thread_id, tile_index, 3);

        // Box filter
        uint2 packed_radiance00 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 0];
        uint2 packed_radiance40 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 4][group_thread_id.y + 0];
        uint2 packed_radiance04 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 0][group_thread_id.y + 4];
        uint2 packed_radiance44 = lds_UpdateTiles_ValueBuffer[group_thread_id.x + 4][group_thread_id.y + 4];

        float4 radiance = float4(0.f, 0.f, 0.f, 0.f);
        radiance += HashGridCache_UnpackRadiance(packed_radiance00);
        radiance += HashGridCache_UnpackRadiance(packed_radiance40);
        radiance += HashGridCache_UnpackRadiance(packed_radiance04);
        radiance += HashGridCache_UnpackRadiance(packed_radiance44);

        // Pack
        g_HashGridCache_ValueBuffer[cell_index] = HashGridCache_PackRadiance(radiance);
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void ResolveCells(in uint did : SV_DispatchThreadID)
{
    if (did >= g_HashGridCache_VisibilityRayCountBuffer[0])
    {
        return; // out of bounds
    }

    uint visibility_index = g_HashGridCache_VisibilityRayBuffer[did];

    if ((visibility_index >> 31) != 0)
    {
        return; // do not use filtered radiance
    }

    uint cell_index  = g_HashGridCache_VisibilityCellBuffer[visibility_index];
    uint query_index = g_HashGridCache_VisibilityQueryBuffer[visibility_index];

    float4 radiance = HashGridCache_FilteredRadiance(cell_index, false);

#ifdef ENABLE_INDIRECT
    float4 RadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[query_index]);
    RadianceInvPdf.xyz   += GIDenoiser_RemoveNaNs(radiance.xyz / max(radiance.w, 1.0f));
    g_RWUpdateRayRadianceInvPdfBuffer[query_index] = PackFp16x4Safe(RadianceInvPdf);
#endif
}


int GetBasisRankToUpdate (int ProbeBasisCount) {
    return MI.FrameIndex % ProbeBasisCount;
}

float HeuristicSGDirectionBias (float3 SG_Direction, float3 Direction) {
    return 0.6f + dot(SG_Direction, Direction) * 0.4f;
}

// Update the probe cache
groupshared float3 LocalEvaluatedRadiance[SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE];
groupshared float3 LocalDColorPrefixSum[WAVE_SIZE];
groupshared float3 LocalDDirectionPrefixSum[WAVE_SIZE];
groupshared float  LocalAFactorSum[WAVE_SIZE];
groupshared float  LocalDLambdaPrefixSum[WAVE_SIZE];
// The coverage of each ray by SGs
groupshared float  LocalRayCoverage[SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE];

groupshared float  LocalSampleWeightPrefixSum[WAVE_SIZE];

// TODO classify the number of update rays to completely unroll many loops
[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_UpdateProbes (int LocalID : SV_GroupThreadID, int GroupID : SV_GroupID) {

    const float Epsilon = 1e-6f;

    int2 ProbeIndex = int2(GroupID % MI.TileDimensions.x, GroupID / MI.TileDimensions.x);
    ProbeHeader Header = GetScreenProbeHeader(ProbeIndex);
    // Thread group early out if the probe is not valid
    [branch]
    if(!Header.bValid) return ;

    int  BasisCount = GetProbeBasisCountFromClass(Header.Class);
    int  ProbeRayCount   = g_RWProbeUpdateRayCountBuffer[GroupID];
    int  ProbeRayOffset  = g_RWProbeUpdateRayOffsetBuffer[GroupID];
    float3 IrradianceColor = GetScreenProbeIrradiance(ProbeIndex);
    SGData IrradianceSG    = GetIrradianceSG(Header.Normal, IrradianceColor);
    
    if(LocalID < BasisCount) {
        LocalSGData[LocalID] = FetchBasisData(Header.BasisOffset + LocalID);
    }
    GroupMemoryBarrierWithGroupSync();

    float  ReprojectionTrust = g_RWProbeHistoryTrustTexture[ProbeIndex].x;

    // Re-initialize the probe if it is not trusted at all
    [branch]
    if(ReprojectionTrust == 0) {
        if(WaveIsFirstLane()) WriteScreenProbeIrradiance(ProbeIndex, 0.f.xxx);
        if(LocalID < BasisCount) {
            SGData SG = LocalSGData[LocalID];
            SG.Color     = 0.001f.xxx;
            // TODO better initialization
            SG.Lambda    = 0.65f + 0.2f * BasisCount;

            float3 Direction = InitHemiDirections(LocalID, BasisCount);
            float3 Normal    = Header.Normal;
            float3 Tangent, Bitangent;
            GetOrthoVectors(Normal, Tangent, Bitangent);
            float  Phi       = BlueNoise_Sample1D(int2(GroupID, LocalID), MI.FrameIndex, 2);
            SG.Direction = normalize(Direction.x * Tangent + Direction.y * Bitangent + Direction.z * Normal);

            SG.Depth     = 1.f;
            LocalSGData[LocalID] = SG;
        }
        GroupMemoryBarrierWithGroupSync();
    }

    // Precomputation
    float  SumSampleWeight = 0.f;
#if SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE % WAVE_SIZE != 0
#error "SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE must be a multiple of WAVE_SIZE"
#endif
    [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
    for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
        int RayRank  = RayRankBase + LocalID;
        int RayIndex = ProbeRayOffset + RayRank;
        float3 RayDirection      = OctahedronToUnitVector(unpackUnorm2x16(g_RWUpdateRayDirectionBuffer[RayIndex]) * 2 - 1);
        float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
        float3 RayRadiance       = RayRadianceInvPdf.xyz;
        float  InvPdf            = RayRadianceInvPdf.w;
        if(InvPdf > 0) {
            float3 EvaluatedRadiance = 0.f.xxx;
            float  Coverage = 0;
            [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE)]
            for(int i = 0; i < BasisCount; i++) {
                float Raw = EvaluateSGRaw(LocalSGData[i], RayDirection);
                EvaluatedRadiance += Raw * LocalSGData[i].Color;
                Coverage = max(Coverage, HeuristicSGDirectionBias(LocalSGData[i].Direction, RayDirection));
            }
            float3 EvaluatedIrradiance = EvaluateSG(IrradianceSG, RayDirection);
            LocalEvaluatedRadiance[RayRank] = EvaluatedRadiance + EvaluatedIrradiance;
            LocalRayCoverage[RayRank] = Coverage;
            SumSampleWeight += InvPdf;
        }
    }
    SumSampleWeight         = WaveActiveSum(SumSampleWeight) + Epsilon;
    GroupMemoryBarrierWithGroupSync();

    // TODO this must be very unstable
    float3 ImpactFactors = 1.f - ReprojectionTrust;

    // 1. Update irradiance SG.
    {
        float SumIrradianceAFactor = 0.f;
        float3 SumIrradianceColor   = 0.f.xxx;
        [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
        for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
            int RayRank  = RayRankBase + LocalID;
            int RayIndex = ProbeRayOffset + RayRank;
            float3 RayDirection      = OctahedronToUnitVector(unpackUnorm2x16(g_RWUpdateRayDirectionBuffer[RayIndex]) * 2 - 1);
            float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
            float3 RayRadiance       = RayRadianceInvPdf.xyz;
            float  InvPdf            = RayRadianceInvPdf.w;
            if(InvPdf > 0) {
                float  IrradianceRaw  = EvaluateSGRaw(IrradianceSG, RayDirection);
                float3 IrradianceEvaluated = IrradianceRaw * IrradianceSG.Color;
                float3 TargetRadiance = RayRadiance - LocalEvaluatedRadiance[RayRank] + IrradianceEvaluated;
                float  SampleWeight   = InvPdf;
                if(IrradianceRaw > 2e-2f) {
                    SumIrradianceAFactor     += 2.f * IrradianceRaw  * IrradianceRaw * SampleWeight;
                    SumIrradianceColor       += 2.f * TargetRadiance * IrradianceRaw * SampleWeight;
                }
                SumIrradianceColor += InvPdf * RayRadiance;
            }
        }
        SumIrradianceAFactor = WaveActiveSum(SumIrradianceAFactor) + Epsilon;
        SumIrradianceColor   = WaveActiveSum(SumIrradianceColor);
        // The chosen thread to update the irradiance
        if(WaveIsFirstLane() && MI.CacheUpdate_SGColor) {
            float3 NewProbeIrradiance = lerp(IrradianceColor, SumIrradianceColor / SumIrradianceAFactor, min(MI.CacheUpdateLearningRate + ImpactFactors.x, 1.f));
            NewProbeIrradiance = max(NewProbeIrradiance, 0.00001f);
            WriteScreenProbeIrradiance(ProbeIndex, NewProbeIrradiance);
        }
    }

    // 2.Update the SG direction first 
    [branch]
    if(MI.CacheUpdate_SGDirection) {
        float3 SumDirection = 0.f;
        // Pick one basis to update direction
        int BasisRankToUpdate = GetBasisRankToUpdate(BasisCount);
        SGData SG_D = LocalSGData[BasisRankToUpdate];
        SGData SG_O;
        [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
        for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
            int RayRank = RayRankBase + LocalID;
            int RayIndex = ProbeRayOffset + RayRank;
            float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
            float3 RayDirection      = OctahedronToUnitVector(unpackUnorm2x16(g_RWUpdateRayDirectionBuffer[RayIndex]) * 2 - 1);
            float3 RayRadiance       = RayRadianceInvPdf.xyz;
            float  InvPdf            = RayRadianceInvPdf.w;
            if(InvPdf > 0) {
                float  SGEvaluatedRaw      = EvaluateSGRaw(SG_D, RayDirection);
                float3 SGEvaluatedRadiance = SGEvaluatedRaw * SG_D.Color;
                // Clamp DiffRadiance to prevent "direction chasing" when the direction of a basis is updated
                // but its color is not converged to the correct result yet.
                float3 DiffRadianceClamped = max(RayRadiance - LocalEvaluatedRadiance[RayRank], 0.f);
                float3 TargetRadiance = DiffRadianceClamped + SGEvaluatedRadiance;
                float  RadianceWeight    = dot(TargetRadiance, 1.f.xxx);//TargetRadiance);
                // The weight for balancing sample distribution
                float  SampleWeight      = InvPdf;
                // 0529: Add a bias to reserve affection for closer light sources in the same direction
                float DirectionBias = HeuristicSGDirectionBias(SG_D.Direction, RayDirection);
                // Decay if it is closer to other SGs
                float Coverage = max(LocalRayCoverage[RayRank], Epsilon);
                float DirectionDecay =  pow(DirectionBias / Coverage, 6);
                float TotalWeight = RadianceWeight * SampleWeight * DirectionDecay;
                SumDirection  += RayDirection * TotalWeight;
            }
        }
        // Accumulate and normalize
        SumDirection = WaveActiveSum(SumDirection);
        if(dot(SumDirection, SumDirection) > 1e-6f) {
            float3 TargetDirection = normalize(SumDirection);
            // float  SrcWeight = SGIntegrate(SG_D.Lambda) * dot(SG_D.Color, 1.f.xxx) + Epsilon;
            // float  DstWeight = SumTotalWeight + Epsilon;
            // float  T = SrcWeight / (SrcWeight + DstWeight);
            float T = 0.1f;
            SG_O = SG_D;
            SG_D.Direction = normalize(lerp(SG_D.Direction, TargetDirection, T));//InterpolateDirection(SG_D.Direction, TargetDirection, T);
            if(WaveIsFirstLane()) {
                LocalSGData[BasisRankToUpdate] = SG_D;
            }
            // Re-calculate the evaluated radiance for the changed basis
            [unroll(SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
            for(int RayRankBase = 0; RayRankBase < ProbeRayCount; RayRankBase += WAVE_SIZE) {
                int RayRank  = RayRankBase + LocalID;
                int RayIndex = ProbeRayOffset + RayRank;
                float3 RayDirection      = OctahedronToUnitVector(unpackUnorm2x16(g_RWUpdateRayDirectionBuffer[RayIndex]) * 2 - 1);
                float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
                float3 RayRadiance       = RayRadianceInvPdf.xyz;
                float  InvPdf            = RayRadianceInvPdf.w;
                if(InvPdf > 0) {
                    float  RawPrevious = EvaluateSGRaw(SG_O, RayDirection);
                    float  Raw         = EvaluateSGRaw(SG_D, RayDirection);
                    float3 Delta = Raw * SG_D.Color - RawPrevious * SG_O.Color;
                    LocalEvaluatedRadiance[RayRank] += Delta;
                }
            }
        }
        GroupMemoryBarrierWithGroupSync();
    }

    // Update Color and Lambda

    int ThreadPerBasis = WAVE_SIZE / BasisCount;
    int BasisRank      = LocalID / ThreadPerBasis;
    int BasisThread    = LocalID % ThreadPerBasis;

    if(BasisRank < BasisCount) {
        SGData SG = LocalSGData[BasisRank];
        SGGradients SumStepSize = (SGGradients)0;
#ifdef OPTIMAL_COLOR_UPDATE
        float  SumAFactor = 0;
#endif
        [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * SSRC_MAX_NUM_UPDATE_RAY_PER_PROBE / WAVE_SIZE)]
        for(int RayGroupOffset = 0; RayGroupOffset < ProbeRayCount; RayGroupOffset += ThreadPerBasis) {
            int RayRank = RayGroupOffset + BasisThread;
            if(RayRank < ProbeRayCount) {
                int RayIndex = ProbeRayOffset + RayRank;
                float4 RayRadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
                float  RayLinearDepth    = g_RWUpdateRayLinearDepthBuffer[RayIndex];
                float3 RayDirection      = OctahedronToUnitVector(unpackUnorm2x16(g_RWUpdateRayDirectionBuffer[RayIndex]) * 2 - 1);
                float3 RayRadiance       = RayRadianceInvPdf.xyz;
                float  InvPdf            = RayRadianceInvPdf.w;
                if(InvPdf > 0) {
                    float  SGEvaluatedRaw      = EvaluateSGRaw(SG, RayDirection);
                    float3 SGEvaluatedRadiance = SGEvaluatedRaw * SG.Color;

                    float3 dColorExtra;
                    SGGradients Gradients;
                    EvaluateSG_Gradients(SG, RayDirection, Gradients, dColorExtra);
                    float3 DiffRadiance   = RayRadiance - LocalEvaluatedRadiance[RayRank];
                    // TODO
                    // This should be done in multi pass actually to avoid explosive radiance update
                    float3 TargetRadiance = DiffRadiance + SGEvaluatedRadiance;
                    float3 X = -2.f * DiffRadiance;
                    float  Y = dot(X, 1.f.xxx);

                    // The weight for balancing sample distribution
                    float  SampleWeight     = InvPdf;
#ifndef OPTIMAL_COLOR_UPDATE
                    SumStepSize.dColor     -= X * Gradients.dColor     * SampleWeight;
#else
                    // least squares method
                    // Clip rays that only evaluates to a tiny value on SG to prevent outflares
                    if(SGEvaluatedRaw > 2e-2f) {
                        SumAFactor                += 2.f * SGEvaluatedRaw * SGEvaluatedRaw * SampleWeight;
                        SumStepSize.dColor        += 2.f * TargetRadiance * SGEvaluatedRaw * SampleWeight;
                    }
#endif
                    // 0529: Add a bias to reserve affection for closer light sources in the same direction
                    float  HeuristicBias = HeuristicSGDirectionBias(SG.Direction, RayDirection);
                    float  DirectionalDecay  = 1.f;//pow(HeuristicBias / LocalRayCoverage[RayRank], 6);
                    SumStepSize.dLambda    -= Y * Gradients.dLambda    * SampleWeight * DirectionalDecay;
                }
            }
        }
        // Accumulate weights
#ifdef OPTIMAL_COLOR_UPDATE
        LocalAFactorSum[LocalID] = WavePrefixSum(SumAFactor);
#endif
        LocalDColorPrefixSum[LocalID]     = WavePrefixSum(SumStepSize.dColor);
        LocalDLambdaPrefixSum[LocalID]    = WavePrefixSum(SumStepSize.dLambda);
        GroupMemoryBarrierWithGroupSync();
        // The chosen thread for updating each basis
        if(BasisThread == ThreadPerBasis - 1) {
            // Accumulate and normalize
#ifdef OPTIMAL_COLOR_UPDATE
            SumAFactor = SumAFactor + LocalAFactorSum[LocalID] - LocalAFactorSum[LocalID - ThreadPerBasis + 1];
#endif
            SumStepSize.dColor        = SumStepSize.dColor + LocalDColorPrefixSum[LocalID] - LocalDColorPrefixSum[LocalID - ThreadPerBasis + 1];
            SumStepSize.dLambda       = SumStepSize.dLambda + LocalDLambdaPrefixSum[LocalID] - LocalDLambdaPrefixSum[LocalID - ThreadPerBasis + 1];
#ifdef OPTIMAL_COLOR_UPDATE
            // It's possible for SumAFactor to be very tiny (because of large SG Lambdas), so we clamp it to prevent outflares
            SumStepSize.dColor     /= max(SumAFactor, Epsilon);
#else       
            SumStepSize.dColor     /= ProbeRayCount;
#endif

            if(MI.CacheUpdate_SGColor) {
#ifdef OPTIMAL_COLOR_UPDATE
                // TODO Clamping is not the smartest choice for outflares
                // it relates to lambda and importance sampling
                float Factor =  min(MI.CacheUpdateLearningRate + ImpactFactors.x, 1.f);
                // Allow the color of the SG with updated direction to change violently
                // if(MI.CacheUpdate_SGDirection && BasisRank == GetBasisRankToUpdate(BasisCount)) {
                //     Factor = max(Factor, 0.2f);
                // }
                float3 NewColor = lerp(SG.Color, SumStepSize.dColor, Factor);
                float3 DeltaColor = NewColor - SG.Color;
                SG.Color += DeltaColor;
#else
                SG.Color += SumStepSize.dColor     * MI.CacheUpdateLearningRate * (1 + ImpactFactors.x);
#endif
                SG.Color = max(SG.Color, 0.0001f.xxx); // Color is in [0.001, inf)
            }
            if(MI.CacheUpdate_SGLambda) {
                float Step = SumStepSize.dLambda    * MI.CacheUpdateLearningRate * (1 + ImpactFactors.z);
                // Clamp the step
                // Step = sign(Step) * min(abs(Step), max(SG.Lambda * 0.2f, 0.1f));
                SG.Lambda    += Step;
                // Decay to make it more stable
                // SG.Lambda     = SG.Lambda >= 1.5 ? SG.Lambda * 0.95f : SG.Lambda;
                // SG.Lambda = 5.f;
                SG.Lambda    = clamp(SG.Lambda, 1.5f, 100.f); // Lambda is in [1.5f, 100.f]
            }

            // Write back
            WriteBasisData(Header.BasisOffset + BasisRank, SG);
        }
    }
}


[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_IntegrateASG (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * MI.TileDimensions.x;
    int2 TileTextureBaseOffset = int2(GroupID) * SSRC_TILE_SIZE;
    const int PIXEL_PER_THREAD = SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE;
    for(int i = 0; i< PIXEL_PER_THREAD; i++) {
        int PixelIndex = i * WAVE_SIZE + LocalID;
        // Operate in subtiles (8x8) to get better coherency in loop branching
        // with the more likely the same number of basis to access for each thread
        int SubtileIndex  = PixelIndex / (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int SubPixelIndex = PixelIndex % (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int PixelX = (SSRC_TILE_SIZE/2) * (SubtileIndex % 2) + SubPixelIndex % (SSRC_TILE_SIZE/2);
        int PixelY = (SSRC_TILE_SIZE/2) * (SubtileIndex / 2) + SubPixelIndex / (SSRC_TILE_SIZE/2);
        int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
        float2 UV = (TexCoords + 0.5f) / MI.ScreenDimensions;
        float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
        if(Depth < 1.f) {
            float LinearDepth   = GetLinearDepth(Depth);
            // Texture coordinates
            float4 Visibility   = g_VisibilityTexture[TexCoords];
            float2 Barycentrics = Visibility.xy;
            uint   InstanceID   = asuint(Visibility.z);
            uint   PrimitiveID  = asuint(Visibility.w);

            Instance InstanceData = g_InstanceBuffer[InstanceID];
            Mesh     mesh     = g_MeshBuffer[InstanceData.mesh_index];

            Triangle vertices = fetchVertices(mesh, PrimitiveID);

            // Reconstruct world space position from barycentrics
            float3x4 transform = g_TransformBuffer[InstanceData.transform_index];
            vertices.v0 = transformPoint(vertices.v0, transform);
            vertices.v1 = transformPoint(vertices.v1, transform);
            vertices.v2 = transformPoint(vertices.v2, transform);

            // Frame
            float3 WorldPosition = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);
            float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
            float3 ShadingNormal  = normalize(2.f * g_ShadingNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);

            UVs PrimitiveUVs = fetchUVs(g_MeshBuffer[InstanceData.mesh_index], PrimitiveID);
            float2 MeshUV = interpolate(PrimitiveUVs.uv0, PrimitiveUVs.uv1, PrimitiveUVs.uv2, Barycentrics);
            Material MaterialData = g_MaterialBuffer[InstanceData.material_index];
            MaterialEmissive EmissiveMaterialData = MakeMaterialEmissive(MaterialData, MeshUV);
            MaterialBRDF MaterialBRDFData = MakeMaterialBRDF(MaterialData, MeshUV);
            
            float3 ViewDirection = normalize(MI.CameraPosition - WorldPosition);
            float DotNV = saturate(dot(ShadingNormal, ViewDirection));

            SSRC_SampleData Sample;
            CalculateSSRCSampleWeights(
                TexCoords + 0.5f,
                WorldPosition,
                LinearDepth, 
                GeometryNormal,
                Sample
            );

            ProbeHeader Headers[4];
            Headers[0] = GetScreenProbeHeader(Sample.Index[0]);
            Headers[1] = GetScreenProbeHeader(Sample.Index[1]);
            Headers[2] = GetScreenProbeHeader(Sample.Index[2]);
            Headers[3] = GetScreenProbeHeader(Sample.Index[3]);
            int BasisCounts[4];
            BasisCounts[0] = GetProbeBasisCountFromClass(Headers[0].Class);
            BasisCounts[1] = GetProbeBasisCountFromClass(Headers[1].Class);
            BasisCounts[2] = GetProbeBasisCountFromClass(Headers[2].Class);
            BasisCounts[3] = GetProbeBasisCountFromClass(Headers[3].Class);
            int BasisCount0 = BasisCounts[0] + BasisCounts[1];
            int BasisCount1 = BasisCounts[2] + BasisCounts[3];
            int BasisCount  = BasisCount0 + BasisCount1;
            // Normalize weights
            Sample.Weights /= max(dot(Sample.Weights, 1.f.xxxx), 0.01f);
            if(dot(Sample.Weights, 1.f.xxxx) > 0.99f) {
                float3 SumRadiance = 0.f.xxx;

                [unroll(SSRC_MAX_NUM_BASIS_PER_PROBE * 4)]
                for(int BasisRank = 0; BasisRank < BasisCount; BasisRank++) {
                    int ProbeRank, ProbeBasisIndex;
                    if(BasisRank < BasisCount0) {
                        ProbeRank = BasisRank < BasisCounts[0] ? 0 : 1;
                        ProbeBasisIndex = BasisRank - (BasisRank < BasisCounts[0] ? 0 : BasisCounts[0]);
                    } else {
                        ProbeBasisIndex = BasisRank - BasisCount0;
                        ProbeRank = ProbeBasisIndex < BasisCounts[2] ? 2 : 3;
                        ProbeBasisIndex -= (ProbeBasisIndex < BasisCounts[2] ? 0 : BasisCounts[2]);
                    }
                    int BasisIndex = Headers[ProbeRank].BasisOffset + ProbeBasisIndex;
                    SGData SG = FetchBasisData(BasisIndex);
                    float3 LightDirection = SG.Direction;
                    float3 ReflectionDirection = calculateGGXSpecularDirection(ShadingNormal, ViewDirection, sqrt(MaterialBRDFData.roughnessAlpha));
                    float3 HalfVector = normalize(LightDirection + ViewDirection);
                    float3 HalfVector_Spec = normalize(ReflectionDirection + ViewDirection);
                    float dotNL = saturate(dot(LightDirection, ShadingNormal));
                    float dotNV = saturate(dot(ShadingNormal, ViewDirection));
                    float dotHV = saturate(dot(HalfVector, ViewDirection));
                    float dotSpecHV = saturate(dot(HalfVector_Spec, ViewDirection));
                    // Approximate \int D * Li with ASG
                    // we use RoughnessAlpha here
                    float3 GGX_D_Li_Approx = SpecularTermASGWarp(SG, ShadingNormal, MaterialBRDFData.roughnessAlphaSqr, ViewDirection);
                    float3 FresnelTerm = fresnel(MaterialBRDFData.F0, dotHV);
                    float  VisibilityTerm   = evaluateVisibilityGGX(MaterialBRDFData.roughnessAlphaSqr, dotNL, dotNV);
                    float3 GGXIntegrationApprox = (FresnelTerm / VisibilityTerm) * GGX_D_Li_Approx;
                    float3 DiffuseCompensation = diffuseCompensationTerm(FresnelTerm, dotSpecHV);
                    float3 LambertIntegration = SGDiffuseInnerProduct(SG, ShadingNormal, MaterialBRDFData.albedo)* DiffuseCompensation;
                    SumRadiance += (GGXIntegrationApprox + LambertIntegration) * Sample.Weights[ProbeRank];
                }
                // Irradiance shading 
                for(int CornerIndex = 0; CornerIndex < 4; CornerIndex ++) {
                    // this is probably the cause for outflares
                    // outflares!!
                    // FIXME why i can not fill Headers[CornerIndex].bValid here? (rare outflares)
                    if(Sample.Weights[CornerIndex] > 0.f) { 
                        float3 IrradianceSGColor = Headers[CornerIndex].Irradiance;
                        SGData SG = GetIrradianceSG(Headers[CornerIndex].Normal, IrradianceSGColor);
                        float3 LightDirection = SG.Direction;
                        float3 ReflectionDirection = calculateGGXSpecularDirection(ShadingNormal, ViewDirection, sqrt(MaterialBRDFData.roughnessAlpha));
                        float3 HalfVector = normalize(LightDirection + ViewDirection);
                        float3 HalfVector_Spec = normalize(ReflectionDirection + ViewDirection);
                        float dotNL = saturate(dot(LightDirection, ShadingNormal));
                        float dotNV = saturate(dot(ShadingNormal, ViewDirection));
                        float dotHV = saturate(dot(HalfVector, ViewDirection));
                        float dotSpecHV = saturate(dot(HalfVector_Spec, ViewDirection));
                        // Approximate \int D * Li with ASG
                        // we use RoughnessAlpha here
                        float3 GGX_D_Li_Approx = SpecularTermASGWarp(SG, ShadingNormal, MaterialBRDFData.roughnessAlphaSqr, ViewDirection);
                        float3 FresnelTerm = fresnel(MaterialBRDFData.F0, dotHV);
                        float  VisibilityTerm   = evaluateVisibilityGGX(MaterialBRDFData.roughnessAlphaSqr, dotNL, dotNV);
                        float3 GGXIntegrationApprox = (FresnelTerm / VisibilityTerm) * GGX_D_Li_Approx;
                        float3 DiffuseCompensation = diffuseCompensationTerm(FresnelTerm, dotSpecHV);
                        float3 LambertIntegration = SGDiffuseInnerProduct(SG, ShadingNormal, MaterialBRDFData.albedo)* DiffuseCompensation;
                        SumRadiance += (GGXIntegrationApprox + LambertIntegration) * Sample.Weights[CornerIndex];
                    }
                }
                // Store shading results
                float3 Emission = EmissiveMaterialData.emissive;
                g_RWGlobalIlluminationOutput[TexCoords] = 
                    float4(GIDenoiser_RemoveNaNs(SumRadiance + Emission), 1.0f);
            } else {
                g_RWGlobalIlluminationOutput[TexCoords] = float4(0.f, 0.f, 0.f, 0.0f);
            }
        } else {
            g_RWGlobalIlluminationOutput[TexCoords] = float4(0.f, 0.f, 0.f, 0.0f);
        }
    }
}

#define MAX_TEMPORAL_ACCUMULATION 10

[numthreads(WAVE_SIZE, 1, 1)]
void SSRC_Denoise (int2 GroupID : SV_GroupID, int LocalID : SV_GroupThreadID) {
    int TileID = GroupID.x + GroupID.y * MI.TileDimensions.x;
    int2 TileTextureBaseOffset = int2(GroupID) * SSRC_TILE_SIZE;
    const int PIXEL_PER_THREAD = SSRC_TILE_SIZE * SSRC_TILE_SIZE / WAVE_SIZE;
    for(int i = 0; i< PIXEL_PER_THREAD; i++) {
        int PixelIndex = i * WAVE_SIZE + LocalID;
        // Operate in subtiles (8x8) to get better coherency in loop branching
        // with the more likely the same number of basis to access for each thread
        int SubtileIndex  = PixelIndex / (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int SubPixelIndex = PixelIndex % (SSRC_TILE_SIZE * SSRC_TILE_SIZE / 4);
        int PixelX = (SSRC_TILE_SIZE/2) * (SubtileIndex % 2) + SubPixelIndex % (SSRC_TILE_SIZE/2);
        int PixelY = (SSRC_TILE_SIZE/2) * (SubtileIndex / 2) + SubPixelIndex / (SSRC_TILE_SIZE/2);
        int2 TexCoords = TileTextureBaseOffset + int2(PixelX, PixelY);
        float2 UV = (TexCoords + 0.5f) / MI.ScreenDimensions;
        float Depth = g_DepthTexture.Load(int3(TexCoords, 0)).x;
        if(Depth < 1.f) {
            float LinearDepth   = GetLinearDepth(Depth);
            // Texture coordinates
            float4 Visibility   = g_VisibilityTexture[TexCoords];
            float2 Barycentrics = Visibility.xy;
            uint   InstanceID   = asuint(Visibility.z);
            uint   PrimitiveID  = asuint(Visibility.w);

            Instance InstanceData = g_InstanceBuffer[InstanceID];
            Mesh     mesh     = g_MeshBuffer[InstanceData.mesh_index];

            Triangle vertices = fetchVertices(mesh, PrimitiveID);

            // Reconstruct world space position from barycentrics
            float3x4 transform = g_TransformBuffer[InstanceData.transform_index];
            vertices.v0 = transformPoint(vertices.v0, transform);
            vertices.v1 = transformPoint(vertices.v1, transform);
            vertices.v2 = transformPoint(vertices.v2, transform);

            // Frame
            float3 WorldPosition = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);
            float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
            float3 ShadingNormal  = normalize(2.f * g_ShadingNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);

            UVs PrimitiveUVs = fetchUVs(g_MeshBuffer[InstanceData.mesh_index], PrimitiveID);
            float2 MeshUV = interpolate(PrimitiveUVs.uv0, PrimitiveUVs.uv1, PrimitiveUVs.uv2, Barycentrics);
            Material MaterialData = g_MaterialBuffer[InstanceData.material_index];
            MaterialEmissive EmissiveMaterialData = MakeMaterialEmissive(MaterialData, MeshUV);
            MaterialBRDF MaterialBRDFData = MakeMaterialBRDF(MaterialData, MeshUV);
            
            float3 ViewDirection = normalize(MI.CameraPosition - WorldPosition);

            
            float4 NewLightingW = g_RWGlobalIlluminationOutput[TexCoords];
            float3 NewLighting  = NewLightingW.xyz;
            float  NewLightingValid = NewLightingW.w;
            float3 HistoryLighting = 0.f;
            float  Alpha           = NewLightingValid > 0 ? 1.f : 0.f;
            float  TotalSamples    = NewLightingValid > 0 ? 1.f : 0.f;

            // Reproject to previous frame
            float2 PreviousUV = UV - g_VelocityTexture.SampleLevel(g_NearestSampler, UV, 0.0f).xy;

            if (all(PreviousUV > 0.0f) && all(PreviousUV < 1.0f))
            {
                float3 Homogeneous     = float3(UV2NDC2(UV), Depth);
                float3 HomogeneousPrev = transformPointProjection(Homogeneous, MI.Reprojection);
                float  PreviousLinearDepth = GetLinearDepth(HomogeneousPrev.z);

                float2 PixelScale2 = 0.5f / MI.ScreenDimensions;

                float4 HistoryGBufferDepths  = g_PreviousDepthTexture.GatherRed(g_ClampedPointSampler, PreviousUV + PixelScale2 * 0.99f).wzxy;
                float4 HistoryLinearDepths   = float4(
                    GetLinearDepth(HistoryGBufferDepths.x),
                    GetLinearDepth(HistoryGBufferDepths.y),
                    GetLinearDepth(HistoryGBufferDepths.z),
                    GetLinearDepth(HistoryGBufferDepths.w)
                );
                // Lumen alike method, jitter disocclusion threshold
                float Noise = BlueNoise_Sample1D(uint2(PixelX, PixelY), MI.FrameIndex, 3);
                float HistoryDistanceThreshold = 0.005f;
                float DisocclusionDistanceThreshold = HistoryDistanceThreshold * lerp(0.5f, 1.5f, Noise);
                DisocclusionDistanceThreshold /= clamp(saturate(dot(ViewDirection, GeometryNormal)), .1f, 1.0f); 
                float4 DepthDistances    = abs(HistoryLinearDepths - PreviousLinearDepth);
                float4 OcclusionWeights  = select(DepthDistances >= PreviousLinearDepth * DisocclusionDistanceThreshold, 1.f, 0.f);
                float4 VisibilityWeights = saturate(1.f - OcclusionWeights);
                float2 SubPixelPos       = frac(clamp(PreviousUV * MI.ScreenDimensions + 0.495f, 0, MI.ScreenDimensions));
                float4 BilinearWeights   = float4(
                    (1.f - SubPixelPos.x) * (1.f - SubPixelPos.y),
                    SubPixelPos.x * (1.f - SubPixelPos.y),
                    (1.f - SubPixelPos.x) * SubPixelPos.y,
                    SubPixelPos.x * SubPixelPos.y
                );
                float4 FinalWeights = BilinearWeights * VisibilityWeights;
                FinalWeights = FinalWeights / max(dot(FinalWeights, 1.f.xxxx), 1e-5f);

                float4 HistorySamples    = 
                    g_PreviousHistoryAccumulationTexture.GatherRed(g_ClampedPointSampler, PreviousUV + PixelScale2 * 0.99f).wzxy
                    * MAX_TEMPORAL_ACCUMULATION;
                TotalSamples = dot(min(HistorySamples + NewLightingValid, MAX_TEMPORAL_ACCUMULATION) * FinalWeights, 1.f.xxxx);
                TotalSamples = min(TotalSamples, MAX_TEMPORAL_ACCUMULATION);
                
                Alpha = NewLightingValid / max(TotalSamples, 1.f);
                
                {
                    // Note: PrevCombinedGlobalIllumination includes the skybox, so we manually keep a copy of ours
                    float3 HistoryLightingX00 = g_PreviousGlobalIlluminationTexture.SampleLevel(
                        g_ClampedPointSampler, PreviousUV + float2(-PixelScale2.x, -PixelScale2.y), 0.f
                    ).xyz;
                    float3 HistoryLightingX10 = g_PreviousGlobalIlluminationTexture.SampleLevel(
                        g_ClampedPointSampler, PreviousUV + float2( PixelScale2.x, -PixelScale2.y), 0.f
                    ).xyz;
                    float3 HistoryLightingX01 = g_PreviousGlobalIlluminationTexture.SampleLevel(
                        g_ClampedPointSampler, PreviousUV + float2(-PixelScale2.x,  PixelScale2.y), 0.f
                    ).xyz;
                    float3 HistoryLightingX11 = g_PreviousGlobalIlluminationTexture.SampleLevel(
                        g_ClampedPointSampler, PreviousUV + float2( PixelScale2.x,  PixelScale2.y), 0.f
                    ).xyz;
                    HistoryLighting = 
                        HistoryLightingX00 * BilinearWeights.x + 
                        HistoryLightingX10 * BilinearWeights.y + 
                        HistoryLightingX01 * BilinearWeights.z + 
                        HistoryLightingX11 * BilinearWeights.w;
                }
            }

            g_RWGlobalIlluminationOutput[TexCoords] = float4(lerp(HistoryLighting, NewLighting, Alpha), 1.0f);
            g_RWHistoryAccumulationTexture[TexCoords] = TotalSamples / MAX_TEMPORAL_ACCUMULATION;
        } else{
            g_RWHistoryAccumulationTexture[TexCoords] = 0.f;
        }

    }

}

// [numthreads(WAVE_SIZE, 1, 1)]
// void SSRC_AccumulateUpdateError (int DispatchID : SV_DispatchThreadID) {
//     // >= 96 registers for each thread (meanwhile < 128)
//     // anyway that's not big deal
//     float ThreadErrorAccumulation[SSRC_TILE_SIZE][SSRC_TILE_SIZE];
//     float ThreadErrorAccumulationWeight[SSRC_TILE_SIZE][SSRC_TILE_SIZE];
//     for(int i = 0; i<SSRC_TILE_SIZE; i++) 
//         for(int j = 0; j<SSRC_TILE_SIZE; j++) {
//             ThreadErrorAccumulation[i][j] = 0;
//         }
//     for(int i = 0; i<SSRC_TILE_SIZE; i++) 
//         for(int j = 0; j<SSRC_TILE_SIZE; j++) {
//             ThreadErrorAccumulationWeight[i][j] = 0;
//         }
//     int2 TileCoords = int2(DispatchID % g_TileDimensions.x, DispatchID / g_TileDimensions.x);
//     int2 TexOffset = TileCoords * SSRC_TILE_SIZE;
//     int TileID = DispatchID;
//     int TileRayCount = g_RWTileRayCountBuffer[TileID];
//     int TileRayOffset = g_RWTileRayOffsetBuffer[TileID];
//     for(int TileRayRank = 0; TileRayRank < TileRayCount; TileRayRank++) {
//         int RayIndex = TileRayOffset + TileRayRank;
//         int2 TexCoords  = UnpackUint16x2(g_RWUpdateRayOriginBuffer[RayIndex]);
//         float4 RadianceInvPdf = UnpackFp16x4(g_RWUpdateRayRadianceInvPdfBuffer[RayIndex]);
//         if(RadianceInvPdf.w > 0) {
//             float3 Error    = RadianceInvPdf.xyz;
//             float  InvPdf   = RadianceInvPdf.w;

//             float  Contrib  = (dot(Error, Error) ) * InvPdf;

//             // Accumulate the error
//             int2  PixelCoords = TexCoords - TexOffset;
//             ThreadErrorAccumulation[PixelCoords.y][PixelCoords.x] += Contrib;
//             ThreadErrorAccumulationWeight[PixelCoords.y][PixelCoords.x] += InvPdf;
//         }
//     }
//     for(int j = 0; j<SSRC_TILE_SIZE; j++) {
//         for(int i = 0; i<SSRC_TILE_SIZE; i++) {
//             int2 TexCoords = TexOffset + int2(i, j);
//             float Error  = ThreadErrorAccumulation[j][i];
//             float Weight = ThreadErrorAccumulationWeight[j][i];
//             float PrevError = g_RWUpdateErrorSplatTexture[TexCoords];
//             if(Weight > 0) {
//                 g_RWUpdateErrorSplatTexture[TexCoords] = lerp(PrevError, Error / Weight, 0.005f);
//             } else {
//                 g_RWUpdateErrorSplatTexture[TexCoords] = lerp(PrevError, 0.f,  0.005f);
//             }
//         }
//     }
// }

// [numthreads(8, 8, 1)]
// void DebugSSRC_ShowDifference (uint2 DispatchID : SV_DispatchThreadID) {
//     if(any(DispatchID >= MI.ScreenDimensions)) {
//         return;
//     }
//     if(g_DebugVisualizeMode == 0) {
//         float Depth = g_DepthTexture.Load(int3(DispatchID, 0)).x;
//         if(Depth < 1.f) {
//             float2 UV = (DispatchID + 0.5f.xx) / MI.ScreenDimensions;
//             float Difference = g_UpdateErrorSplatTexture.SampleLevel(g_LinearSampler, UV, ERROR_BLUR_LOD).x;
//             g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(Difference * g_DebugTonemapExposure), 1.f);
//         } else {
//             g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
//         }
//     } else if(g_DebugVisualizeMode == 1) {
//         int2 TileCoords = DispatchID / SSRC_TILE_SIZE;
//         int TileID = TileCoords.x + TileCoords.y * g_TileDimensions.x;
//         int TileRayCount = g_RWTileRayCountBuffer[TileID];
//         if(TileRayCount == 0) {
//             g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
//         } else {
//             g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(TileRayCount / 128.f), 1.f);
//         }
//     } else if(g_DebugVisualizeMode == 2) {
//         float Depth = g_DepthTexture.Load(int3(DispatchID, 0)).x;
//         if(Depth < 1.f) {
//             float Difference = g_UpdateErrorSplatTexture.Load(int3(DispatchID, 0)).x;
//             g_RWDebugOutput[DispatchID] = float4(ColorHeatMap(Difference * g_DebugTonemapExposure), 1.f);
//         } else {
//             g_RWDebugOutput[DispatchID] = float4(0.f, 0.f, 0.f, 0.0f);
//         }
//     }
// }

// ***********************************************
// *                 Misc                        *
// ***********************************************


// [numthreads(1, 1, 1)]
// void DebugSSRC_GenerateDrawIndexed (uint DispatchID : SV_DispatchThreadID) {
//     DrawIndexedCommand draw_command;
//     draw_command.index_count_per_instance = 3;
//     draw_command.instance_count  = g_RWActiveBasisCountBuffer[0];
//     draw_command.index_offset    = 0;
//     draw_command.vertex_offset   = 0;
//     draw_command.instance_offset = 0;
//     g_RWDrawIndexedCommandBuffer[0] = draw_command;
// }

[numthreads(1, 1, 1)]
void DebugSSRC_FetchCursorPos (uint DipspatchID : SV_DispatchThreadID) {
    float4 Visibility = g_VisibilityTexture.Load(int3(MI.DebugCursorPixelCoords, 0));
    float2 Barycentrics = Visibility.xy;
    uint InstanceID = asuint(Visibility.z);
    uint PrimitiveID = asuint(Visibility.w);
    Instance InstanceData = g_InstanceBuffer[InstanceID];
    Mesh mesh = g_MeshBuffer[InstanceData.mesh_index];
    Triangle vertices = fetchVertices(mesh, PrimitiveID);
    float3x4 transform = g_TransformBuffer[InstanceData.transform_index];
    vertices.v0 = transformPoint(vertices.v0, transform);
    vertices.v1 = transformPoint(vertices.v1, transform);
    vertices.v2 = transformPoint(vertices.v2, transform);
    float3 WorldPosition = interpolate(vertices.v0, vertices.v1, vertices.v2, Barycentrics);
    g_RWDebugCursorWorldPosBuffer[0] = WorldPosition;
}

[numthreads(WAVE_SIZE, 1, 1)]
void DebugSSRC_VisualizeProbePlacement (int DispatchID : SV_DispatchThreadID) {
    int2 ProbeIndex = int2(DispatchID % MI.TileDimensions.x, DispatchID / MI.TileDimensions.x);
    if(ProbeIndex.x >= MI.TileDimensions.x || ProbeIndex.y >= MI.TileDimensions.y) {
        return;
    }
    int2 UniformProbeScreenCoords = GetUniformScreenProbeScreenCoords(ProbeIndex);

    if(all(UniformProbeScreenCoords >= 0) && all(UniformProbeScreenCoords < MI.ScreenDimensions)
    && IsScreenProbeValid(ProbeIndex))
        g_RWDebugOutput[UniformProbeScreenCoords] = float4(10.f.xxx, 1.f);
    // Visualize adaptive probes
    int  AdaptiveProbeCount = g_RWTileAdaptiveProbeCountTexture[ProbeIndex];
    for(int i = 0; i < AdaptiveProbeCount; i++) {
        int  ScreenProbeIndex1 = GetAdaptiveProbeIndex(ProbeIndex, i) + MI.UniformScreenProbeCount;
        int2 AdaptiveProbeIndex = int2(ScreenProbeIndex1 % MI.TileDimensions.x, ScreenProbeIndex1 / MI.TileDimensions.x);
        ProbeHeader Header = GetScreenProbeHeader(AdaptiveProbeIndex);
        int2 AdaptiveProbeScreenCoords = Header.ScreenCoords;
        g_RWDebugOutput[AdaptiveProbeScreenCoords] = float4(10.f.xxx, 1.f);
    }
}

[numthreads(WAVE_SIZE, 1, 1)]
void DebugSSRC_PrepareProbeIncidentRadiance (uint DispatchID : SV_DispatchThreadID) {
    if(DispatchID >= MI.DebugVisualizeIncidentRadianceNumPoints) {
        return;
    }
    if(DispatchID == 0) {
        // 3 channel sum
        g_RWReduceCountBuffer[0] = MI.DebugVisualizeIncidentRadianceNumPoints * 3;
    }
    float3 Direction      = FibonacciSphere(DispatchID, MI.DebugVisualizeIncidentRadianceNumPoints);
    float3 DebugWorldPos  = g_RWDebugCursorWorldPosBuffer[0];
    float3 Homogeneous    = transformPointProjection(DebugWorldPos, MI.CameraProjView);
    float2 UV             = NDC22UV(Homogeneous.xy);
    int2   TexCoords      = int2(UV * MI.ScreenDimensions);
    
    int2   TileIndex       = int2(TexCoords.x / SSRC_TILE_SIZE, TexCoords.y / SSRC_TILE_SIZE);
    int2   ProbeIndex      = TileIndex;
    ProbeHeader Header     = GetScreenProbeHeader(ProbeIndex);
    float  MinScreenDistance = Header.bValid ? length(UV - Header.ScreenCoords - 0.5) : 1e6f;
    int AdaptiveProbeCount = g_RWTileAdaptiveProbeCountTexture[TileIndex];
    for(int AdaptiveProbeRank = 0; AdaptiveProbeRank < AdaptiveProbeCount; AdaptiveProbeRank++) {
        int ScreenProbeIndex1 = GetAdaptiveProbeIndex(ProbeIndex, AdaptiveProbeRank) + MI.UniformScreenProbeCount;
        int2 ScreenProbeIndex = int2(ScreenProbeIndex1 % MI.TileDimensions.x, ScreenProbeIndex1 / MI.TileDimensions.x);
        ProbeHeader AdaptiveHeader = GetScreenProbeHeader(ScreenProbeIndex);
        float ScreenDistance  = length(UV - AdaptiveHeader.ScreenCoords - 0.5);
        if(!Header.bValid || ScreenDistance < MinScreenDistance) {
            ProbeIndex = ScreenProbeIndex;
            Header = AdaptiveHeader;
            MinScreenDistance = ScreenDistance;
        }
    }

    if(DispatchID == 0) {
        g_RWDebugProbeWorldPositionBuffer[0] = Header.Position;
        g_RWDebugProbeIndexBuffer[0]         = ProbeIndex;
    }
    
    int BasisCount = GetProbeBasisCountFromClass(Header.Class);

    float3 SumRadiance = 0.f.xxx;
    for(int i = 0; i < BasisCount; i++) {
        int BasisIndex = Header.BasisOffset + i;
        SGData SG = FetchBasisData(BasisIndex);
        float3 EvaluatedSG   = EvaluateSG(SG, Direction);
        SumRadiance += EvaluatedSG;
    }
    SGData IrradianceSG = GetIrradianceSG(Header.Normal, Header.Irradiance);
    g_RWDebugVisualizeIncidentRadianceBuffer[DispatchID] = SumRadiance + EvaluateSG(IrradianceSG, Direction);
}

[numthreads(1, 1, 1)]
void DebugSSRC_PrepareUpdateRays () {
    int2   TexCoords      = MI.DebugCursorPixelCoords;
    float  Depth          = g_DepthTexture.Load(int3(TexCoords, 0)).x;
    if(Depth < 1.f) {
        float3 GeometryNormal = normalize(2.f * g_GeometryNormalTexture.Load(int3(TexCoords, 0)).xyz - 1.f);
        SSRC_SampleData Sample;
        CalculateSSRCSampleWeights(
            TexCoords + 0.5f,
            g_RWDebugCursorWorldPosBuffer[0],
            GetLinearDepth(Depth),
            GeometryNormal,
            Sample
        );
        int MaxIndex;
        if(Sample.Weights[0] > Sample.Weights[1]) {
            MaxIndex = 0;
        } else {
            MaxIndex = 1;
        }
        if(Sample.Weights[2] > Sample.Weights[MaxIndex]) {
            MaxIndex = 2;
        }
        if(Sample.Weights[3] > Sample.Weights[MaxIndex]) {
            MaxIndex = 3;
        }
        if(Sample.Weights[MaxIndex] != 0) {
            int2 ProbeIndex  = Sample.Index[MaxIndex];
            g_RWDebugProbeIndexBuffer[0] = ProbeIndex;
            int  ProbeIndex1 = ProbeIndex.x + ProbeIndex.y * MI.TileDimensions.x;
            int  ProbeRayCount = g_RWProbeUpdateRayCountBuffer[ProbeIndex1];
            DrawCommand draw_command = (DrawCommand)0;
            draw_command.vertex_count_per_instance = 2;
            draw_command.instance_count  = ProbeRayCount;
            draw_command.vertex_offset   = 0;
            draw_command.instance_offset = 0;
            g_RWDrawCommandBuffer[0] = draw_command;
        } else {
            DrawCommand draw_command = (DrawCommand)0;
            draw_command.vertex_count_per_instance = 0;
            draw_command.instance_count  = 0;
            draw_command.vertex_offset   = 0;
            draw_command.instance_offset = 0;
            g_RWDrawCommandBuffer[0] = draw_command;
        }
    } else {
        DrawCommand draw_command = (DrawCommand)0;
        draw_command.vertex_count_per_instance = 0;
        draw_command.instance_count  = 0;
        draw_command.vertex_offset   = 0;
        draw_command.instance_offset = 0;
        g_RWDrawCommandBuffer[0] = draw_command;
    }
}



// New line required for termination.
